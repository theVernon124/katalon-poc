'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _helpersJs = require('../helpers.js');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _appiumSupport = require('appium-support');

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _logcat = require('../logcat');

var _logcat2 = _interopRequireDefault(_logcat);

var _asyncbox = require('asyncbox');

var _teen_process = require('teen_process');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var SETTINGS_HELPER_ID = 'io.appium.settings';
var WIFI_CONNECTION_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.WiFiConnectionSettingReceiver';
var WIFI_CONNECTION_SETTING_ACTION = SETTINGS_HELPER_ID + '.wifi';
var DATA_CONNECTION_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.DataConnectionSettingReceiver';
var DATA_CONNECTION_SETTING_ACTION = SETTINGS_HELPER_ID + '.data_connection';
var ANIMATION_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.AnimationSettingReceiver';
var ANIMATION_SETTING_ACTION = SETTINGS_HELPER_ID + '.animation';
var LOCALE_SETTING_RECEIVER = SETTINGS_HELPER_ID + '/.receivers.LocaleSettingReceiver';
var LOCALE_SETTING_ACTION = SETTINGS_HELPER_ID + '.locale';
var LOCATION_SERVICE = SETTINGS_HELPER_ID + '/.LocationService';
var MAX_SHELL_BUFFER_LENGTH = 1000;

var methods = {};

/**
 * Get the path to adb executable amd assign it
 * to this.executable.path and this.binaries.adb properties.
 *
 * @return {string} Full path to adb executable.
 */
methods.getAdbWithCorrectAdbPath = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("adb"));

      case 2:
        this.executable.path = context$1$0.sent;

        this.binaries.adb = this.executable.path;
        return context$1$0.abrupt('return', this.adb);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the full path to aapt tool and assign it to
 * this.binaries.aapt property
 */
methods.initAapt = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("aapt"));

      case 2:
        this.binaries.aapt = context$1$0.sent;

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the full path to zipalign tool and assign it to
 * this.binaries.zipalign property
 */
methods.initZipAlign = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("zipalign"));

      case 2:
        this.binaries.zipalign = context$1$0.sent;

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the API level of the device under test.
 *
 * @return {number} The API level as integer number, for example 21 for
 *                  Android Lollipop. The result of this method is cached, so all the further
 * calls return the same value as the first one.
 */
methods.getApiLevel = function callee$0$0() {
  var strOutput;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (_lodash2['default'].isInteger(this._apiLevel)) {
          context$1$0.next = 13;
          break;
        }

        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getDeviceProperty('ro.build.version.sdk'));

      case 4:
        strOutput = context$1$0.sent;

        this._apiLevel = parseInt(strOutput.trim(), 10);

        if (!isNaN(this._apiLevel)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('The actual output "' + strOutput + '" cannot be converted to an integer');

      case 8:
        context$1$0.next = 13;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('Error getting device API level. Original error: ' + context$1$0.t0.message);

      case 13:
        _loggerJs2['default'].debug('Device API level: ' + this._apiLevel);
        return context$1$0.abrupt('return', this._apiLevel);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

/**
 * Retrieve the platform version of the device under test.
 *
 * @return {string} The platform version as a string, for example '5.0' for
 * Android Lollipop.
 */
methods.getPlatformVersion = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info("Getting device platform version");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getDeviceProperty('ro.build.version.release'));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('Error getting device platform version. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
};

/**
 * Verify whether a device is connected.
 *
 * @return {boolean} True if at least one device is visible to adb.
 */
methods.isDeviceConnected = function callee$0$0() {
  var devices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 2:
        devices = context$1$0.sent;
        return context$1$0.abrupt('return', devices.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Recursively create a new folder on the device under test.
 *
 * @param {string} remotePath - The new path to be created.
 * @return {string} mkdir command output.
 */
methods.mkdir = function callee$0$0(remotePath) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['mkdir', '-p', remotePath]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Verify whether the given argument is a
 * valid class name.
 *
 * @param {string} classString - The actual class name to be verified.
 * @return {?Array.<Match>} The result of Regexp.exec operation
 *                          or _null_ if no matches are found.
 */
methods.isValidClass = function (classString) {
  // some.package/some.package.Activity
  return new RegExp(/^[a-zA-Z0-9\./_]+$/).exec(classString);
};

/**
 * Force application to stop on the device under test.
 *
 * @param {string} pkg - The package name to be stopped.
 * @return {string} The output of the corresponding adb command.
 */
methods.forceStop = function callee$0$0(pkg) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['am', 'force-stop', pkg]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Clear the user data of the particular application on the device
 * under test.
 *
 * @param {string} pkg - The package name to be cleared.
 * @return {string} The output of the corresponding adb command.
 */
methods.clear = function callee$0$0(pkg) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'clear', pkg]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Grant all permissions requested by the particular package.
 * This method is only useful on Android 6.0+ and for applications
 * that support components-based permissions setting.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} apk - The path to the actual apk file.
 * @return {string|boolean} The output of the corresponding adb command
 *                          or _false_ if there was an error during command execution.
 */
methods.grantAllPermissions = function callee$0$0(pkg, apk) {
  var apiLevel, targetSdk, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _ret;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;
        targetSdk = null;
        context$1$0.prev = 4;

        if (apk) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.targetSdkVersionUsingPKG(pkg));

      case 8:
        targetSdk = context$1$0.sent;
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.targetSdkVersionFromManifest(apk));

      case 13:
        targetSdk = context$1$0.sent;

      case 14:
        context$1$0.next = 19;
        break;

      case 16:
        context$1$0.prev = 16;
        context$1$0.t0 = context$1$0['catch'](4);

        //avoiding logging error stack, as calling library function would have logged
        _loggerJs2['default'].warn('Ran into problem getting target SDK version; ignoring...');

      case 19:
        if (!(apiLevel >= 23 && targetSdk >= 23)) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((function callee$1$0() {
          var stdout, requestedPermissions, grantedPermissions, permissonsToGrant, cmds, cmdChunk, permission, nextCmd, result, lastError, cmd;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

              case 2:
                stdout = context$2$0.sent;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getReqPermissions(pkg, stdout));

              case 5:
                requestedPermissions = context$2$0.sent;
                context$2$0.next = 8;
                return _regeneratorRuntime.awrap(this.getGrantedPermissions(pkg, stdout));

              case 8:
                grantedPermissions = context$2$0.sent;
                permissonsToGrant = requestedPermissions.filter(function (x) {
                  return grantedPermissions.indexOf(x) < 0;
                });

                if (permissonsToGrant.length) {
                  context$2$0.next = 13;
                  break;
                }

                _loggerJs2['default'].info(pkg + ' contains no permissions available for granting.');
                return context$2$0.abrupt('return', {
                  v: true
                });

              case 13:
                cmds = [];
                cmdChunk = [];
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 18;

                for (_iterator = _getIterator(permissonsToGrant); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  permission = _step.value;
                  nextCmd = ['pm', 'grant', pkg, permission, ';'];

                  if (nextCmd.join(' ').length + cmdChunk.join(' ').length >= MAX_SHELL_BUFFER_LENGTH) {
                    cmds.push(cmdChunk);
                    cmdChunk = [];
                  }
                  cmdChunk = cmdChunk.concat(nextCmd);
                }
                context$2$0.next = 26;
                break;

              case 22:
                context$2$0.prev = 22;
                context$2$0.t0 = context$2$0['catch'](18);
                _didIteratorError = true;
                _iteratorError = context$2$0.t0;

              case 26:
                context$2$0.prev = 26;
                context$2$0.prev = 27;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 29:
                context$2$0.prev = 29;

                if (!_didIteratorError) {
                  context$2$0.next = 32;
                  break;
                }

                throw _iteratorError;

              case 32:
                return context$2$0.finish(29);

              case 33:
                return context$2$0.finish(26);

              case 34:
                if (cmdChunk.length) {
                  cmds.push(cmdChunk);
                }
                _loggerJs2['default'].debug('Got the following command chunks to execute: ' + cmds);
                result = true;
                lastError = null;
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                context$2$0.prev = 41;
                _iterator2 = _getIterator(cmds);

              case 43:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  context$2$0.next = 61;
                  break;
                }

                cmd = _step2.value;
                context$2$0.prev = 45;
                context$2$0.next = 48;
                return _regeneratorRuntime.awrap(this.shell(cmd));

              case 48:
                context$2$0.t1 = context$2$0.sent;

                if (!context$2$0.t1) {
                  context$2$0.next = 51;
                  break;
                }

                context$2$0.t1 = result;

              case 51:
                result = context$2$0.t1;
                context$2$0.next = 58;
                break;

              case 54:
                context$2$0.prev = 54;
                context$2$0.t2 = context$2$0['catch'](45);

                // this is to give the method a chance to assign all the requested permissions
                // before to quit in case we'd like to ignore the error on the higher level
                lastError = context$2$0.t2;
                result = false;

              case 58:
                _iteratorNormalCompletion2 = true;
                context$2$0.next = 43;
                break;

              case 61:
                context$2$0.next = 67;
                break;

              case 63:
                context$2$0.prev = 63;
                context$2$0.t3 = context$2$0['catch'](41);
                _didIteratorError2 = true;
                _iteratorError2 = context$2$0.t3;

              case 67:
                context$2$0.prev = 67;
                context$2$0.prev = 68;

                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }

              case 70:
                context$2$0.prev = 70;

                if (!_didIteratorError2) {
                  context$2$0.next = 73;
                  break;
                }

                throw _iteratorError2;

              case 73:
                return context$2$0.finish(70);

              case 74:
                return context$2$0.finish(67);

              case 75:
                if (!lastError) {
                  context$2$0.next = 77;
                  break;
                }

                throw lastError;

              case 77:
                return context$2$0.abrupt('return', {
                  v: result
                });

              case 78:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[18, 22, 26, 34], [27,, 29, 33], [41, 63, 67, 75], [45, 54], [68,, 70, 74]]);
        })());

      case 22:
        _ret = context$1$0.sent;

        if (!(typeof _ret === 'object')) {
          context$1$0.next = 25;
          break;
        }

        return context$1$0.abrupt('return', _ret.v);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 16]]);
};

/**
 * Grant single permission for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} permission - The full name of the permission to be granted.
 * @throws {Error} If there was an error while changing permissions.
 */
methods.grantPermission = function callee$0$0(pkg, permission) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'grant', pkg, permission]));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (context$1$0.t0.message.includes("not a changeable permission type")) {
          context$1$0.next = 9;
          break;
        }

        throw context$1$0.t0;

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
};

/**
 * Revoke single permission from the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} permission - The full name of the permission to be revoked.
 * @throws {Error} If there was an error while changing permissions.
 */
methods.revokePermission = function callee$0$0(pkg, permission) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'revoke', pkg, permission]));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (context$1$0.t0.message.includes("not a changeable permission type")) {
          context$1$0.next = 9;
          break;
        }

        throw context$1$0.t0;

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
};

/**
 * Retrieve the list of granted permissions for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} cmdOutput [null] - Optional parameter containing command output of
 *                                    _pm dump_ command. It speeds this method up
 *                                    if present.
 * @return {array} The list of granted permissions or an empty list.
 * @throws {Error} If there was an error while changing permissions.
 */
methods.getGrantedPermissions = function callee$0$0(pkg) {
  var cmdOutput = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var stdout, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = cmdOutput;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 4:
        context$1$0.t0 = context$1$0.sent;

      case 5:
        stdout = context$1$0.t0;
        match = new RegExp(/(install permissions:|User 0)([\s\S]*?)DUMP OF SERVICE activity:/g).exec(stdout);

        if (match) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to get granted permissions');

      case 9:
        return context$1$0.abrupt('return', (match[0].match(/android\.permission\.\w+:\sgranted=true/g) || []).map(function (x) {
          return x.replace(/:\sgranted=true/g, '');
        }));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of denied permissions for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} cmdOutput [null] - Optional parameter containing command output of
 *                                    _pm dump_ command. It speeds this method up
 *                                    if present.
 * @return {array} The list of denied permissions or an empty list.
 */
methods.getDeniedPermissions = function callee$0$0(pkg) {
  var cmdOutput = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var stdout, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = cmdOutput;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 4:
        context$1$0.t0 = context$1$0.sent;

      case 5:
        stdout = context$1$0.t0;
        match = new RegExp(/(install permissions:|User 0)([\s\S]*?)DUMP OF SERVICE activity:/g).exec(stdout);

        if (match) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to get denied permissions');

      case 9:
        return context$1$0.abrupt('return', (match[0].match(/android\.permission\.\w+:\sgranted=false/g) || []).map(function (x) {
          return x.replace(/:\sgranted=false/g, '');
        }));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of requested permissions for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @param {string} cmdOutput [null] - Optional parameter containing command output of
 *                                    _pm dump_ command. It speeds this method up
 *                                    if present.
 * @return {array} The list of requested permissions or an empty list.
 */
methods.getReqPermissions = function callee$0$0(pkg) {
  var cmdOutput = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var stdout, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = cmdOutput;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 4:
        context$1$0.t0 = context$1$0.sent;

      case 5:
        stdout = context$1$0.t0;
        match = new RegExp(/requested permissions:([\s\S]*?)(install permissions:|User 0)/g).exec(stdout);

        if (match) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to get requested permissions');

      case 9:
        return context$1$0.abrupt('return', match[0].match(/android\.permission\.\w+/g) || []);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of location providers for the device under test.
 *
 * @return {Array.<String>} The list of available location providers or an empty list.
 */
methods.getLocationProviders = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('secure', 'location_providers_allowed'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', stdout.trim().split(',').map(function (p) {
          return p.trim();
        }).filter(Boolean));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Toggle the state of GPS location provider.
 *
 * @param {boolean} enabled - Whether to enable (true) or disable (false) the GPS provider.
 */
methods.toggleGPSLocationProvider = function callee$0$0(enabled) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setSetting('secure', 'location_providers_allowed', (enabled ? "+" : "-") + 'gps'));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Stop the particular package if it is running and clears its application data.
 *
 * @param {string} pkg - The package name to be processed.
 */
methods.stopAndClear = function callee$0$0(pkg) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.forceStop(pkg));

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.clear(pkg));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Cannot stop and clear ' + pkg + '. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Retrieve the target SDK version for the particular package.
 *
 * @param {string} pkg - The package name to be processed.
 * @return {string} The parsed SDK version.
 */
methods.getTargetSdkUsingPKG = function callee$0$0(pkg) {
  var stdout, targetSdk;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'dump', pkg]));

      case 2:
        stdout = context$1$0.sent;
        targetSdk = new RegExp(/targetSdk=([^\s\s]+)/g).exec(stdout)[1];
        return context$1$0.abrupt('return', targetSdk);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the list of available input methods (IMEs) for the device under test.
 *
 * @return {Array.<String>} The list of IME names or an empty list.
 */
methods.availableIMEs = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'list', '-a']));

      case 3:
        context$1$0.t0 = context$1$0.sent;
        return context$1$0.abrupt('return', (0, _helpersJs.getIMEListFromOutput)(context$1$0.t0));

      case 7:
        context$1$0.prev = 7;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting available IME\'s. Original error: ' + context$1$0.t1.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Retrieve the list of enabled input methods (IMEs) for the device under test.
 *
 * @return {Array.<String>} The list of enabled IME names or an empty list.
 */
methods.enabledIMEs = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'list']));

      case 3:
        context$1$0.t0 = context$1$0.sent;
        return context$1$0.abrupt('return', (0, _helpersJs.getIMEListFromOutput)(context$1$0.t0));

      case 7:
        context$1$0.prev = 7;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting enabled IME\'s. Original error: ' + context$1$0.t1.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Enable the particular input method on the device under test.
 *
 * @param {string} imeId - One of existing IME ids.
 */
methods.enableIME = function callee$0$0(imeId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'enable', imeId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Disable the particular input method on the device under test.
 *
 * @param {string} imeId - One of existing IME ids.
 */
methods.disableIME = function callee$0$0(imeId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'disable', imeId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the particular input method on the device under test.
 *
 * @param {string} imeId - One of existing IME ids.
 */
methods.setIME = function callee$0$0(imeId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['ime', 'set', imeId]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the default input method on the device under test.
 *
 * @return {string} The name of the default input method.
 */
methods.defaultIME = function callee$0$0() {
  var engine;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSetting('secure', 'default_input_method'));

      case 3:
        engine = context$1$0.sent;
        return context$1$0.abrupt('return', engine.trim());

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Error getting default IME. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 7]]);
};

/**
 * Send the particular keycode to the device under test.
 *
 * @param {string|number} keycode - The actual key code to be sent.
 */
methods.keyevent = function callee$0$0(keycode) {
  var code;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        code = parseInt(keycode, 10);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['input', 'keyevent', code]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the particular text to the device under test.
 *
 * @param {string} text - The actual text to be sent.
 */
methods.inputText = function callee$0$0(text) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        /* jshint ignore:start */
        // need to escape whitespace and ( ) < > | ; & * \ ~ " '
        text = text.replace(/\\/g, '\\\\').replace(/\(/g, '\(').replace(/\)/g, '\)').replace(/</g, '\<').replace(/>/g, '\>').replace(/\|/g, '\|').replace(/;/g, '\;').replace(/&/g, '\&').replace(/\*/g, '\*').replace(/~/g, '\~').replace(/"/g, '\"').replace(/'/g, "\'").replace(/ /g, '%s');
        /* jshint ignore:end */
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['input', 'text', text]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Clear the active text field on the device under test by sending
 * special keyevents to it.
 *
 * @param {number} length [100] - The maximum length of the text in the field to be cleared.
 */
methods.clearTextField = function callee$0$0() {
  var length = arguments.length <= 0 || arguments[0] === undefined ? 100 : arguments[0];
  var args, i;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // assumes that the EditText field already has focus
        _loggerJs2['default'].debug('Clearing up to ' + length + ' characters');

        if (!(length === 0)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return');

      case 3:
        args = ['input', 'keyevent'];

        for (i = 0; i < length; i++) {
          // we cannot know where the cursor is in the text field, so delete both before
          // and after so that we get rid of everything
          // https://developer.android.com/reference/android/view/KeyEvent.html#KEYCODE_DEL
          // https://developer.android.com/reference/android/view/KeyEvent.html#KEYCODE_FORWARD_DEL
          args.push('67', '112');
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the special keycode to the device under test in order to lock it.
 */
methods.lock = function callee$0$0() {
  var timeoutMs;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.isScreenLocked());

      case 2:
        if (!context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        _loggerJs2['default'].debug("Screen is already locked. Doing nothing.");
        return context$1$0.abrupt('return');

      case 5:
        _loggerJs2['default'].debug("Pressing the KEYCODE_POWER button to lock screen");
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.keyevent(26));

      case 8:
        timeoutMs = 5000;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.isScreenLocked());

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        }, {
          waitMs: timeoutMs,
          intervalMs: 500
        }));

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](9);
        throw new Error('The device screen is still locked after ' + timeoutMs + 'ms timeout');

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 14]]);
};

/**
 * Send the special keycode to the device under test in order to emulate
 * Back button tap.
 */
methods.back = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Pressing the BACK button");
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.keyevent(4));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send the special keycode to the device under test in order to emulate
 * Home button tap.
 */
methods.goToHome = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Pressing the HOME button");
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.keyevent(3));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} the actual path to adb executable.
 */
methods.getAdbPath = function () {
  return this.executable.path;
};

/**
 * Retrieve current screen orientation of the device under test.
 *
 * @return {number} The current orientation encoded as an integer number.
 */
methods.getScreenOrientation = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'input']));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', (0, _helpersJs.getSurfaceOrientation)(stdout));

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the screen lock state of the device under test.
 *
 * @return {boolean} True if the device is locked.
 */
methods.isScreenLocked = function callee$0$0() {
  var stdout, dumpsysFile;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'window']));

      case 2:
        stdout = context$1$0.sent;

        if (!process.env.APPIUM_LOG_DUMPSYS) {
          context$1$0.next = 8;
          break;
        }

        dumpsysFile = _path2['default'].resolve(process.cwd(), "dumpsys.log");

        _loggerJs2['default'].debug('Writing dumpsys output to ' + dumpsysFile);
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dumpsysFile, stdout));

      case 8:
        return context$1$0.abrupt('return', (0, _helpersJs.isShowingLockscreen)(stdout) || (0, _helpersJs.isCurrentFocusOnKeyguard)(stdout) || !(0, _helpersJs.isScreenOnFully)(stdout));

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the state of the software keyboard on the device under test.
 *
 * @return {boolean} True if the software keyboard is present.
 */
methods.isSoftKeyboardPresent = function callee$0$0() {
  var stdout, isKeyboardShown, canCloseKeyboard, inputShownMatch, isInputViewShownMatch;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'input_method']));

      case 3:
        stdout = context$1$0.sent;
        isKeyboardShown = false, canCloseKeyboard = false, inputShownMatch = /mInputShown=\w+/gi.exec(stdout);

        if (inputShownMatch && inputShownMatch[0]) {
          isKeyboardShown = inputShownMatch[0].split('=')[1] === 'true';
          isInputViewShownMatch = /mIsInputViewShown=\w+/gi.exec(stdout);

          if (isInputViewShownMatch && isInputViewShownMatch[0]) {
            canCloseKeyboard = isInputViewShownMatch[0].split('=')[1] === 'true';
          }
        }
        return context$1$0.abrupt('return', { isKeyboardShown: isKeyboardShown, canCloseKeyboard: canCloseKeyboard });

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Error finding softkeyboard. Original error: ' + context$1$0.t0.message);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
};

/**
 * Send an arbitrary Telnet command to the device under test.
 *
 * @param {string} command - The command to be sent.
 *
 * @return {string} The actual output of the given command.
 */
methods.sendTelnetCommand = function callee$0$0(command) {
  var port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Sending telnet command to device: ' + command);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getEmulatorPort());

      case 3:
        port = context$1$0.sent;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
          var conn = _net2['default'].createConnection(port, 'localhost'),
              connected = false,
              readyRegex = /^OK$/m,
              dataStream = "",
              res = null;
          conn.on('connect', function () {
            _loggerJs2['default'].debug("Socket connection to device created");
          });
          conn.on('data', function (data) {
            data = data.toString('utf8');
            if (!connected) {
              if (readyRegex.test(data)) {
                connected = true;
                _loggerJs2['default'].debug("Socket connection to device ready");
                conn.write(command + '\n');
              }
            } else {
              dataStream += data;
              if (readyRegex.test(data)) {
                res = dataStream.replace(readyRegex, "").trim();
                res = _lodash2['default'].last(res.trim().split('\n'));
                _loggerJs2['default'].debug('Telnet command got response: ' + res);
                conn.write("quit\n");
              }
            }
          });
          conn.on('error', function (err) {
            // eslint-disable-line promise/prefer-await-to-callbacks
            _loggerJs2['default'].debug('Telnet command error: ' + err.message);
            reject(err);
          });
          conn.on('close', function () {
            if (res === null) {
              reject(new Error("Never got a response from command"));
            } else {
              resolve(res);
            }
          });
        }));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of Airplane mode on the device under test.
 *
 * @return {boolean} True if Airplane mode is enabled.
 */
methods.isAirplaneModeOn = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'airplane_mode_on'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', parseInt(stdout, 10) !== 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of Airplane mode in Settings on the device under test.
 *
 * @param {boolean} on - True to enable the Airplane mode in Settings and false to disable it.
 */
methods.setAirplaneMode = function callee$0$0(on) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setSetting('global', 'airplane_mode_on', on ? 1 : 0));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Broadcast the state of Airplane mode on the device under test.
 * This method should be called after {@link #setAirplaneMode}, otherwise
 * the mode change is not going to be applied for the device.
 *
 * @param {boolean} on - True to broadcast enable and false to broadcast disable.
 */
methods.broadcastAirplaneMode = function callee$0$0(on) {
  var args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['am', 'broadcast', '-a', 'android.intent.action.AIRPLANE_MODE', '--ez', 'state', on ? 'true' : 'false'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of WiFi on the device under test.
 *
 * @return {boolean} True if WiFi is enabled.
 */
methods.isWifiOn = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'wifi_on'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', parseInt(stdout, 10) !== 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of WiFi on the device under test.
 *
 * @param {boolean} on - True to enable and false to disable it.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setWifiState = function callee$0$0(on) {
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var isRoot;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!isEmulator) {
          context$1$0.next = 14;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.root());

      case 3:
        isRoot = context$1$0.sent;
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(['svc', 'wifi', on ? 'enable' : 'disable']));

      case 7:
        context$1$0.prev = 7;

        if (!isRoot) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.unroot());

      case 11:
        return context$1$0.finish(7);

      case 12:
        context$1$0.next = 16;
        break;

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', WIFI_CONNECTION_SETTING_ACTION, '-n', WIFI_CONNECTION_SETTING_RECEIVER, '--es', 'setstatus', on ? 'enable' : 'disable']));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4,, 7, 12]]);
};

/**
 * Check the state of Data transfer on the device under test.
 *
 * @return {boolean} True if Data transfer is enabled.
 */
methods.isDataOn = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'mobile_data'));

      case 2:
        stdout = context$1$0.sent;
        return context$1$0.abrupt('return', parseInt(stdout, 10) !== 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of Data transfer on the device under test.
 *
 * @param {boolean} on - True to enable and false to disable it.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setDataState = function callee$0$0(on) {
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var isRoot;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!isEmulator) {
          context$1$0.next = 14;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.root());

      case 3:
        isRoot = context$1$0.sent;
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(['svc', 'data', on ? 'enable' : 'disable']));

      case 7:
        context$1$0.prev = 7;

        if (!isRoot) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.unroot());

      case 11:
        return context$1$0.finish(7);

      case 12:
        context$1$0.next = 16;
        break;

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', DATA_CONNECTION_SETTING_ACTION, '-n', DATA_CONNECTION_SETTING_RECEIVER, '--es', 'setstatus', on ? 'enable' : 'disable']));

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4,, 7, 12]]);
};

/**
 * Change the state of WiFi and/or Data transfer on the device under test.
 *
 * @param {boolean} wifi - True to enable and false to disable WiFi.
 * @param {boolean} data - True to enable and false to disable Data transfer.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setWifiAndData = function callee$0$0(_ref) {
  var wifi = _ref.wifi;
  var data = _ref.data;
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!_appiumSupport.util.hasValue(wifi)) {
          context$1$0.next = 3;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.setWifiState(wifi, isEmulator));

      case 3:
        if (!_appiumSupport.util.hasValue(data)) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.setDataState(data, isEmulator));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the state of animation on the device under test.
 * Animation on the device is controlled by the following global properties:
 * [ANIMATOR_DURATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#ANIMATOR_DURATION_SCALE},
 * [TRANSITION_ANIMATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#TRANSITION_ANIMATION_SCALE},
 * [WINDOW_ANIMATION_SCALE]{@link https://developer.android.com/reference/android/provider/Settings.Global.html#WINDOW_ANIMATION_SCALE}.
 * This method sets all this properties to 0.0 to disable (1.0 to enable) animation.
 *
 * Turning off animation might be useful to improve stability
 * and reduce tests execution time.
 *
 * @param {boolean} on - True to enable and false to disable it.
 */
methods.setAnimationState = function callee$0$0(on) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', ANIMATION_SETTING_ACTION, '-n', ANIMATION_SETTING_RECEIVER, '--es', 'setstatus', on ? 'enable' : 'disable']));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check the state of animation on the device under test.
 *
 * @return {boolean} True if at least one of animation scale settings
 *                   is not equal to '0.0'.
 */
methods.isAnimationOn = function callee$0$0() {
  var animator_duration_scale, transition_animation_scale, window_animation_scale;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'animator_duration_scale'));

      case 2:
        animator_duration_scale = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'transition_animation_scale'));

      case 5:
        transition_animation_scale = context$1$0.sent;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getSetting('global', 'window_animation_scale'));

      case 8:
        window_animation_scale = context$1$0.sent;
        return context$1$0.abrupt('return', _lodash2['default'].some([animator_duration_scale, transition_animation_scale, window_animation_scale], function (setting) {
          return setting !== '0.0';
        }));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Change the locale on the device under test. Don't need to reboot the device after changing the locale.
 * This method sets an arbitrary locale following:
 *   https://developer.android.com/reference/java/util/Locale.html
 *   https://developer.android.com/reference/java/util/Locale.html#Locale(java.lang.String,%20java.lang.String)
 *
 * @param {string} language - Language. e.g. en, ja
 * @param {string} country - Country. e.g. US, JP
 */
methods.setDeviceSysLocaleViaSettingApp = function callee$0$0(language, country) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', LOCALE_SETTING_ACTION, '-n', LOCALE_SETTING_RECEIVER, '--es', 'lang', language.toLowerCase(), '--es', 'country', country.toUpperCase()]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Object} Location
 * @property {float|string} longitude - Valid longitude value.
 * @property {float|string} latitude - Valid latitude value.
 */

/**
 * Emulate geolocation coordinates on the device under test.
 *
 * @param {Location} location - Location object.
 * @param {boolean} isEmulator [false] - Set it to true if the device under test
 *                                       is an emulator rather than a real device.
 */
methods.setGeoLocation = function callee$0$0(location) {
  var isEmulator = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var longitude, latitude;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        longitude = parseFloat(location.longitude);

        if (!isNaN(longitude)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error('location.longitude is expected to be a valid float number. \'' + location.longitude + '\' is given instead');

      case 3:
        longitude = '' + _lodash2['default'].ceil(longitude, 5);
        latitude = parseFloat(location.latitude);

        if (!isNaN(latitude)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error('location.latitude is expected to be a valid float number. \'' + location.latitude + '\' is given instead');

      case 7:
        latitude = '' + _lodash2['default'].ceil(latitude, 5);

        if (!isEmulator) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.resetTelnetAuthToken());

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'geo', 'fix', longitude, latitude]));

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'geo', 'fix', longitude.replace('.', ','), latitude.replace('.', ',')]));

      case 15:
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.shell(['am', 'startservice', '-e', 'longitude', longitude, '-e', 'latitude', latitude, LOCATION_SERVICE]));

      case 19:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Forcefully recursively remove a path on the device under test.
 * Be careful while calling this method.
 *
 * @param {string} path - The path to be removed recursively.
 */
methods.rimraf = function callee$0$0(path) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['rm', '-rf', path]));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Send a file to the device under test.
 *
 * @param {string} localPath - The path to the file on the local file system.
 * @param {string} remotePath - The destination path on the remote device.
 * @param {object} opts - Additional options mapping. See
 *                        https://github.com/appium/node-teen_process,
 *                        _exec_ method options, for more information about available
 *                        options.
 */
methods.push = function callee$0$0(localPath, remotePath, opts) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(['push', localPath, remotePath], opts));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Receive a file from the device under test.
 *
 * @param {string} remotePath - The source path on the remote device.
 * @param {string} localPath - The destination path to the file on the local file system.
 */
methods.pull = function callee$0$0(remotePath, localPath) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(['pull', remotePath, localPath], { timeout: 60000 }));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Check whether the process with the particular name is running on the device
 * under test.
 *
 * @param {string} processName - The name of the process to be checked.
 * @return {boolean} True if the given process is running.
 * @throws {error} If the given process name is not a valid class name.
 */
methods.processExists = function callee$0$0(processName) {
  var stdout, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, line, pkgColumn;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        if (this.isValidClass(processName)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error('Invalid process name: ' + processName);

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell("ps"));

      case 5:
        stdout = context$1$0.sent;
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 9;
        _iterator3 = _getIterator(stdout.split(/\r?\n/));

      case 11:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 20;
          break;
        }

        line = _step3.value;

        line = line.trim().split(/\s+/);
        pkgColumn = line[line.length - 1];

        if (!(pkgColumn && pkgColumn.indexOf(processName) !== -1)) {
          context$1$0.next = 17;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 17:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 11;
        break;

      case 20:
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError3) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError3;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        return context$1$0.abrupt('return', false);

      case 37:
        context$1$0.prev = 37;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error finding if process exists. Original error: ' + context$1$0.t1.message);

      case 40:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 37], [9, 22, 26, 34], [27,, 29, 33]]);
};

/**
 * Get TCP port forwarding with adb on the device under test.
 * @return {Array.<String>} The output of the corresponding adb command. An array contains each forwarding line of output
 */
methods.getForwardList = function callee$0$0() {
  var connections;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('List forwarding ports');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', '--list']));

      case 3:
        connections = context$1$0.sent;
        return context$1$0.abrupt('return', connections.split('\n'));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Setup TCP port forwarding with adb on the device under test.
 *
 * @param {string|number} systemPort - The number of the local system port.
 * @param {string|number} devicePort - The number of the remote device port.
 */
methods.forwardPort = function callee$0$0(systemPort, devicePort) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Forwarding system: ' + systemPort + ' to device: ' + devicePort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', 'tcp:' + systemPort, 'tcp:' + devicePort]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Remove TCP port forwarding with adb on the device under test. The forwarding
 * for the given port should be setup with {@link #forwardPort} first.
 *
 * @param {string|number} systemPort - The number of the local system port
 *                                     to remove forwarding on.
 */
methods.removePortForward = function callee$0$0(systemPort) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Removing forwarded port socket connection: ' + systemPort + ' ');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', '--remove', 'tcp:' + systemPort]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Setup TCP port forwarding with adb on the device under test. The difference
 * between {@link #forwardPort} is that this method does setup for an abstract
 * local port.
 *
 * @param {string|number} systemPort - The number of the local system port.
 * @param {string|number} devicePort - The number of the remote device port.
 */
methods.forwardAbstractPort = function callee$0$0(systemPort, devicePort) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Forwarding system: ' + systemPort + ' to abstract device: ' + devicePort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['forward', 'tcp:' + systemPort, 'localabstract:' + devicePort]));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute ping shell command on the device under test.
 *
 * @return {boolean} True if the command output contains 'ping' substring.
 * @throws {error} If there was an error while executing 'ping' command on the
 *                 device under test.
 */
methods.ping = function callee$0$0() {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(["echo", "ping"]));

      case 2:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf("ping") === 0)) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 5:
        throw new Error('ADB ping failed, returned ' + stdout);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Restart the device under test using adb commands.
 *
 * @throws {error} If start fails.
 */
methods.restart = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.stopLogcat());

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.restartAdb());

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.waitForDevice(60));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.startLogcat());

      case 9:
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Restart failed. Orginial error: ' + context$1$0.t0.message);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 11]]);
};

/**
 * Start the logcat process to gather logs.
 *
 * @throws {error} If restart fails.
 */
methods.startLogcat = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (_lodash2['default'].isEmpty(this.logcat)) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("Trying to start logcat capture but it's already started!");

      case 2:
        this.logcat = new _logcat2['default']({
          adb: this.executable,
          debug: false,
          debugTrace: false,
          clearDeviceLogsOnStart: !!this.clearDeviceLogsOnStart
        });
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.logcat.startCapture());

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Stop the active logcat process which gathers logs.
 * The call will be ignored if no logcat process is running.
 */
methods.stopLogcat = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!_lodash2['default'].isEmpty(this.logcat)) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.logcat.stopCapture());

      case 5:
        context$1$0.prev = 5;

        this.logcat = null;
        return context$1$0.finish(5);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2,, 5, 8]]);
};

/**
 * Retrieve the output from the currently running logcat process.
 * The logcat process should be executed by {2link #startLogcat} method.
 *
 * @return {string} The collected logcat output.
 * @throws {Error} If logcat process is not running.
 */
methods.getLogcatLogs = function () {
  if (_lodash2['default'].isEmpty(this.logcat)) {
    throw new Error("Can't get logcat logs since logcat hasn't started");
  }
  return this.logcat.getLogs();
};

/**
 * Set the callback for the logcat output event.
 *
 * @param {Function} listener - The listener function, which accepts one argument. The argument is
 *                              a log record object with `timestamp`, `level` and `message` properties.
 * @throws {Error} If logcat process is not running.
 */
methods.setLogcatListener = function (listener) {
  if (_lodash2['default'].isEmpty(this.logcat)) {
    throw new Error("Logcat process hasn't been started");
  }
  this.logcat.on('output', listener);
};

/**
 * Removes the previously set callback for the logcat output event.
 *
 * @param {Function} listener - The listener function, which has been previously
 *                              passed to `setLogcatListener`
 * @throws {Error} If logcat process is not running.
 */
methods.removeLogcatListener = function (listener) {
  if (_lodash2['default'].isEmpty(this.logcat)) {
    throw new Error("Logcat process hasn't been started");
  }
  this.logcat.removeListener('output', listener);
};

/**
 * Get the list of process ids for the particular process on the device under test.
 *
 * @param {string} name - The part of process name.
 * @return {Array.<number>} The list of matched process IDs or an empty list.
 */
methods.getPIDsByName = function callee$0$0(name) {
  var stdout, pids, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, line, match;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Getting all processes with ' + name);
        context$1$0.prev = 1;

        // ps <comm> where comm is last 15 characters of package name
        if (name.length > 15) {
          name = name.substr(name.length - 15);
        }
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell(["ps"]));

      case 5:
        stdout = context$1$0.sent.trim();
        pids = [];
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 10;
        _iterator4 = _getIterator(stdout.split("\n"));

      case 12:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 24;
          break;
        }

        line = _step4.value;

        if (!(line.indexOf(name) !== -1)) {
          context$1$0.next = 21;
          break;
        }

        match = /[^\t ]+[\t ]+([0-9]+)/.exec(line);

        if (!match) {
          context$1$0.next = 20;
          break;
        }

        pids.push(parseInt(match[1], 10));
        context$1$0.next = 21;
        break;

      case 20:
        throw new Error('Could not extract PID from ps output: ' + line);

      case 21:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 12;
        break;

      case 24:
        context$1$0.next = 30;
        break;

      case 26:
        context$1$0.prev = 26;
        context$1$0.t0 = context$1$0['catch'](10);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 30:
        context$1$0.prev = 30;
        context$1$0.prev = 31;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 33:
        context$1$0.prev = 33;

        if (!_didIteratorError4) {
          context$1$0.next = 36;
          break;
        }

        throw _iteratorError4;

      case 36:
        return context$1$0.finish(33);

      case 37:
        return context$1$0.finish(30);

      case 38:
        return context$1$0.abrupt('return', pids);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](1);
        throw new Error('Unable to get pids for ' + name + '. Orginial error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 41], [10, 26, 30, 38], [31,, 33, 37]]);
};

/**
 * Get the list of process ids for the particular process on the device under test.
 *
 * @param {string} name - The part of process name.
 * @return {Array.<number>} The list of matched process IDs or an empty list.
 */
methods.killProcessesByName = function callee$0$0(name) {
  var pids, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, pid;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Attempting to kill all ' + name + ' processes');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getPIDsByName(name));

      case 4:
        pids = context$1$0.sent;

        if (!(pids.length < 1)) {
          context$1$0.next = 8;
          break;
        }

        _loggerJs2['default'].info('No ' + name + ' process found to kill, continuing...');
        return context$1$0.abrupt('return');

      case 8:
        _iteratorNormalCompletion5 = true;
        _didIteratorError5 = false;
        _iteratorError5 = undefined;
        context$1$0.prev = 11;
        _iterator5 = _getIterator(pids);

      case 13:
        if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
          context$1$0.next = 20;
          break;
        }

        pid = _step5.value;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(this.killProcessByPID(pid));

      case 17:
        _iteratorNormalCompletion5 = true;
        context$1$0.next = 13;
        break;

      case 20:
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](11);
        _didIteratorError5 = true;
        _iteratorError5 = context$1$0.t0;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion5 && _iterator5['return']) {
          _iterator5['return']();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError5) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError5;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        context$1$0.next = 39;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Unable to kill ' + name + ' processes. Original error: ' + context$1$0.t1.message);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 36], [11, 22, 26, 34], [27,, 29, 33]]);
};

/**
 * Kill the particular process on the device under test.
 *
 * @param {string|number} pid - The ID of the process to be killed.
 * @return {string} Kill command stdout.
 * @throws {Error} If the process with given ID is not present or cannot be killed.
 */
methods.killProcessByPID = function callee$0$0(pid) {
  var timeoutMs, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Attempting to kill process ' + pid);
        // Just to check if the process exists and throw an exception otherwise
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.shell(['kill', '-0', pid]));

      case 3:
        timeoutMs = 1000;
        stdout = undefined;
        context$1$0.prev = 5;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.shell(['kill', pid]));

              case 3:
                stdout = context$2$0.sent;
                return context$2$0.abrupt('return', false);

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                return context$2$0.abrupt('return', true);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[0, 7]]);
        }, { waitMs: timeoutMs, intervalMs: 300 }));

      case 8:
        context$1$0.next = 16;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](5);

        _loggerJs2['default'].warn('Cannot kill process ' + pid + ' in ' + timeoutMs + ' ms. Trying to force kill...');
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['kill', '-9', pid]));

      case 15:
        stdout = context$1$0.sent;

      case 16:
        return context$1$0.abrupt('return', stdout);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 10]]);
};

/**
 * Broadcast process killing on the device under test.
 *
 * @param {string} intent - The name of the intent to broadcast to.
 * @param {string} processName - The name of the killed process.
 * @throws {error} If the process was not killed.
 */
methods.broadcastProcessEnd = function callee$0$0(intent, processName) {
  var start, timeoutMs;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // start the broadcast without waiting for it to finish.
        this.broadcast(intent);
        // wait for the process to end
        start = Date.now();
        timeoutMs = 40000;
        context$1$0.prev = 3;

      case 4:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 14;
          break;
        }

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.processExists(processName));

      case 7:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(400));

      case 10:
        return context$1$0.abrupt('continue', 4);

      case 11:
        return context$1$0.abrupt('return');

      case 14:
        throw new Error('Process never died within ' + timeoutMs + ' ms');

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('Unable to broadcast process end. Original error: ' + context$1$0.t0.message);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 17]]);
};

/**
 * Broadcast a message to the given intent.
 *
 * @param {string} intent - The name of the intent to broadcast to.
 * @throws {error} If intent name is not a valid class name.
 */
methods.broadcast = function callee$0$0(intent) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.isValidClass(intent)) {
          context$1$0.next = 2;
          break;
        }

        throw new Error('Invalid intent ' + intent);

      case 2:
        _loggerJs2['default'].debug('Broadcasting: ' + intent);
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell(['am', 'broadcast', '-a', intent]));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Kill Android instruments if they are currently running.
 */
methods.endAndroidCoverage = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(this.instrumentProc && this.instrumentProc.isRunning)) {
          context$1$0.next = 3;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.instrumentProc.stop());

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Instrument the particular activity.
 *
 * @param {string} pkg - The name of the package to be instrumented.
 * @param {string} activity - The name of the main activity in this package.
 * @param {string} instrumentWith - The name of the package to instrument
 *                                  the activity with.
 * @throws {error} If any exception is reported by adb shell.
 */
methods.instrument = function callee$0$0(pkg, activity, instrumentWith) {
  var pkgActivity, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (activity[0] !== ".") {
          pkg = "";
        }
        pkgActivity = (pkg + activity).replace(/\.+/g, '.');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['am', 'instrument', '-e', 'main_activity', pkgActivity, instrumentWith]));

      case 4:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf("Exception") !== -1)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error('Unknown exception during instrumentation. ' + ('Original error ' + stdout.split("\n")[0]));

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Collect Android coverage by instrumenting the particular activity.
 *
 * @param {string} instrumentClass - The name of the instrumentation class.
 * @param {string} waitPkg - The name of the package to be instrumented.
 * @param {string} waitActivity - The name of the main activity in this package.
 *
 * @return {promise} The promise is successfully resolved if the instrumentation starts
 *                   without errors.
 */
methods.androidCoverage = function callee$0$0(instrumentClass, waitPkg, waitActivity) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.isValidClass(instrumentClass)) {
          context$1$0.next = 2;
          break;
        }

        throw new Error('Invalid class ' + instrumentClass);

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$1$0(resolve, reject) {
          var args;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                args = this.executable.defaultArgs.concat(['shell', 'am', 'instrument', '-e', 'coverage', 'true', '-w']).concat([instrumentClass]);

                _loggerJs2['default'].debug('Collecting coverage data with: ' + [this.executable.path].concat(args).join(' '));
                context$2$0.prev = 2;

                // am instrument runs for the life of the app process.
                this.instrumentProc = new _teen_process.SubProcess(this.executable.path, args);
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap(this.instrumentProc.start(0));

              case 6:
                this.instrumentProc.on('output', function (stdout, stderr) {
                  if (stderr) {
                    reject(new Error('Failed to run instrumentation. Original error: ' + stderr));
                  }
                });
                context$2$0.next = 9;
                return _regeneratorRuntime.awrap(this.waitForActivity(waitPkg, waitActivity));

              case 9:
                resolve();
                context$2$0.next = 15;
                break;

              case 12:
                context$2$0.prev = 12;
                context$2$0.t0 = context$2$0['catch'](2);

                reject(new Error('Android coverage failed. Original error: ' + context$2$0.t0.message));

              case 15:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4, [[2, 12]]);
        }));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the particular property of the device under test.
 *
 * @param {string} property - The name of the property. This name should
 *                            be known to _adb shell getprop_ tool.
 *
 * @return {string} The value of the given property.
 */
methods.getDeviceProperty = function callee$0$0(property) {
  var stdout, val;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['getprop', property]));

      case 2:
        stdout = context$1$0.sent;
        val = stdout.trim();

        _loggerJs2['default'].debug('Current device property \'' + property + '\': ' + val);
        return context$1$0.abrupt('return', val);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the particular property of the device under test.
 *
 * @param {string} property - The name of the property. This name should
 *                            be known to _adb shell setprop_ tool.
 * @param {string} val - The new property value.
 *
 * @throws {error} If _setprop_ utility fails to change property value.
 */
methods.setDeviceProperty = function callee$0$0(prop, val) {
  var apiLevel, err;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;

        if (!(apiLevel >= 26)) {
          context$1$0.next = 7;
          break;
        }

        _loggerJs2['default'].debug('Running adb root, Android O needs adb to be rooted to setDeviceProperty');
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.root());

      case 7:
        _loggerJs2['default'].debug('Setting device property \'' + prop + '\' to \'' + val + '\'');
        err = undefined;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.shell(['setprop', prop, val]));

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](9);

        err = context$1$0.t0;

      case 17:
        if (!(apiLevel >= 26)) {
          context$1$0.next = 21;
          break;
        }

        _loggerJs2['default'].debug('Removing adb root for setDeviceProperty');
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.unroot());

      case 21:
        if (!err) {
          context$1$0.next = 23;
          break;
        }

        throw err;

      case 23:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 14]]);
};

/**
 * @return {string} Current system language on the device under test.
 */
// eslint-disable-line curly
methods.getDeviceSysLanguage = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("persist.sys.language"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the new system language on the device under test.
 *
 * @param {string} language - The new language value.
 */
methods.setDeviceSysLanguage = function callee$0$0(language) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceProperty("persist.sys.language", language.toLowerCase()));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current country name on the device under test.
 */
methods.getDeviceSysCountry = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("persist.sys.country"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the new system country on the device under test.
 *
 * @param {string} country - The new country value.
 */
methods.setDeviceSysCountry = function callee$0$0(country) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceProperty("persist.sys.country", country.toUpperCase()));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current system locale name on the device under test.
 */
methods.getDeviceSysLocale = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("persist.sys.locale"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the new system locale on the device under test.
 *
 * @param {string} locale - The new locale value.
 */
methods.setDeviceSysLocale = function callee$0$0(locale) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceProperty("persist.sys.locale", locale));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current product language name on the device under test.
 */
methods.getDeviceProductLanguage = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.locale.language"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current product country name on the device under test.
 */
methods.getDeviceProductCountry = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.locale.region"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} Current product locale name on the device under test.
 */
methods.getDeviceProductLocale = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.locale"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} The model name of the device under test.
 */
methods.getModel = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.model"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @return {string} The manufacturer name of the device under test.
 */
methods.getManufacturer = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceProperty("ro.product.manufacturer"));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the current screen size.
 *
 * @return {string} Device screen size as string in format 'WxH' or
 *                  _null_ if it cannot be determined.
 */
methods.getScreenSize = function callee$0$0() {
  var stdout, size;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['wm', 'size']));

      case 2:
        stdout = context$1$0.sent;
        size = new RegExp(/Physical size: ([^\r?\n]+)*/g).exec(stdout);

        if (!(size && size.length >= 2)) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', size[1].trim());

      case 6:
        return context$1$0.abrupt('return', null);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the current screen density in dpi
 *
 * @return {?number} Device screen density as a number or _null_ if it
 *                  cannot be determined
 */
methods.getScreenDensity = function callee$0$0() {
  var stdout, density, densityNumber;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['wm', 'density']));

      case 2:
        stdout = context$1$0.sent;
        density = new RegExp(/Physical density: ([^\r?\n]+)*/g).exec(stdout);

        if (!(density && density.length >= 2)) {
          context$1$0.next = 7;
          break;
        }

        densityNumber = parseInt(density[1].trim(), 10);
        return context$1$0.abrupt('return', isNaN(densityNumber) ? null : densityNumber);

      case 7:
        return context$1$0.abrupt('return', null);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Setup HTTP proxy in device settings.
 *
 * @param {string} proxyHost - The host name of the proxy.
 * @param {string|number} proxyPort - The port number to be set.
 */
methods.setHttpProxy = function callee$0$0(proxyHost, proxyPort) {
  var proxy;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        proxy = proxyHost + ':' + proxyPort;

        if (!_lodash2['default'].isUndefined(proxyHost)) {
          context$1$0.next = 3;
          break;
        }

        throw new Error('Call to setHttpProxy method with undefined proxy_host: ' + proxy);

      case 3:
        if (!_lodash2['default'].isUndefined(proxyPort)) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Call to setHttpProxy method with undefined proxy_port ' + proxy);

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.setSetting('global', 'http_proxy', proxy));

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.setSetting('secure', 'http_proxy', proxy));

      case 9:
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.setSetting('system', 'http_proxy', proxy));

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.setSetting('system', 'global_http_proxy_host', proxyHost));

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.setSetting('system', 'global_http_proxy_port', proxyPort));

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set device property.
 * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
 *
 * @param {string} namespace - one of {system, secure, global}, case-insensitive.
 * @param {string} setting - property name.
 * @param {string|number} value - property value.
 * @return {string} command output.
 */
methods.setSetting = function callee$0$0(namespace, setting, value) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['settings', 'put', namespace, setting, value]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get device property.
 * [android.provider.Settings]{@link https://developer.android.com/reference/android/provider/Settings.html}
 *
 * @param {string} namespace - one of {system, secure, global}, case-insensitive.
 * @param {string} setting - property name.
 * @return {string} property value.
 */
methods.getSetting = function callee$0$0(namespace, setting) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['settings', 'get', namespace, setting]));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Retrieve the `adb bugreport` command output. This
 * operation may take up to several minutes.
 *
 * @param {?number} timeout [120000] - Command timeout in milliseconds
 * @returns {string} Command stdout
 */
methods.bugreport = function callee$0$0() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? 120000 : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(['bugreport'], { timeout: timeout }));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

exports['default'] = methods;
module.exports = exports['default'];

/**
 * If apk not provided, considering apk already installed on the device
 * and fetching targetSdk using package name.
 */

/**
 * If the device is running Android 6.0(API 23) or higher, and your app's target SDK is 23 or higher:
 * The app has to list the permissions in the manifest.
 * refer: https://developer.android.com/training/permissions/requesting.html
 */

// As it consumes more time for granting each permission,
// trying to grant all permission by forming equivalent command.
// Also, it is necessary to split long commands into chunks, since the maximum length of
// adb shell buffer is limited

// keycode must be an int.

// optional debugging
// if the method is not working, turn it on and send us the output

// A workaround for https://code.google.com/p/android/issues/detail?id=206180

// pull folder can take more time, increasing time out to 60 secs

// kill returns non-zero code if the process is already killed

// cool down
// Fix pkg..activity error
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hZGItY29tbWFuZHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3dCQUFnQixjQUFjOzs7O3lCQUV5QixlQUFlOztvQkFDckQsTUFBTTs7OztzQkFDVCxRQUFROzs7OzZCQUNHLGdCQUFnQjs7bUJBQ3pCLEtBQUs7Ozs7c0JBQ0YsV0FBVzs7Ozt3QkFDVSxVQUFVOzs0QkFDdkIsY0FBYzs7d0JBQzNCLFVBQVU7Ozs7QUFFeEIsSUFBTSxrQkFBa0IsR0FBRyxvQkFBb0IsQ0FBQztBQUNoRCxJQUFNLGdDQUFnQyxHQUFNLGtCQUFrQiw4Q0FBMkMsQ0FBQztBQUMxRyxJQUFNLDhCQUE4QixHQUFNLGtCQUFrQixVQUFPLENBQUM7QUFDcEUsSUFBTSxnQ0FBZ0MsR0FBTSxrQkFBa0IsOENBQTJDLENBQUM7QUFDMUcsSUFBTSw4QkFBOEIsR0FBTSxrQkFBa0IscUJBQWtCLENBQUM7QUFDL0UsSUFBTSwwQkFBMEIsR0FBTSxrQkFBa0IseUNBQXNDLENBQUM7QUFDL0YsSUFBTSx3QkFBd0IsR0FBTSxrQkFBa0IsZUFBWSxDQUFDO0FBQ25FLElBQU0sdUJBQXVCLEdBQU0sa0JBQWtCLHNDQUFtQyxDQUFDO0FBQ3pGLElBQU0scUJBQXFCLEdBQU0sa0JBQWtCLFlBQVMsQ0FBQztBQUM3RCxJQUFNLGdCQUFnQixHQUFNLGtCQUFrQixzQkFBbUIsQ0FBQztBQUNsRSxJQUFNLHVCQUF1QixHQUFHLElBQUksQ0FBQzs7QUFFckMsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOzs7Ozs7OztBQVFqQixPQUFPLENBQUMsd0JBQXdCLEdBQUc7Ozs7O3lDQUNKLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7OztBQUF6RCxZQUFJLENBQUMsVUFBVSxDQUFDLElBQUk7O0FBQ3BCLFlBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDOzRDQUNsQyxJQUFJLENBQUMsR0FBRzs7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Ozs7Ozs7Ozs7QUFXRixPQUFPLENBQUMsVUFBVSxHQUFHLG9CQUFnQixTQUFTLEVBQUUsT0FBTyxFQUFFLEtBQUs7Ozs7O3lDQUMvQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDOzs7Ozs7Ozs7O0NBQ3hFLENBQUM7Ozs7Ozs7Ozs7QUFVRixPQUFPLENBQUMsVUFBVSxHQUFHLG9CQUFnQixTQUFTLEVBQUUsT0FBTzs7Ozs7eUNBQ3hDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQzs7Ozs7Ozs7OztDQUNqRSxDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxHQUFHO01BQWdCLE9BQU8seURBQUcsTUFBTTs7Ozs7eUNBQ3JDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFDLE9BQU8sRUFBUCxPQUFPLEVBQUMsQ0FBQzs7Ozs7Ozs7OztDQUNwRCxDQUFDOztxQkFFYSxPQUFPIiwiZmlsZSI6ImxpYi90b29scy9hZGItY29tbWFuZHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBnZXRJTUVMaXN0RnJvbU91dHB1dCwgaXNTaG93aW5nTG9ja3NjcmVlbiwgaXNDdXJyZW50Rm9jdXNPbktleWd1YXJkLFxuICAgICAgICAgZ2V0U3VyZmFjZU9yaWVudGF0aW9uLCBpc1NjcmVlbk9uRnVsbHkgfSBmcm9tICcuLi9oZWxwZXJzLmpzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGZzLCB1dGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IG5ldCBmcm9tICduZXQnO1xuaW1wb3J0IExvZ2NhdCBmcm9tICcuLi9sb2djYXQnO1xuaW1wb3J0IHsgc2xlZXAsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcblxuY29uc3QgU0VUVElOR1NfSEVMUEVSX0lEID0gJ2lvLmFwcGl1bS5zZXR0aW5ncyc7XG5jb25zdCBXSUZJX0NPTk5FQ1RJT05fU0VUVElOR19SRUNFSVZFUiA9IGAke1NFVFRJTkdTX0hFTFBFUl9JRH0vLnJlY2VpdmVycy5XaUZpQ29ubmVjdGlvblNldHRpbmdSZWNlaXZlcmA7XG5jb25zdCBXSUZJX0NPTk5FQ1RJT05fU0VUVElOR19BQ1RJT04gPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9LndpZmlgO1xuY29uc3QgREFUQV9DT05ORUNUSU9OX1NFVFRJTkdfUkVDRUlWRVIgPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9Ly5yZWNlaXZlcnMuRGF0YUNvbm5lY3Rpb25TZXR0aW5nUmVjZWl2ZXJgO1xuY29uc3QgREFUQV9DT05ORUNUSU9OX1NFVFRJTkdfQUNUSU9OID0gYCR7U0VUVElOR1NfSEVMUEVSX0lEfS5kYXRhX2Nvbm5lY3Rpb25gO1xuY29uc3QgQU5JTUFUSU9OX1NFVFRJTkdfUkVDRUlWRVIgPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9Ly5yZWNlaXZlcnMuQW5pbWF0aW9uU2V0dGluZ1JlY2VpdmVyYDtcbmNvbnN0IEFOSU1BVElPTl9TRVRUSU5HX0FDVElPTiA9IGAke1NFVFRJTkdTX0hFTFBFUl9JRH0uYW5pbWF0aW9uYDtcbmNvbnN0IExPQ0FMRV9TRVRUSU5HX1JFQ0VJVkVSID0gYCR7U0VUVElOR1NfSEVMUEVSX0lEfS8ucmVjZWl2ZXJzLkxvY2FsZVNldHRpbmdSZWNlaXZlcmA7XG5jb25zdCBMT0NBTEVfU0VUVElOR19BQ1RJT04gPSBgJHtTRVRUSU5HU19IRUxQRVJfSUR9LmxvY2FsZWA7XG5jb25zdCBMT0NBVElPTl9TRVJWSUNFID0gYCR7U0VUVElOR1NfSEVMUEVSX0lEfS8uTG9jYXRpb25TZXJ2aWNlYDtcbmNvbnN0IE1BWF9TSEVMTF9CVUZGRVJfTEVOR1RIID0gMTAwMDtcblxubGV0IG1ldGhvZHMgPSB7fTtcblxuLyoqXG4gKiBHZXQgdGhlIHBhdGggdG8gYWRiIGV4ZWN1dGFibGUgYW1kIGFzc2lnbiBpdFxuICogdG8gdGhpcy5leGVjdXRhYmxlLnBhdGggYW5kIHRoaXMuYmluYXJpZXMuYWRiIHByb3BlcnRpZXMuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gYWRiIGV4ZWN1dGFibGUuXG4gKi9cbm1ldGhvZHMuZ2V0QWRiV2l0aENvcnJlY3RBZGJQYXRoID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0aGlzLmV4ZWN1dGFibGUucGF0aCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChcImFkYlwiKTtcbiAgdGhpcy5iaW5hcmllcy5hZGIgPSB0aGlzLmV4ZWN1dGFibGUucGF0aDtcbiAgcmV0dXJuIHRoaXMuYWRiO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZ1bGwgcGF0aCB0byBhYXB0IHRvb2wgYW5kIGFzc2lnbiBpdCB0b1xuICogdGhpcy5iaW5hcmllcy5hYXB0IHByb3BlcnR5XG4gKi9cbm1ldGhvZHMuaW5pdEFhcHQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmluYXJpZXMuYWFwdCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChcImFhcHRcIik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZnVsbCBwYXRoIHRvIHppcGFsaWduIHRvb2wgYW5kIGFzc2lnbiBpdCB0b1xuICogdGhpcy5iaW5hcmllcy56aXBhbGlnbiBwcm9wZXJ0eVxuICovXG5tZXRob2RzLmluaXRaaXBBbGlnbiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iaW5hcmllcy56aXBhbGlnbiA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChcInppcGFsaWduXCIpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgQVBJIGxldmVsIG9mIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBBUEkgbGV2ZWwgYXMgaW50ZWdlciBudW1iZXIsIGZvciBleGFtcGxlIDIxIGZvclxuICogICAgICAgICAgICAgICAgICBBbmRyb2lkIExvbGxpcG9wLiBUaGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIGlzIGNhY2hlZCwgc28gYWxsIHRoZSBmdXJ0aGVyXG4gKiBjYWxscyByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGZpcnN0IG9uZS5cbiAqL1xubWV0aG9kcy5nZXRBcGlMZXZlbCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgaWYgKCFfLmlzSW50ZWdlcih0aGlzLl9hcGlMZXZlbCkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyT3V0cHV0ID0gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9wZXJ0eSgncm8uYnVpbGQudmVyc2lvbi5zZGsnKTtcbiAgICAgIHRoaXMuX2FwaUxldmVsID0gcGFyc2VJbnQoc3RyT3V0cHV0LnRyaW0oKSwgMTApO1xuICAgICAgaWYgKGlzTmFOKHRoaXMuX2FwaUxldmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBhY3R1YWwgb3V0cHV0IFwiJHtzdHJPdXRwdXR9XCIgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyYCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGRldmljZSBBUEkgbGV2ZWwuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgbG9nLmRlYnVnKGBEZXZpY2UgQVBJIGxldmVsOiAke3RoaXMuX2FwaUxldmVsfWApO1xuICByZXR1cm4gdGhpcy5fYXBpTGV2ZWw7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBwbGF0Zm9ybSB2ZXJzaW9uIG9mIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwbGF0Zm9ybSB2ZXJzaW9uIGFzIGEgc3RyaW5nLCBmb3IgZXhhbXBsZSAnNS4wJyBmb3JcbiAqIEFuZHJvaWQgTG9sbGlwb3AuXG4gKi9cbm1ldGhvZHMuZ2V0UGxhdGZvcm1WZXJzaW9uID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuaW5mbyhcIkdldHRpbmcgZGV2aWNlIHBsYXRmb3JtIHZlcnNpb25cIik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoJ3JvLmJ1aWxkLnZlcnNpb24ucmVsZWFzZScpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGRldmljZSBwbGF0Zm9ybSB2ZXJzaW9uLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSBkZXZpY2UgaXMgY29ubmVjdGVkLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYXQgbGVhc3Qgb25lIGRldmljZSBpcyB2aXNpYmxlIHRvIGFkYi5cbiAqL1xubWV0aG9kcy5pc0RldmljZUNvbm5lY3RlZCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgcmV0dXJuIGRldmljZXMubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY3JlYXRlIGEgbmV3IGZvbGRlciBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgbmV3IHBhdGggdG8gYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gbWtkaXIgY29tbWFuZCBvdXRwdXQuXG4gKi9cbm1ldGhvZHMubWtkaXIgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5zaGVsbChbJ21rZGlyJywgJy1wJywgcmVtb3RlUGF0aF0pO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgd2hldGhlciB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYVxuICogdmFsaWQgY2xhc3MgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NTdHJpbmcgLSBUaGUgYWN0dWFsIGNsYXNzIG5hbWUgdG8gYmUgdmVyaWZpZWQuXG4gKiBAcmV0dXJuIHs/QXJyYXkuPE1hdGNoPn0gVGhlIHJlc3VsdCBvZiBSZWdleHAuZXhlYyBvcGVyYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBvciBfbnVsbF8gaWYgbm8gbWF0Y2hlcyBhcmUgZm91bmQuXG4gKi9cbm1ldGhvZHMuaXNWYWxpZENsYXNzID0gZnVuY3Rpb24gKGNsYXNzU3RyaW5nKSB7XG4gIC8vIHNvbWUucGFja2FnZS9zb21lLnBhY2thZ2UuQWN0aXZpdHlcbiAgcmV0dXJuIG5ldyBSZWdFeHAoL15bYS16QS1aMC05XFwuL19dKyQvKS5leGVjKGNsYXNzU3RyaW5nKTtcbn07XG5cbi8qKlxuICogRm9yY2UgYXBwbGljYXRpb24gdG8gc3RvcCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgc3RvcHBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZC5cbiAqL1xubWV0aG9kcy5mb3JjZVN0b3AgPSBhc3luYyBmdW5jdGlvbiAocGtnKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLnNoZWxsKFsnYW0nLCAnZm9yY2Utc3RvcCcsIHBrZ10pO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlciBkYXRhIG9mIHRoZSBwYXJ0aWN1bGFyIGFwcGxpY2F0aW9uIG9uIHRoZSBkZXZpY2VcbiAqIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgY2xlYXJlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZC5cbiAqL1xubWV0aG9kcy5jbGVhciA9IGFzeW5jIGZ1bmN0aW9uIChwa2cpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdjbGVhcicsIHBrZ10pO1xufTtcblxuLyoqXG4gKiBHcmFudCBhbGwgcGVybWlzc2lvbnMgcmVxdWVzdGVkIGJ5IHRoZSBwYXJ0aWN1bGFyIHBhY2thZ2UuXG4gKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWZ1bCBvbiBBbmRyb2lkIDYuMCsgYW5kIGZvciBhcHBsaWNhdGlvbnNcbiAqIHRoYXQgc3VwcG9ydCBjb21wb25lbnRzLWJhc2VkIHBlcm1pc3Npb25zIHNldHRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBwYWNrYWdlIG5hbWUgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwayAtIFRoZSBwYXRoIHRvIHRoZSBhY3R1YWwgYXBrIGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8Ym9vbGVhbn0gVGhlIG91dHB1dCBvZiB0aGUgY29ycmVzcG9uZGluZyBhZGIgY29tbWFuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG9yIF9mYWxzZV8gaWYgdGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyBjb21tYW5kIGV4ZWN1dGlvbi5cbiAqL1xubWV0aG9kcy5ncmFudEFsbFBlcm1pc3Npb25zID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgYXBrKSB7XG4gIGxldCBhcGlMZXZlbCA9IGF3YWl0IHRoaXMuZ2V0QXBpTGV2ZWwoKTtcbiAgbGV0IHRhcmdldFNkayA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKCFhcGspIHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgYXBrIG5vdCBwcm92aWRlZCwgY29uc2lkZXJpbmcgYXBrIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2VcbiAgICAgICAqIGFuZCBmZXRjaGluZyB0YXJnZXRTZGsgdXNpbmcgcGFja2FnZSBuYW1lLlxuICAgICAgICovXG4gICAgICB0YXJnZXRTZGsgPSBhd2FpdCB0aGlzLnRhcmdldFNka1ZlcnNpb25Vc2luZ1BLRyhwa2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRTZGsgPSBhd2FpdCB0aGlzLnRhcmdldFNka1ZlcnNpb25Gcm9tTWFuaWZlc3QoYXBrKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvL2F2b2lkaW5nIGxvZ2dpbmcgZXJyb3Igc3RhY2ssIGFzIGNhbGxpbmcgbGlicmFyeSBmdW5jdGlvbiB3b3VsZCBoYXZlIGxvZ2dlZFxuICAgIGxvZy53YXJuKGBSYW4gaW50byBwcm9ibGVtIGdldHRpbmcgdGFyZ2V0IFNESyB2ZXJzaW9uOyBpZ25vcmluZy4uLmApO1xuICB9XG4gIGlmIChhcGlMZXZlbCA+PSAyMyAmJiB0YXJnZXRTZGsgPj0gMjMpIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZGV2aWNlIGlzIHJ1bm5pbmcgQW5kcm9pZCA2LjAoQVBJIDIzKSBvciBoaWdoZXIsIGFuZCB5b3VyIGFwcCdzIHRhcmdldCBTREsgaXMgMjMgb3IgaGlnaGVyOlxuICAgICAqIFRoZSBhcHAgaGFzIHRvIGxpc3QgdGhlIHBlcm1pc3Npb25zIGluIHRoZSBtYW5pZmVzdC5cbiAgICAgKiByZWZlcjogaHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvcGVybWlzc2lvbnMvcmVxdWVzdGluZy5odG1sXG4gICAgICovXG4gICAgY29uc3Qgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2R1bXAnLCBwa2ddKTtcbiAgICBjb25zdCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMuZ2V0UmVxUGVybWlzc2lvbnMocGtnLCBzdGRvdXQpO1xuICAgIGNvbnN0IGdyYW50ZWRQZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMuZ2V0R3JhbnRlZFBlcm1pc3Npb25zKHBrZywgc3Rkb3V0KTtcbiAgICBjb25zdCBwZXJtaXNzb25zVG9HcmFudCA9IHJlcXVlc3RlZFBlcm1pc3Npb25zLmZpbHRlcigoeCkgPT4gZ3JhbnRlZFBlcm1pc3Npb25zLmluZGV4T2YoeCkgPCAwKTtcbiAgICBpZiAoIXBlcm1pc3NvbnNUb0dyYW50Lmxlbmd0aCkge1xuICAgICAgbG9nLmluZm8oYCR7cGtnfSBjb250YWlucyBubyBwZXJtaXNzaW9ucyBhdmFpbGFibGUgZm9yIGdyYW50aW5nLmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEFzIGl0IGNvbnN1bWVzIG1vcmUgdGltZSBmb3IgZ3JhbnRpbmcgZWFjaCBwZXJtaXNzaW9uLFxuICAgIC8vIHRyeWluZyB0byBncmFudCBhbGwgcGVybWlzc2lvbiBieSBmb3JtaW5nIGVxdWl2YWxlbnQgY29tbWFuZC5cbiAgICAvLyBBbHNvLCBpdCBpcyBuZWNlc3NhcnkgdG8gc3BsaXQgbG9uZyBjb21tYW5kcyBpbnRvIGNodW5rcywgc2luY2UgdGhlIG1heGltdW0gbGVuZ3RoIG9mXG4gICAgLy8gYWRiIHNoZWxsIGJ1ZmZlciBpcyBsaW1pdGVkXG4gICAgbGV0IGNtZHMgPSBbXTtcbiAgICBsZXQgY21kQ2h1bmsgPSBbXTtcbiAgICBmb3IgKGxldCBwZXJtaXNzaW9uIG9mIHBlcm1pc3NvbnNUb0dyYW50KSB7XG4gICAgICBjb25zdCBuZXh0Q21kID0gWydwbScsICdncmFudCcsIHBrZywgcGVybWlzc2lvbiwgJzsnXTtcbiAgICAgIGlmIChuZXh0Q21kLmpvaW4oJyAnKS5sZW5ndGggKyBjbWRDaHVuay5qb2luKCcgJykubGVuZ3RoID49IE1BWF9TSEVMTF9CVUZGRVJfTEVOR1RIKSB7XG4gICAgICAgIGNtZHMucHVzaChjbWRDaHVuayk7XG4gICAgICAgIGNtZENodW5rID0gW107XG4gICAgICB9XG4gICAgICBjbWRDaHVuayA9IGNtZENodW5rLmNvbmNhdChuZXh0Q21kKTtcbiAgICB9XG4gICAgaWYgKGNtZENodW5rLmxlbmd0aCkge1xuICAgICAgY21kcy5wdXNoKGNtZENodW5rKTtcbiAgICB9XG4gICAgbG9nLmRlYnVnKGBHb3QgdGhlIGZvbGxvd2luZyBjb21tYW5kIGNodW5rcyB0byBleGVjdXRlOiAke2NtZHN9YCk7XG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgZm9yIChsZXQgY21kIG9mIGNtZHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2hlbGwoY21kKSAmJiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdG8gZ2l2ZSB0aGUgbWV0aG9kIGEgY2hhbmNlIHRvIGFzc2lnbiBhbGwgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBiZWZvcmUgdG8gcXVpdCBpbiBjYXNlIHdlJ2QgbGlrZSB0byBpZ25vcmUgdGhlIGVycm9yIG9uIHRoZSBoaWdoZXIgbGV2ZWxcbiAgICAgICAgbGFzdEVycm9yID0gZTtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLyoqXG4gKiBHcmFudCBzaW5nbGUgcGVybWlzc2lvbiBmb3IgdGhlIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIHBhY2thZ2UgbmFtZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVybWlzc2lvbiAtIFRoZSBmdWxsIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gYmUgZ3JhbnRlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hhbmdpbmcgcGVybWlzc2lvbnMuXG4gKi9cbm1ldGhvZHMuZ3JhbnRQZXJtaXNzaW9uID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgcGVybWlzc2lvbikge1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdncmFudCcsIHBrZywgcGVybWlzc2lvbl0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIm5vdCBhIGNoYW5nZWFibGUgcGVybWlzc2lvbiB0eXBlXCIpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV2b2tlIHNpbmdsZSBwZXJtaXNzaW9uIGZyb20gdGhlIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIHBhY2thZ2UgbmFtZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGVybWlzc2lvbiAtIFRoZSBmdWxsIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdG8gYmUgcmV2b2tlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hhbmdpbmcgcGVybWlzc2lvbnMuXG4gKi9cbm1ldGhvZHMucmV2b2tlUGVybWlzc2lvbiA9IGFzeW5jIGZ1bmN0aW9uIChwa2csIHBlcm1pc3Npb24pIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAncmV2b2tlJywgcGtnLCBwZXJtaXNzaW9uXSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwibm90IGEgY2hhbmdlYWJsZSBwZXJtaXNzaW9uIHR5cGVcIikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBncmFudGVkIHBlcm1pc3Npb25zIGZvciB0aGUgcGFydGljdWxhciBwYWNrYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbWRPdXRwdXQgW251bGxdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIGNvbnRhaW5pbmcgY29tbWFuZCBvdXRwdXQgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BtIGR1bXBfIGNvbW1hbmQuIEl0IHNwZWVkcyB0aGlzIG1ldGhvZCB1cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICogQHJldHVybiB7YXJyYXl9IFRoZSBsaXN0IG9mIGdyYW50ZWQgcGVybWlzc2lvbnMgb3IgYW4gZW1wdHkgbGlzdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgY2hhbmdpbmcgcGVybWlzc2lvbnMuXG4gKi9cbm1ldGhvZHMuZ2V0R3JhbnRlZFBlcm1pc3Npb25zID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgY21kT3V0cHV0ID0gbnVsbCkge1xuICBsZXQgc3Rkb3V0ID0gY21kT3V0cHV0IHx8IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdkdW1wJywgcGtnXSk7XG4gIGxldCBtYXRjaCA9IG5ldyBSZWdFeHAoLyhpbnN0YWxsIHBlcm1pc3Npb25zOnxVc2VyIDApKFtcXHNcXFNdKj8pRFVNUCBPRiBTRVJWSUNFIGFjdGl2aXR5Oi9nKS5leGVjKHN0ZG91dCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgZ3JhbnRlZCBwZXJtaXNzaW9ucycpO1xuICB9XG4gIHJldHVybiAobWF0Y2hbMF0ubWF0Y2goL2FuZHJvaWRcXC5wZXJtaXNzaW9uXFwuXFx3KzpcXHNncmFudGVkPXRydWUvZykgfHwgW10pXG4gICAgLm1hcCgoeCkgPT4geC5yZXBsYWNlKC86XFxzZ3JhbnRlZD10cnVlL2csICcnKSk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRlbmllZCBwZXJtaXNzaW9ucyBmb3IgdGhlIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIHBhY2thZ2UgbmFtZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY21kT3V0cHV0IFtudWxsXSAtIE9wdGlvbmFsIHBhcmFtZXRlciBjb250YWluaW5nIGNvbW1hbmQgb3V0cHV0IG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbSBkdW1wXyBjb21tYW5kLiBJdCBzcGVlZHMgdGhpcyBtZXRob2QgdXBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcHJlc2VudC5cbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgbGlzdCBvZiBkZW5pZWQgcGVybWlzc2lvbnMgb3IgYW4gZW1wdHkgbGlzdC5cbiAqL1xubWV0aG9kcy5nZXREZW5pZWRQZXJtaXNzaW9ucyA9IGFzeW5jIGZ1bmN0aW9uIChwa2csIGNtZE91dHB1dCA9IG51bGwpIHtcbiAgbGV0IHN0ZG91dCA9IGNtZE91dHB1dCB8fCBhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAnZHVtcCcsIHBrZ10pO1xuICBsZXQgbWF0Y2ggPSBuZXcgUmVnRXhwKC8oaW5zdGFsbCBwZXJtaXNzaW9uczp8VXNlciAwKShbXFxzXFxTXSo/KURVTVAgT0YgU0VSVklDRSBhY3Rpdml0eTovZykuZXhlYyhzdGRvdXQpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGRlbmllZCBwZXJtaXNzaW9ucycpO1xuICB9XG4gIHJldHVybiAobWF0Y2hbMF0ubWF0Y2goL2FuZHJvaWRcXC5wZXJtaXNzaW9uXFwuXFx3KzpcXHNncmFudGVkPWZhbHNlL2cpIHx8IFtdKVxuICAgIC5tYXAoKHgpID0+IHgucmVwbGFjZSgvOlxcc2dyYW50ZWQ9ZmFsc2UvZywgJycpKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgcmVxdWVzdGVkIHBlcm1pc3Npb25zIGZvciB0aGUgcGFydGljdWxhciBwYWNrYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbWRPdXRwdXQgW251bGxdIC0gT3B0aW9uYWwgcGFyYW1ldGVyIGNvbnRhaW5pbmcgY29tbWFuZCBvdXRwdXQgb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BtIGR1bXBfIGNvbW1hbmQuIEl0IHNwZWVkcyB0aGlzIG1ldGhvZCB1cFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwcmVzZW50LlxuICogQHJldHVybiB7YXJyYXl9IFRoZSBsaXN0IG9mIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmdldFJlcVBlcm1pc3Npb25zID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgY21kT3V0cHV0ID0gbnVsbCkge1xuICBsZXQgc3Rkb3V0ID0gY21kT3V0cHV0IHx8IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdkdW1wJywgcGtnXSk7XG4gIGxldCBtYXRjaCA9IG5ldyBSZWdFeHAoL3JlcXVlc3RlZCBwZXJtaXNzaW9uczooW1xcc1xcU10qPykoaW5zdGFsbCBwZXJtaXNzaW9uczp8VXNlciAwKS9nKS5leGVjKHN0ZG91dCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgcmVxdWVzdGVkIHBlcm1pc3Npb25zJyk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoWzBdLm1hdGNoKC9hbmRyb2lkXFwucGVybWlzc2lvblxcLlxcdysvZykgfHwgW107XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGxvY2F0aW9uIHByb3ZpZGVycyBmb3IgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgbG9jYXRpb24gcHJvdmlkZXJzIG9yIGFuIGVtcHR5IGxpc3QuXG4gKi9cbm1ldGhvZHMuZ2V0TG9jYXRpb25Qcm92aWRlcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ3NlY3VyZScsICdsb2NhdGlvbl9wcm92aWRlcnNfYWxsb3dlZCcpO1xuICByZXR1cm4gc3Rkb3V0LnRyaW0oKS5zcGxpdCgnLCcpXG4gICAgLm1hcCgocCkgPT4gcC50cmltKCkpXG4gICAgLmZpbHRlcihCb29sZWFuKTtcbn07XG5cbi8qKlxuICogVG9nZ2xlIHRoZSBzdGF0ZSBvZiBHUFMgbG9jYXRpb24gcHJvdmlkZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIC0gV2hldGhlciB0byBlbmFibGUgKHRydWUpIG9yIGRpc2FibGUgKGZhbHNlKSB0aGUgR1BTIHByb3ZpZGVyLlxuICovXG5tZXRob2RzLnRvZ2dsZUdQU0xvY2F0aW9uUHJvdmlkZXIgPSBhc3luYyBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICBhd2FpdCB0aGlzLnNldFNldHRpbmcoJ3NlY3VyZScsICdsb2NhdGlvbl9wcm92aWRlcnNfYWxsb3dlZCcsIGAke2VuYWJsZWQgPyBcIitcIiA6IFwiLVwifWdwc2ApO1xufTtcblxuLyoqXG4gKiBTdG9wIHRoZSBwYXJ0aWN1bGFyIHBhY2thZ2UgaWYgaXQgaXMgcnVubmluZyBhbmQgY2xlYXJzIGl0cyBhcHBsaWNhdGlvbiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqL1xubWV0aG9kcy5zdG9wQW5kQ2xlYXIgPSBhc3luYyBmdW5jdGlvbiAocGtnKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5mb3JjZVN0b3AocGtnKTtcbiAgICBhd2FpdCB0aGlzLmNsZWFyKHBrZyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdG9wIGFuZCBjbGVhciAke3BrZ30uIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdGFyZ2V0IFNESyB2ZXJzaW9uIGZvciB0aGUgcGFydGljdWxhciBwYWNrYWdlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgcGFja2FnZSBuYW1lIHRvIGJlIHByb2Nlc3NlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHBhcnNlZCBTREsgdmVyc2lvbi5cbiAqL1xubWV0aG9kcy5nZXRUYXJnZXRTZGtVc2luZ1BLRyA9IGFzeW5jIGZ1bmN0aW9uIChwa2cpIHtcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdkdW1wJywgcGtnXSk7XG4gIGxldCB0YXJnZXRTZGsgPSBuZXcgUmVnRXhwKC90YXJnZXRTZGs9KFteXFxzXFxzXSspL2cpLmV4ZWMoc3Rkb3V0KVsxXTtcbiAgcmV0dXJuIHRhcmdldFNkaztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGlucHV0IG1ldGhvZHMgKElNRXMpIGZvciB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBsaXN0IG9mIElNRSBuYW1lcyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmF2YWlsYWJsZUlNRXMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldElNRUxpc3RGcm9tT3V0cHV0KGF3YWl0IHRoaXMuc2hlbGwoWydpbWUnLCAnbGlzdCcsICctYSddKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgYXZhaWxhYmxlIElNRSdzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZW5hYmxlZCBpbnB1dCBtZXRob2RzIChJTUVzKSBmb3IgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgbGlzdCBvZiBlbmFibGVkIElNRSBuYW1lcyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmVuYWJsZWRJTUVzID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiBnZXRJTUVMaXN0RnJvbU91dHB1dChhd2FpdCB0aGlzLnNoZWxsKFsnaW1lJywgJ2xpc3QnXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVuYWJsZWQgSU1FJ3MuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgdGhlIHBhcnRpY3VsYXIgaW5wdXQgbWV0aG9kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1lSWQgLSBPbmUgb2YgZXhpc3RpbmcgSU1FIGlkcy5cbiAqL1xubWV0aG9kcy5lbmFibGVJTUUgPSBhc3luYyBmdW5jdGlvbiAoaW1lSWQpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2ltZScsICdlbmFibGUnLCBpbWVJZF0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIHRoZSBwYXJ0aWN1bGFyIGlucHV0IG1ldGhvZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGltZUlkIC0gT25lIG9mIGV4aXN0aW5nIElNRSBpZHMuXG4gKi9cbm1ldGhvZHMuZGlzYWJsZUlNRSA9IGFzeW5jIGZ1bmN0aW9uIChpbWVJZCkge1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnaW1lJywgJ2Rpc2FibGUnLCBpbWVJZF0pO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcnRpY3VsYXIgaW5wdXQgbWV0aG9kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW1lSWQgLSBPbmUgb2YgZXhpc3RpbmcgSU1FIGlkcy5cbiAqL1xubWV0aG9kcy5zZXRJTUUgPSBhc3luYyBmdW5jdGlvbiAoaW1lSWQpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2ltZScsICdzZXQnLCBpbWVJZF0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgaW5wdXQgbWV0aG9kIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGlucHV0IG1ldGhvZC5cbiAqL1xubWV0aG9kcy5kZWZhdWx0SU1FID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCBlbmdpbmUgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ3NlY3VyZScsICdkZWZhdWx0X2lucHV0X21ldGhvZCcpO1xuICAgIHJldHVybiBlbmdpbmUudHJpbSgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGRlZmF1bHQgSU1FLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZCB0aGUgcGFydGljdWxhciBrZXljb2RlIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGtleWNvZGUgLSBUaGUgYWN0dWFsIGtleSBjb2RlIHRvIGJlIHNlbnQuXG4gKi9cbm1ldGhvZHMua2V5ZXZlbnQgPSBhc3luYyBmdW5jdGlvbiAoa2V5Y29kZSkge1xuICAvLyBrZXljb2RlIG11c3QgYmUgYW4gaW50LlxuICBsZXQgY29kZSA9IHBhcnNlSW50KGtleWNvZGUsIDEwKTtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2lucHV0JywgJ2tleWV2ZW50JywgY29kZV0pO1xufTtcblxuLyoqXG4gKiBTZW5kIHRoZSBwYXJ0aWN1bGFyIHRleHQgdG8gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIGFjdHVhbCB0ZXh0IHRvIGJlIHNlbnQuXG4gKi9cbm1ldGhvZHMuaW5wdXRUZXh0ID0gYXN5bmMgZnVuY3Rpb24gKHRleHQpIHtcbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAvLyBuZWVkIHRvIGVzY2FwZSB3aGl0ZXNwYWNlIGFuZCAoICkgPCA+IHwgOyAmICogXFwgfiBcIiAnXG4gIHRleHQgPSB0ZXh0XG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgICAucmVwbGFjZSgvXFwoL2csICdcXCgnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXCkvZywgJ1xcKScpXG4gICAgICAgICAgLnJlcGxhY2UoLzwvZywgJ1xcPCcpXG4gICAgICAgICAgLnJlcGxhY2UoLz4vZywgJ1xcPicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcfC9nLCAnXFx8JylcbiAgICAgICAgICAucmVwbGFjZSgvOy9nLCAnXFw7JylcbiAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnXFwmJylcbiAgICAgICAgICAucmVwbGFjZSgvXFwqL2csICdcXConKVxuICAgICAgICAgIC5yZXBsYWNlKC9+L2csICdcXH4nKVxuICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcIicpXG4gICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXCdcIilcbiAgICAgICAgICAucmVwbGFjZSgvIC9nLCAnJXMnKTtcbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2lucHV0JywgJ3RleHQnLCB0ZXh0XSk7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBhY3RpdmUgdGV4dCBmaWVsZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QgYnkgc2VuZGluZ1xuICogc3BlY2lhbCBrZXlldmVudHMgdG8gaXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBbMTAwXSAtIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgdGV4dCBpbiB0aGUgZmllbGQgdG8gYmUgY2xlYXJlZC5cbiAqL1xubWV0aG9kcy5jbGVhclRleHRGaWVsZCA9IGFzeW5jIGZ1bmN0aW9uIChsZW5ndGggPSAxMDApIHtcbiAgLy8gYXNzdW1lcyB0aGF0IHRoZSBFZGl0VGV4dCBmaWVsZCBhbHJlYWR5IGhhcyBmb2N1c1xuICBsb2cuZGVidWcoYENsZWFyaW5nIHVwIHRvICR7bGVuZ3RofSBjaGFyYWN0ZXJzYCk7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGFyZ3MgPSBbJ2lucHV0JywgJ2tleWV2ZW50J107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAvLyB3ZSBjYW5ub3Qga25vdyB3aGVyZSB0aGUgY3Vyc29yIGlzIGluIHRoZSB0ZXh0IGZpZWxkLCBzbyBkZWxldGUgYm90aCBiZWZvcmVcbiAgICAvLyBhbmQgYWZ0ZXIgc28gdGhhdCB3ZSBnZXQgcmlkIG9mIGV2ZXJ5dGhpbmdcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC92aWV3L0tleUV2ZW50Lmh0bWwjS0VZQ09ERV9ERUxcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC92aWV3L0tleUV2ZW50Lmh0bWwjS0VZQ09ERV9GT1JXQVJEX0RFTFxuICAgIGFyZ3MucHVzaCgnNjcnLCAnMTEyJyk7XG4gIH1cbiAgYXdhaXQgdGhpcy5zaGVsbChhcmdzKTtcbn07XG5cbi8qKlxuICogU2VuZCB0aGUgc3BlY2lhbCBrZXljb2RlIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdCBpbiBvcmRlciB0byBsb2NrIGl0LlxuICovXG5tZXRob2RzLmxvY2sgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmIChhd2FpdCB0aGlzLmlzU2NyZWVuTG9ja2VkKCkpIHtcbiAgICBsb2cuZGVidWcoXCJTY3JlZW4gaXMgYWxyZWFkeSBsb2NrZWQuIERvaW5nIG5vdGhpbmcuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBsb2cuZGVidWcoXCJQcmVzc2luZyB0aGUgS0VZQ09ERV9QT1dFUiBidXR0b24gdG8gbG9jayBzY3JlZW5cIik7XG4gIGF3YWl0IHRoaXMua2V5ZXZlbnQoMjYpO1xuXG4gIGNvbnN0IHRpbWVvdXRNcyA9IDUwMDA7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmlzU2NyZWVuTG9ja2VkKCksIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogNTAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGV2aWNlIHNjcmVlbiBpcyBzdGlsbCBsb2NrZWQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXMgdGltZW91dGApO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmQgdGhlIHNwZWNpYWwga2V5Y29kZSB0byB0aGUgZGV2aWNlIHVuZGVyIHRlc3QgaW4gb3JkZXIgdG8gZW11bGF0ZVxuICogQmFjayBidXR0b24gdGFwLlxuICovXG5tZXRob2RzLmJhY2sgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIlByZXNzaW5nIHRoZSBCQUNLIGJ1dHRvblwiKTtcbiAgYXdhaXQgdGhpcy5rZXlldmVudCg0KTtcbn07XG5cbi8qKlxuICogU2VuZCB0aGUgc3BlY2lhbCBrZXljb2RlIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdCBpbiBvcmRlciB0byBlbXVsYXRlXG4gKiBIb21lIGJ1dHRvbiB0YXAuXG4gKi9cbm1ldGhvZHMuZ29Ub0hvbWUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIlByZXNzaW5nIHRoZSBIT01FIGJ1dHRvblwiKTtcbiAgYXdhaXQgdGhpcy5rZXlldmVudCgzKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgYWN0dWFsIHBhdGggdG8gYWRiIGV4ZWN1dGFibGUuXG4gKi9cbm1ldGhvZHMuZ2V0QWRiUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZXhlY3V0YWJsZS5wYXRoO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBvcmllbnRhdGlvbiBlbmNvZGVkIGFzIGFuIGludGVnZXIgbnVtYmVyLlxuICovXG5tZXRob2RzLmdldFNjcmVlbk9yaWVudGF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ2R1bXBzeXMnLCAnaW5wdXQnXSk7XG4gIHJldHVybiBnZXRTdXJmYWNlT3JpZW50YXRpb24oc3Rkb3V0KTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHNjcmVlbiBsb2NrIHN0YXRlIG9mIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBkZXZpY2UgaXMgbG9ja2VkLlxuICovXG5tZXRob2RzLmlzU2NyZWVuTG9ja2VkID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ2R1bXBzeXMnLCAnd2luZG93J10pO1xuICBpZiAocHJvY2Vzcy5lbnYuQVBQSVVNX0xPR19EVU1QU1lTKSB7XG4gICAgLy8gb3B0aW9uYWwgZGVidWdnaW5nXG4gICAgLy8gaWYgdGhlIG1ldGhvZCBpcyBub3Qgd29ya2luZywgdHVybiBpdCBvbiBhbmQgc2VuZCB1cyB0aGUgb3V0cHV0XG4gICAgbGV0IGR1bXBzeXNGaWxlID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIFwiZHVtcHN5cy5sb2dcIik7XG4gICAgbG9nLmRlYnVnKGBXcml0aW5nIGR1bXBzeXMgb3V0cHV0IHRvICR7ZHVtcHN5c0ZpbGV9YCk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGR1bXBzeXNGaWxlLCBzdGRvdXQpO1xuICB9XG4gIHJldHVybiAoaXNTaG93aW5nTG9ja3NjcmVlbihzdGRvdXQpIHx8IGlzQ3VycmVudEZvY3VzT25LZXlndWFyZChzdGRvdXQpIHx8XG4gICAgICAgICAgIWlzU2NyZWVuT25GdWxseShzdGRvdXQpKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHN0YXRlIG9mIHRoZSBzb2Z0d2FyZSBrZXlib2FyZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc29mdHdhcmUga2V5Ym9hcmQgaXMgcHJlc2VudC5cbiAqL1xubWV0aG9kcy5pc1NvZnRLZXlib2FyZFByZXNlbnQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydkdW1wc3lzJywgJ2lucHV0X21ldGhvZCddKTtcbiAgICBsZXQgaXNLZXlib2FyZFNob3duID0gZmFsc2UsXG4gICAgICAgIGNhbkNsb3NlS2V5Ym9hcmQgPSBmYWxzZSxcbiAgICAgICAgaW5wdXRTaG93bk1hdGNoID0gL21JbnB1dFNob3duPVxcdysvZ2kuZXhlYyhzdGRvdXQpO1xuICAgIGlmIChpbnB1dFNob3duTWF0Y2ggJiYgaW5wdXRTaG93bk1hdGNoWzBdKSB7XG4gICAgICBpc0tleWJvYXJkU2hvd24gPSBpbnB1dFNob3duTWF0Y2hbMF0uc3BsaXQoJz0nKVsxXSA9PT0gJ3RydWUnO1xuICAgICAgbGV0IGlzSW5wdXRWaWV3U2hvd25NYXRjaCA9IC9tSXNJbnB1dFZpZXdTaG93bj1cXHcrL2dpLmV4ZWMoc3Rkb3V0KTtcbiAgICAgIGlmIChpc0lucHV0Vmlld1Nob3duTWF0Y2ggJiYgaXNJbnB1dFZpZXdTaG93bk1hdGNoWzBdKSB7XG4gICAgICAgIGNhbkNsb3NlS2V5Ym9hcmQgPSBpc0lucHV0Vmlld1Nob3duTWF0Y2hbMF0uc3BsaXQoJz0nKVsxXSA9PT0gJ3RydWUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge2lzS2V5Ym9hcmRTaG93biwgY2FuQ2xvc2VLZXlib2FyZH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGZpbmRpbmcgc29mdGtleWJvYXJkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZCBhbiBhcmJpdHJhcnkgVGVsbmV0IGNvbW1hbmQgdG8gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tYW5kIC0gVGhlIGNvbW1hbmQgdG8gYmUgc2VudC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBhY3R1YWwgb3V0cHV0IG9mIHRoZSBnaXZlbiBjb21tYW5kLlxuICovXG5tZXRob2RzLnNlbmRUZWxuZXRDb21tYW5kID0gYXN5bmMgZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgbG9nLmRlYnVnKGBTZW5kaW5nIHRlbG5ldCBjb21tYW5kIHRvIGRldmljZTogJHtjb21tYW5kfWApO1xuICBsZXQgcG9ydCA9IGF3YWl0IHRoaXMuZ2V0RW11bGF0b3JQb3J0KCk7XG4gIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGNvbm4gPSBuZXQuY3JlYXRlQ29ubmVjdGlvbihwb3J0LCAnbG9jYWxob3N0JyksXG4gICAgICAgIGNvbm5lY3RlZCA9IGZhbHNlLFxuICAgICAgICByZWFkeVJlZ2V4ID0gL15PSyQvbSxcbiAgICAgICAgZGF0YVN0cmVhbSA9IFwiXCIsXG4gICAgICAgIHJlcyA9IG51bGw7XG4gICAgY29ubi5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGxvZy5kZWJ1ZyhcIlNvY2tldCBjb25uZWN0aW9uIHRvIGRldmljZSBjcmVhdGVkXCIpO1xuICAgIH0pO1xuICAgIGNvbm4ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICAgIGlmIChyZWFkeVJlZ2V4LnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNvY2tldCBjb25uZWN0aW9uIHRvIGRldmljZSByZWFkeVwiKTtcbiAgICAgICAgICBjb25uLndyaXRlKGAke2NvbW1hbmR9XFxuYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFTdHJlYW0gKz0gZGF0YTtcbiAgICAgICAgaWYgKHJlYWR5UmVnZXgudGVzdChkYXRhKSkge1xuICAgICAgICAgIHJlcyA9IGRhdGFTdHJlYW0ucmVwbGFjZShyZWFkeVJlZ2V4LCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgcmVzID0gXy5sYXN0KHJlcy50cmltKCkuc3BsaXQoJ1xcbicpKTtcbiAgICAgICAgICBsb2cuZGVidWcoYFRlbG5ldCBjb21tYW5kIGdvdCByZXNwb25zZTogJHtyZXN9YCk7XG4gICAgICAgICAgY29ubi53cml0ZShcInF1aXRcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25uLm9uKCdlcnJvcicsIChlcnIpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by1jYWxsYmFja3NcbiAgICAgIGxvZy5kZWJ1ZyhgVGVsbmV0IGNvbW1hbmQgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcbiAgICBjb25uLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIk5ldmVyIGdvdCBhIHJlc3BvbnNlIGZyb20gY29tbWFuZFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGVjayB0aGUgc3RhdGUgb2YgQWlycGxhbmUgbW9kZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBBaXJwbGFuZSBtb2RlIGlzIGVuYWJsZWQuXG4gKi9cbm1ldGhvZHMuaXNBaXJwbGFuZU1vZGVPbiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuZ2V0U2V0dGluZygnZ2xvYmFsJywgJ2FpcnBsYW5lX21vZGVfb24nKTtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ZG91dCwgMTApICE9PSAwO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHN0YXRlIG9mIEFpcnBsYW5lIG1vZGUgaW4gU2V0dGluZ3Mgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb24gLSBUcnVlIHRvIGVuYWJsZSB0aGUgQWlycGxhbmUgbW9kZSBpbiBTZXR0aW5ncyBhbmQgZmFsc2UgdG8gZGlzYWJsZSBpdC5cbiAqL1xubWV0aG9kcy5zZXRBaXJwbGFuZU1vZGUgPSBhc3luYyBmdW5jdGlvbiAob24pIHtcbiAgYXdhaXQgdGhpcy5zZXRTZXR0aW5nKCdnbG9iYWwnLCAnYWlycGxhbmVfbW9kZV9vbicsIG9uID8gMSA6IDApO1xufTtcblxuLyoqXG4gKiBCcm9hZGNhc3QgdGhlIHN0YXRlIG9mIEFpcnBsYW5lIG1vZGUgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB7QGxpbmsgI3NldEFpcnBsYW5lTW9kZX0sIG90aGVyd2lzZVxuICogdGhlIG1vZGUgY2hhbmdlIGlzIG5vdCBnb2luZyB0byBiZSBhcHBsaWVkIGZvciB0aGUgZGV2aWNlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb24gLSBUcnVlIHRvIGJyb2FkY2FzdCBlbmFibGUgYW5kIGZhbHNlIHRvIGJyb2FkY2FzdCBkaXNhYmxlLlxuICovXG5tZXRob2RzLmJyb2FkY2FzdEFpcnBsYW5lTW9kZSA9IGFzeW5jIGZ1bmN0aW9uIChvbikge1xuICBsZXQgYXJncyA9IFsnYW0nLCAnYnJvYWRjYXN0JywgJy1hJywgJ2FuZHJvaWQuaW50ZW50LmFjdGlvbi5BSVJQTEFORV9NT0RFJyxcbiAgICAgICAgICAgICAgJy0tZXonLCAnc3RhdGUnLCBvbiA/ICd0cnVlJyA6ICdmYWxzZSddO1xuICBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDaGVjayB0aGUgc3RhdGUgb2YgV2lGaSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBXaUZpIGlzIGVuYWJsZWQuXG4gKi9cbm1ldGhvZHMuaXNXaWZpT24gPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ2dsb2JhbCcsICd3aWZpX29uJyk7XG4gIHJldHVybiAocGFyc2VJbnQoc3Rkb3V0LCAxMCkgIT09IDApO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHN0YXRlIG9mIFdpRmkgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb24gLSBUcnVlIHRvIGVuYWJsZSBhbmQgZmFsc2UgdG8gZGlzYWJsZSBpdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbXVsYXRvciBbZmFsc2VdIC0gU2V0IGl0IHRvIHRydWUgaWYgdGhlIGRldmljZSB1bmRlciB0ZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGFuIGVtdWxhdG9yIHJhdGhlciB0aGFuIGEgcmVhbCBkZXZpY2UuXG4gKi9cbm1ldGhvZHMuc2V0V2lmaVN0YXRlID0gYXN5bmMgZnVuY3Rpb24gKG9uLCBpc0VtdWxhdG9yID0gZmFsc2UpIHtcbiAgaWYgKGlzRW11bGF0b3IpIHtcbiAgICBjb25zdCBpc1Jvb3QgPSBhd2FpdCB0aGlzLnJvb3QoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N2YycsICd3aWZpJywgb24gPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudW5yb290KCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdicm9hZGNhc3QnLCAnLWEnLCBXSUZJX0NPTk5FQ1RJT05fU0VUVElOR19BQ1RJT04sXG4gICAgICAgICAgICAgICAgICAgICAgJy1uJywgV0lGSV9DT05ORUNUSU9OX1NFVFRJTkdfUkVDRUlWRVIsXG4gICAgICAgICAgICAgICAgICAgICAgJy0tZXMnLCAnc2V0c3RhdHVzJywgb24gPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10pO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBzdGF0ZSBvZiBEYXRhIHRyYW5zZmVyIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIERhdGEgdHJhbnNmZXIgaXMgZW5hYmxlZC5cbiAqL1xubWV0aG9kcy5pc0RhdGFPbiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuZ2V0U2V0dGluZygnZ2xvYmFsJywgJ21vYmlsZV9kYXRhJyk7XG4gIHJldHVybiAocGFyc2VJbnQoc3Rkb3V0LCAxMCkgIT09IDApO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHN0YXRlIG9mIERhdGEgdHJhbnNmZXIgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb24gLSBUcnVlIHRvIGVuYWJsZSBhbmQgZmFsc2UgdG8gZGlzYWJsZSBpdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNFbXVsYXRvciBbZmFsc2VdIC0gU2V0IGl0IHRvIHRydWUgaWYgdGhlIGRldmljZSB1bmRlciB0ZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGFuIGVtdWxhdG9yIHJhdGhlciB0aGFuIGEgcmVhbCBkZXZpY2UuXG4gKi9cbm1ldGhvZHMuc2V0RGF0YVN0YXRlID0gYXN5bmMgZnVuY3Rpb24gKG9uLCBpc0VtdWxhdG9yID0gZmFsc2UpIHtcbiAgaWYgKGlzRW11bGF0b3IpIHtcbiAgICBjb25zdCBpc1Jvb3QgPSBhd2FpdCB0aGlzLnJvb3QoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N2YycsICdkYXRhJywgb24gPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudW5yb290KCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdicm9hZGNhc3QnLCAnLWEnLCBEQVRBX0NPTk5FQ1RJT05fU0VUVElOR19BQ1RJT04sXG4gICAgICAgICAgICAgICAgICAgICAgJy1uJywgREFUQV9DT05ORUNUSU9OX1NFVFRJTkdfUkVDRUlWRVIsXG4gICAgICAgICAgICAgICAgICAgICAgJy0tZXMnLCAnc2V0c3RhdHVzJywgb24gPyAnZW5hYmxlJyA6ICdkaXNhYmxlJ10pO1xuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgc3RhdGUgb2YgV2lGaSBhbmQvb3IgRGF0YSB0cmFuc2ZlciBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB3aWZpIC0gVHJ1ZSB0byBlbmFibGUgYW5kIGZhbHNlIHRvIGRpc2FibGUgV2lGaS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGF0YSAtIFRydWUgdG8gZW5hYmxlIGFuZCBmYWxzZSB0byBkaXNhYmxlIERhdGEgdHJhbnNmZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW11bGF0b3IgW2ZhbHNlXSAtIFNldCBpdCB0byB0cnVlIGlmIHRoZSBkZXZpY2UgdW5kZXIgdGVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhbiBlbXVsYXRvciByYXRoZXIgdGhhbiBhIHJlYWwgZGV2aWNlLlxuICovXG5tZXRob2RzLnNldFdpZmlBbmREYXRhID0gYXN5bmMgZnVuY3Rpb24gKHt3aWZpLCBkYXRhfSwgaXNFbXVsYXRvciA9IGZhbHNlKSB7XG4gIGlmICh1dGlsLmhhc1ZhbHVlKHdpZmkpKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRXaWZpU3RhdGUod2lmaSwgaXNFbXVsYXRvcik7XG4gIH1cbiAgaWYgKHV0aWwuaGFzVmFsdWUoZGF0YSkpIHtcbiAgICBhd2FpdCB0aGlzLnNldERhdGFTdGF0ZShkYXRhLCBpc0VtdWxhdG9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHN0YXRlIG9mIGFuaW1hdGlvbiBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiBBbmltYXRpb24gb24gdGhlIGRldmljZSBpcyBjb250cm9sbGVkIGJ5IHRoZSBmb2xsb3dpbmcgZ2xvYmFsIHByb3BlcnRpZXM6XG4gKiBbQU5JTUFUT1JfRFVSQVRJT05fU0NBTEVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3Byb3ZpZGVyL1NldHRpbmdzLkdsb2JhbC5odG1sI0FOSU1BVE9SX0RVUkFUSU9OX1NDQUxFfSxcbiAqIFtUUkFOU0lUSU9OX0FOSU1BVElPTl9TQ0FMRV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vcmVmZXJlbmNlL2FuZHJvaWQvcHJvdmlkZXIvU2V0dGluZ3MuR2xvYmFsLmh0bWwjVFJBTlNJVElPTl9BTklNQVRJT05fU0NBTEV9LFxuICogW1dJTkRPV19BTklNQVRJT05fU0NBTEVde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3Byb3ZpZGVyL1NldHRpbmdzLkdsb2JhbC5odG1sI1dJTkRPV19BTklNQVRJT05fU0NBTEV9LlxuICogVGhpcyBtZXRob2Qgc2V0cyBhbGwgdGhpcyBwcm9wZXJ0aWVzIHRvIDAuMCB0byBkaXNhYmxlICgxLjAgdG8gZW5hYmxlKSBhbmltYXRpb24uXG4gKlxuICogVHVybmluZyBvZmYgYW5pbWF0aW9uIG1pZ2h0IGJlIHVzZWZ1bCB0byBpbXByb3ZlIHN0YWJpbGl0eVxuICogYW5kIHJlZHVjZSB0ZXN0cyBleGVjdXRpb24gdGltZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9uIC0gVHJ1ZSB0byBlbmFibGUgYW5kIGZhbHNlIHRvIGRpc2FibGUgaXQuXG4gKi9cbm1ldGhvZHMuc2V0QW5pbWF0aW9uU3RhdGUgPSBhc3luYyBmdW5jdGlvbiAob24pIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2FtJywgJ2Jyb2FkY2FzdCcsICctYScsIEFOSU1BVElPTl9TRVRUSU5HX0FDVElPTixcbiAgICAgICAgICAgICAgICAgICAgJy1uJywgQU5JTUFUSU9OX1NFVFRJTkdfUkVDRUlWRVIsXG4gICAgICAgICAgICAgICAgICAgICctLWVzJywgJ3NldHN0YXR1cycsIG9uID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHN0YXRlIG9mIGFuaW1hdGlvbiBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhdCBsZWFzdCBvbmUgb2YgYW5pbWF0aW9uIHNjYWxlIHNldHRpbmdzXG4gKiAgICAgICAgICAgICAgICAgICBpcyBub3QgZXF1YWwgdG8gJzAuMCcuXG4gKi9cbm1ldGhvZHMuaXNBbmltYXRpb25PbiA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGFuaW1hdG9yX2R1cmF0aW9uX3NjYWxlID0gYXdhaXQgdGhpcy5nZXRTZXR0aW5nKCdnbG9iYWwnLCAnYW5pbWF0b3JfZHVyYXRpb25fc2NhbGUnKTtcbiAgbGV0IHRyYW5zaXRpb25fYW5pbWF0aW9uX3NjYWxlID0gYXdhaXQgdGhpcy5nZXRTZXR0aW5nKCdnbG9iYWwnLCAndHJhbnNpdGlvbl9hbmltYXRpb25fc2NhbGUnKTtcbiAgbGV0IHdpbmRvd19hbmltYXRpb25fc2NhbGUgPSBhd2FpdCB0aGlzLmdldFNldHRpbmcoJ2dsb2JhbCcsICd3aW5kb3dfYW5pbWF0aW9uX3NjYWxlJyk7XG4gIHJldHVybiBfLnNvbWUoW2FuaW1hdG9yX2R1cmF0aW9uX3NjYWxlLCB0cmFuc2l0aW9uX2FuaW1hdGlvbl9zY2FsZSwgd2luZG93X2FuaW1hdGlvbl9zY2FsZV0sXG4gICAgICAgICAgICAgICAgKHNldHRpbmcpID0+IHNldHRpbmcgIT09ICcwLjAnKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBsb2NhbGUgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LiBEb24ndCBuZWVkIHRvIHJlYm9vdCB0aGUgZGV2aWNlIGFmdGVyIGNoYW5naW5nIHRoZSBsb2NhbGUuXG4gKiBUaGlzIG1ldGhvZCBzZXRzIGFuIGFyYml0cmFyeSBsb2NhbGUgZm9sbG93aW5nOlxuICogICBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvamF2YS91dGlsL0xvY2FsZS5odG1sXG4gKiAgIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9qYXZhL3V0aWwvTG9jYWxlLmh0bWwjTG9jYWxlKGphdmEubGFuZy5TdHJpbmcsJTIwamF2YS5sYW5nLlN0cmluZylcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgLSBMYW5ndWFnZS4gZS5nLiBlbiwgamFcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb3VudHJ5IC0gQ291bnRyeS4gZS5nLiBVUywgSlBcbiAqL1xubWV0aG9kcy5zZXREZXZpY2VTeXNMb2NhbGVWaWFTZXR0aW5nQXBwID0gYXN5bmMgZnVuY3Rpb24gKGxhbmd1YWdlLCBjb3VudHJ5KSB7XG4gIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdicm9hZGNhc3QnLCAnLWEnLCBMT0NBTEVfU0VUVElOR19BQ1RJT04sXG4gICAgJy1uJywgTE9DQUxFX1NFVFRJTkdfUkVDRUlWRVIsXG4gICAgJy0tZXMnLCAnbGFuZycsIGxhbmd1YWdlLnRvTG93ZXJDYXNlKCksXG4gICAgJy0tZXMnLCAnY291bnRyeScsIGNvdW50cnkudG9VcHBlckNhc2UoKV0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2NhdGlvblxuICogQHByb3BlcnR5IHtmbG9hdHxzdHJpbmd9IGxvbmdpdHVkZSAtIFZhbGlkIGxvbmdpdHVkZSB2YWx1ZS5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR8c3RyaW5nfSBsYXRpdHVkZSAtIFZhbGlkIGxhdGl0dWRlIHZhbHVlLlxuICovXG5cbi8qKlxuICogRW11bGF0ZSBnZW9sb2NhdGlvbiBjb29yZGluYXRlcyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtMb2NhdGlvbn0gbG9jYXRpb24gLSBMb2NhdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRW11bGF0b3IgW2ZhbHNlXSAtIFNldCBpdCB0byB0cnVlIGlmIHRoZSBkZXZpY2UgdW5kZXIgdGVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhbiBlbXVsYXRvciByYXRoZXIgdGhhbiBhIHJlYWwgZGV2aWNlLlxuICovXG5tZXRob2RzLnNldEdlb0xvY2F0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGxvY2F0aW9uLCBpc0VtdWxhdG9yID0gZmFsc2UpIHtcbiAgbGV0IGxvbmdpdHVkZSA9IHBhcnNlRmxvYXQobG9jYXRpb24ubG9uZ2l0dWRlKTtcbiAgaWYgKGlzTmFOKGxvbmdpdHVkZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGxvY2F0aW9uLmxvbmdpdHVkZSBpcyBleHBlY3RlZCB0byBiZSBhIHZhbGlkIGZsb2F0IG51bWJlci4gJyR7bG9jYXRpb24ubG9uZ2l0dWRlfScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGxvbmdpdHVkZSA9IGAke18uY2VpbChsb25naXR1ZGUsIDUpfWA7XG4gIGxldCBsYXRpdHVkZSA9IHBhcnNlRmxvYXQobG9jYXRpb24ubGF0aXR1ZGUpO1xuICBpZiAoaXNOYU4obGF0aXR1ZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsb2NhdGlvbi5sYXRpdHVkZSBpcyBleHBlY3RlZCB0byBiZSBhIHZhbGlkIGZsb2F0IG51bWJlci4gJyR7bG9jYXRpb24ubGF0aXR1ZGV9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgbGF0aXR1ZGUgPSBgJHtfLmNlaWwobGF0aXR1ZGUsIDUpfWA7XG4gIGlmIChpc0VtdWxhdG9yKSB7XG4gICAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsICdnZW8nLCAnZml4JywgbG9uZ2l0dWRlLCBsYXRpdHVkZV0pO1xuICAgIC8vIEEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MjA2MTgwXG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2dlbycsICdmaXgnLCBsb25naXR1ZGUucmVwbGFjZSgnLicsICcsJyksIGxhdGl0dWRlLnJlcGxhY2UoJy4nLCAnLCcpXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2hlbGwoWydhbScsICdzdGFydHNlcnZpY2UnLCAnLWUnLCAnbG9uZ2l0dWRlJywgbG9uZ2l0dWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLWUnLCAnbGF0aXR1ZGUnLCBsYXRpdHVkZSwgTE9DQVRJT05fU0VSVklDRV0pO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlZnVsbHkgcmVjdXJzaXZlbHkgcmVtb3ZlIGEgcGF0aCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiBCZSBjYXJlZnVsIHdoaWxlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byBiZSByZW1vdmVkIHJlY3Vyc2l2ZWx5LlxuICovXG5tZXRob2RzLnJpbXJhZiA9IGFzeW5jIGZ1bmN0aW9uIChwYXRoKSB7XG4gIGF3YWl0IHRoaXMuc2hlbGwoWydybScsICctcmYnLCBwYXRoXSk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBmaWxlIHRvIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIC0gVGhlIHBhdGggdG8gdGhlIGZpbGUgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgZGVzdGluYXRpb24gcGF0aCBvbiB0aGUgcmVtb3RlIGRldmljZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzLFxuICogICAgICAgICAgICAgICAgICAgICAgICBfZXhlY18gbWV0aG9kIG9wdGlvbnMsIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGF2YWlsYWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLlxuICovXG5tZXRob2RzLnB1c2ggPSBhc3luYyBmdW5jdGlvbiAobG9jYWxQYXRoLCByZW1vdGVQYXRoLCBvcHRzKSB7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3B1c2gnLCBsb2NhbFBhdGgsIHJlbW90ZVBhdGhdLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUmVjZWl2ZSBhIGZpbGUgZnJvbSB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgc291cmNlIHBhdGggb24gdGhlIHJlbW90ZSBkZXZpY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxQYXRoIC0gVGhlIGRlc3RpbmF0aW9uIHBhdGggdG8gdGhlIGZpbGUgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5tZXRob2RzLnB1bGwgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCwgbG9jYWxQYXRoKSB7XG4gIC8vIHB1bGwgZm9sZGVyIGNhbiB0YWtlIG1vcmUgdGltZSwgaW5jcmVhc2luZyB0aW1lIG91dCB0byA2MCBzZWNzXG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3B1bGwnLCByZW1vdGVQYXRoLCBsb2NhbFBhdGhdLCB7dGltZW91dDogNjAwMDB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcHJvY2VzcyB3aXRoIHRoZSBwYXJ0aWN1bGFyIG5hbWUgaXMgcnVubmluZyBvbiB0aGUgZGV2aWNlXG4gKiB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9jZXNzTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9jZXNzIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwcm9jZXNzIGlzIHJ1bm5pbmcuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgdGhlIGdpdmVuIHByb2Nlc3MgbmFtZSBpcyBub3QgYSB2YWxpZCBjbGFzcyBuYW1lLlxuICovXG5tZXRob2RzLnByb2Nlc3NFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiAocHJvY2Vzc05hbWUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZENsYXNzKHByb2Nlc3NOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByb2Nlc3MgbmFtZTogJHtwcm9jZXNzTmFtZX1gKTtcbiAgICB9XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoXCJwc1wiKTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dC5zcGxpdCgvXFxyP1xcbi8pKSB7XG4gICAgICBsaW5lID0gbGluZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgIGxldCBwa2dDb2x1bW4gPSBsaW5lW2xpbmUubGVuZ3RoIC0gMV07XG4gICAgICBpZiAocGtnQ29sdW1uICYmIHBrZ0NvbHVtbi5pbmRleE9mKHByb2Nlc3NOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmluZGluZyBpZiBwcm9jZXNzIGV4aXN0cy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBUQ1AgcG9ydCBmb3J3YXJkaW5nIHdpdGggYWRiIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgb3V0cHV0IG9mIHRoZSBjb3JyZXNwb25kaW5nIGFkYiBjb21tYW5kLiBBbiBhcnJheSBjb250YWlucyBlYWNoIGZvcndhcmRpbmcgbGluZSBvZiBvdXRwdXRcbiAqL1xubWV0aG9kcy5nZXRGb3J3YXJkTGlzdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKGBMaXN0IGZvcndhcmRpbmcgcG9ydHNgKTtcbiAgbGV0IGNvbm5lY3Rpb25zID0gYXdhaXQgdGhpcy5hZGJFeGVjKFsnZm9yd2FyZCcsICctLWxpc3QnXSk7XG4gIHJldHVybiBjb25uZWN0aW9ucy5zcGxpdCgnXFxuJyk7XG59O1xuXG4vKipcbiAqIFNldHVwIFRDUCBwb3J0IGZvcndhcmRpbmcgd2l0aCBhZGIgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3lzdGVtUG9ydCAtIFRoZSBudW1iZXIgb2YgdGhlIGxvY2FsIHN5c3RlbSBwb3J0LlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZXZpY2VQb3J0IC0gVGhlIG51bWJlciBvZiB0aGUgcmVtb3RlIGRldmljZSBwb3J0LlxuICovXG5tZXRob2RzLmZvcndhcmRQb3J0ID0gYXN5bmMgZnVuY3Rpb24gKHN5c3RlbVBvcnQsIGRldmljZVBvcnQpIHtcbiAgbG9nLmRlYnVnKGBGb3J3YXJkaW5nIHN5c3RlbTogJHtzeXN0ZW1Qb3J0fSB0byBkZXZpY2U6ICR7ZGV2aWNlUG9ydH1gKTtcbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZm9yd2FyZCcsIGB0Y3A6JHtzeXN0ZW1Qb3J0fWAsIGB0Y3A6JHtkZXZpY2VQb3J0fWBdKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIFRDUCBwb3J0IGZvcndhcmRpbmcgd2l0aCBhZGIgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LiBUaGUgZm9yd2FyZGluZ1xuICogZm9yIHRoZSBnaXZlbiBwb3J0IHNob3VsZCBiZSBzZXR1cCB3aXRoIHtAbGluayAjZm9yd2FyZFBvcnR9IGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3lzdGVtUG9ydCAtIFRoZSBudW1iZXIgb2YgdGhlIGxvY2FsIHN5c3RlbSBwb3J0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byByZW1vdmUgZm9yd2FyZGluZyBvbi5cbiAqL1xubWV0aG9kcy5yZW1vdmVQb3J0Rm9yd2FyZCA9IGFzeW5jIGZ1bmN0aW9uIChzeXN0ZW1Qb3J0KSB7XG4gIGxvZy5kZWJ1ZyhgUmVtb3ZpbmcgZm9yd2FyZGVkIHBvcnQgc29ja2V0IGNvbm5lY3Rpb246ICR7c3lzdGVtUG9ydH0gYCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2ZvcndhcmQnLCBgLS1yZW1vdmVgLCBgdGNwOiR7c3lzdGVtUG9ydH1gXSk7XG59O1xuXG4vKipcbiAqIFNldHVwIFRDUCBwb3J0IGZvcndhcmRpbmcgd2l0aCBhZGIgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LiBUaGUgZGlmZmVyZW5jZVxuICogYmV0d2VlbiB7QGxpbmsgI2ZvcndhcmRQb3J0fSBpcyB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgc2V0dXAgZm9yIGFuIGFic3RyYWN0XG4gKiBsb2NhbCBwb3J0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3lzdGVtUG9ydCAtIFRoZSBudW1iZXIgb2YgdGhlIGxvY2FsIHN5c3RlbSBwb3J0LlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZXZpY2VQb3J0IC0gVGhlIG51bWJlciBvZiB0aGUgcmVtb3RlIGRldmljZSBwb3J0LlxuICovXG5tZXRob2RzLmZvcndhcmRBYnN0cmFjdFBvcnQgPSBhc3luYyBmdW5jdGlvbiAoc3lzdGVtUG9ydCwgZGV2aWNlUG9ydCkge1xuICBsb2cuZGVidWcoYEZvcndhcmRpbmcgc3lzdGVtOiAke3N5c3RlbVBvcnR9IHRvIGFic3RyYWN0IGRldmljZTogJHtkZXZpY2VQb3J0fWApO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydmb3J3YXJkJywgYHRjcDoke3N5c3RlbVBvcnR9YCwgYGxvY2FsYWJzdHJhY3Q6JHtkZXZpY2VQb3J0fWBdKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBwaW5nIHNoZWxsIGNvbW1hbmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbW1hbmQgb3V0cHV0IGNvbnRhaW5zICdwaW5nJyBzdWJzdHJpbmcuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGV4ZWN1dGluZyAncGluZycgY29tbWFuZCBvbiB0aGVcbiAqICAgICAgICAgICAgICAgICBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xubWV0aG9kcy5waW5nID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbXCJlY2hvXCIsIFwicGluZ1wiXSk7XG4gIGlmIChzdGRvdXQuaW5kZXhPZihcInBpbmdcIikgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYEFEQiBwaW5nIGZhaWxlZCwgcmV0dXJuZWQgJHtzdGRvdXR9YCk7XG59O1xuXG4vKipcbiAqIFJlc3RhcnQgdGhlIGRldmljZSB1bmRlciB0ZXN0IHVzaW5nIGFkYiBjb21tYW5kcy5cbiAqXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgc3RhcnQgZmFpbHMuXG4gKi9cbm1ldGhvZHMucmVzdGFydCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLnN0b3BMb2djYXQoKTtcbiAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JEZXZpY2UoNjApO1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMb2djYXQoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgUmVzdGFydCBmYWlsZWQuIE9yZ2luaWFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCB0aGUgbG9nY2F0IHByb2Nlc3MgdG8gZ2F0aGVyIGxvZ3MuXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IElmIHJlc3RhcnQgZmFpbHMuXG4gKi9cbm1ldGhvZHMuc3RhcnRMb2djYXQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICghXy5pc0VtcHR5KHRoaXMubG9nY2F0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBzdGFydCBsb2djYXQgY2FwdHVyZSBidXQgaXQncyBhbHJlYWR5IHN0YXJ0ZWQhXCIpO1xuICB9XG4gIHRoaXMubG9nY2F0ID0gbmV3IExvZ2NhdCh7XG4gICAgYWRiOiB0aGlzLmV4ZWN1dGFibGUsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGRlYnVnVHJhY2U6IGZhbHNlLFxuICAgIGNsZWFyRGV2aWNlTG9nc09uU3RhcnQ6ICEhdGhpcy5jbGVhckRldmljZUxvZ3NPblN0YXJ0LFxuICB9KTtcbiAgYXdhaXQgdGhpcy5sb2djYXQuc3RhcnRDYXB0dXJlKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgdGhlIGFjdGl2ZSBsb2djYXQgcHJvY2VzcyB3aGljaCBnYXRoZXJzIGxvZ3MuXG4gKiBUaGUgY2FsbCB3aWxsIGJlIGlnbm9yZWQgaWYgbm8gbG9nY2F0IHByb2Nlc3MgaXMgcnVubmluZy5cbiAqL1xubWV0aG9kcy5zdG9wTG9nY2F0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAoXy5pc0VtcHR5KHRoaXMubG9nY2F0KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMubG9nY2F0LnN0b3BDYXB0dXJlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5sb2djYXQgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBvdXRwdXQgZnJvbSB0aGUgY3VycmVudGx5IHJ1bm5pbmcgbG9nY2F0IHByb2Nlc3MuXG4gKiBUaGUgbG9nY2F0IHByb2Nlc3Mgc2hvdWxkIGJlIGV4ZWN1dGVkIGJ5IHsybGluayAjc3RhcnRMb2djYXR9IG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb2xsZWN0ZWQgbG9nY2F0IG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb2djYXQgcHJvY2VzcyBpcyBub3QgcnVubmluZy5cbiAqL1xubWV0aG9kcy5nZXRMb2djYXRMb2dzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoXy5pc0VtcHR5KHRoaXMubG9nY2F0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBsb2djYXQgbG9ncyBzaW5jZSBsb2djYXQgaGFzbid0IHN0YXJ0ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMubG9nY2F0LmdldExvZ3MoKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGxvZ2NhdCBvdXRwdXQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgb25lIGFyZ3VtZW50LiBUaGUgYXJndW1lbnQgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBsb2cgcmVjb3JkIG9iamVjdCB3aXRoIGB0aW1lc3RhbXBgLCBgbGV2ZWxgIGFuZCBgbWVzc2FnZWAgcHJvcGVydGllcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb2djYXQgcHJvY2VzcyBpcyBub3QgcnVubmluZy5cbiAqL1xubWV0aG9kcy5zZXRMb2djYXRMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICBpZiAoXy5pc0VtcHR5KHRoaXMubG9nY2F0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2NhdCBwcm9jZXNzIGhhc24ndCBiZWVuIHN0YXJ0ZWRcIik7XG4gIH1cbiAgdGhpcy5sb2djYXQub24oJ291dHB1dCcsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgcHJldmlvdXNseSBzZXQgY2FsbGJhY2sgZm9yIHRoZSBsb2djYXQgb3V0cHV0IGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLCB3aGljaCBoYXMgYmVlbiBwcmV2aW91c2x5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZCB0byBgc2V0TG9nY2F0TGlzdGVuZXJgXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbG9nY2F0IHByb2Nlc3MgaXMgbm90IHJ1bm5pbmcuXG4gKi9cbm1ldGhvZHMucmVtb3ZlTG9nY2F0TGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgaWYgKF8uaXNFbXB0eSh0aGlzLmxvZ2NhdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2djYXQgcHJvY2VzcyBoYXNuJ3QgYmVlbiBzdGFydGVkXCIpO1xuICB9XG4gIHRoaXMubG9nY2F0LnJlbW92ZUxpc3RlbmVyKCdvdXRwdXQnLCBsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBwcm9jZXNzIGlkcyBmb3IgdGhlIHBhcnRpY3VsYXIgcHJvY2VzcyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFydCBvZiBwcm9jZXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGxpc3Qgb2YgbWF0Y2hlZCBwcm9jZXNzIElEcyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmdldFBJRHNCeU5hbWUgPSBhc3luYyBmdW5jdGlvbiAobmFtZSkge1xuICBsb2cuZGVidWcoYEdldHRpbmcgYWxsIHByb2Nlc3NlcyB3aXRoICR7bmFtZX1gKTtcbiAgdHJ5IHtcbiAgICAvLyBwcyA8Y29tbT4gd2hlcmUgY29tbSBpcyBsYXN0IDE1IGNoYXJhY3RlcnMgb2YgcGFja2FnZSBuYW1lXG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMTUpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihuYW1lLmxlbmd0aCAtIDE1KTtcbiAgICB9XG4gICAgbGV0IHN0ZG91dCA9IChhd2FpdCB0aGlzLnNoZWxsKFtcInBzXCJdKSkudHJpbSgpO1xuICAgIGxldCBwaWRzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGlmIChsaW5lLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IC9bXlxcdCBdK1tcXHQgXSsoWzAtOV0rKS8uZXhlYyhsaW5lKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcGlkcy5wdXNoKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGV4dHJhY3QgUElEIGZyb20gcHMgb3V0cHV0OiAke2xpbmV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpZHM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBnZXQgcGlkcyBmb3IgJHtuYW1lfS4gT3JnaW5pYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBwcm9jZXNzIGlkcyBmb3IgdGhlIHBhcnRpY3VsYXIgcHJvY2VzcyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFydCBvZiBwcm9jZXNzIG5hbWUuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVGhlIGxpc3Qgb2YgbWF0Y2hlZCBwcm9jZXNzIElEcyBvciBhbiBlbXB0eSBsaXN0LlxuICovXG5tZXRob2RzLmtpbGxQcm9jZXNzZXNCeU5hbWUgPSBhc3luYyBmdW5jdGlvbiAobmFtZSkge1xuICB0cnkge1xuICAgIGxvZy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byBraWxsIGFsbCAke25hbWV9IHByb2Nlc3Nlc2ApO1xuICAgIGxldCBwaWRzID0gYXdhaXQgdGhpcy5nZXRQSURzQnlOYW1lKG5hbWUpO1xuICAgIGlmIChwaWRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIGxvZy5pbmZvKGBObyAke25hbWV9IHByb2Nlc3MgZm91bmQgdG8ga2lsbCwgY29udGludWluZy4uLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBwaWQgb2YgcGlkcykge1xuICAgICAgYXdhaXQgdGhpcy5raWxsUHJvY2Vzc0J5UElEKHBpZCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8ga2lsbCAke25hbWV9IHByb2Nlc3Nlcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgdGhlIHBhcnRpY3VsYXIgcHJvY2VzcyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwaWQgLSBUaGUgSUQgb2YgdGhlIHByb2Nlc3MgdG8gYmUga2lsbGVkLlxuICogQHJldHVybiB7c3RyaW5nfSBLaWxsIGNvbW1hbmQgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcm9jZXNzIHdpdGggZ2l2ZW4gSUQgaXMgbm90IHByZXNlbnQgb3IgY2Fubm90IGJlIGtpbGxlZC5cbiAqL1xubWV0aG9kcy5raWxsUHJvY2Vzc0J5UElEID0gYXN5bmMgZnVuY3Rpb24gKHBpZCkge1xuICBsb2cuZGVidWcoYEF0dGVtcHRpbmcgdG8ga2lsbCBwcm9jZXNzICR7cGlkfWApO1xuICAvLyBKdXN0IHRvIGNoZWNrIGlmIHRoZSBwcm9jZXNzIGV4aXN0cyBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uIG90aGVyd2lzZVxuICBhd2FpdCB0aGlzLnNoZWxsKFsna2lsbCcsICctMCcsIHBpZF0pO1xuICBjb25zdCB0aW1lb3V0TXMgPSAxMDAwO1xuICBsZXQgc3Rkb3V0O1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbJ2tpbGwnLCBwaWRdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBraWxsIHJldHVybnMgbm9uLXplcm8gY29kZSBpZiB0aGUgcHJvY2VzcyBpcyBhbHJlYWR5IGtpbGxlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7d2FpdE1zOiB0aW1lb3V0TXMsIGludGVydmFsTXM6IDMwMH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IGtpbGwgcHJvY2VzcyAke3BpZH0gaW4gJHt0aW1lb3V0TXN9IG1zLiBUcnlpbmcgdG8gZm9yY2Uga2lsbC4uLmApO1xuICAgIHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydraWxsJywgJy05JywgcGlkXSk7XG4gIH1cbiAgcmV0dXJuIHN0ZG91dDtcbn07XG5cbi8qKlxuICogQnJvYWRjYXN0IHByb2Nlc3Mga2lsbGluZyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGludGVudCAtIFRoZSBuYW1lIG9mIHRoZSBpbnRlbnQgdG8gYnJvYWRjYXN0IHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb2Nlc3NOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGtpbGxlZCBwcm9jZXNzLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRoZSBwcm9jZXNzIHdhcyBub3Qga2lsbGVkLlxuICovXG5tZXRob2RzLmJyb2FkY2FzdFByb2Nlc3NFbmQgPSBhc3luYyBmdW5jdGlvbiAoaW50ZW50LCBwcm9jZXNzTmFtZSkge1xuICAvLyBzdGFydCB0aGUgYnJvYWRjYXN0IHdpdGhvdXQgd2FpdGluZyBmb3IgaXQgdG8gZmluaXNoLlxuICB0aGlzLmJyb2FkY2FzdChpbnRlbnQpO1xuICAvLyB3YWl0IGZvciB0aGUgcHJvY2VzcyB0byBlbmRcbiAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbGV0IHRpbWVvdXRNcyA9IDQwMDAwO1xuICB0cnkge1xuICAgIHdoaWxlICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA8IHRpbWVvdXRNcykge1xuICAgICAgaWYgKGF3YWl0IHRoaXMucHJvY2Vzc0V4aXN0cyhwcm9jZXNzTmFtZSkpIHtcbiAgICAgICAgLy8gY29vbCBkb3duXG4gICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2Nlc3MgbmV2ZXIgZGllZCB3aXRoaW4gJHt0aW1lb3V0TXN9IG1zYCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBicm9hZGNhc3QgcHJvY2VzcyBlbmQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCcm9hZGNhc3QgYSBtZXNzYWdlIHRvIHRoZSBnaXZlbiBpbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGludGVudCAtIFRoZSBuYW1lIG9mIHRoZSBpbnRlbnQgdG8gYnJvYWRjYXN0IHRvLlxuICogQHRocm93cyB7ZXJyb3J9IElmIGludGVudCBuYW1lIGlzIG5vdCBhIHZhbGlkIGNsYXNzIG5hbWUuXG4gKi9cbm1ldGhvZHMuYnJvYWRjYXN0ID0gYXN5bmMgZnVuY3Rpb24gKGludGVudCkge1xuICBpZiAoIXRoaXMuaXNWYWxpZENsYXNzKGludGVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW50ZW50ICR7aW50ZW50fWApO1xuICB9XG4gIGxvZy5kZWJ1ZyhgQnJvYWRjYXN0aW5nOiAke2ludGVudH1gKTtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ2FtJywgJ2Jyb2FkY2FzdCcsICctYScsIGludGVudF0pO1xufTtcblxuLyoqXG4gKiBLaWxsIEFuZHJvaWQgaW5zdHJ1bWVudHMgaWYgdGhleSBhcmUgY3VycmVudGx5IHJ1bm5pbmcuXG4gKi9cbm1ldGhvZHMuZW5kQW5kcm9pZENvdmVyYWdlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pbnN0cnVtZW50UHJvYyAmJiB0aGlzLmluc3RydW1lbnRQcm9jLmlzUnVubmluZykge1xuICAgIGF3YWl0IHRoaXMuaW5zdHJ1bWVudFByb2Muc3RvcCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RydW1lbnQgdGhlIHBhcnRpY3VsYXIgYWN0aXZpdHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGJlIGluc3RydW1lbnRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpdml0eSAtIFRoZSBuYW1lIG9mIHRoZSBtYWluIGFjdGl2aXR5IGluIHRoaXMgcGFja2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0cnVtZW50V2l0aCAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGluc3RydW1lbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhY3Rpdml0eSB3aXRoLlxuICogQHRocm93cyB7ZXJyb3J9IElmIGFueSBleGNlcHRpb24gaXMgcmVwb3J0ZWQgYnkgYWRiIHNoZWxsLlxuICovXG5tZXRob2RzLmluc3RydW1lbnQgPSBhc3luYyBmdW5jdGlvbiAocGtnLCBhY3Rpdml0eSwgaW5zdHJ1bWVudFdpdGgpIHtcbiAgaWYgKGFjdGl2aXR5WzBdICE9PSBcIi5cIikge1xuICAgIHBrZyA9IFwiXCI7XG4gIH1cbiAgbGV0IHBrZ0FjdGl2aXR5ID0gKHBrZyArIGFjdGl2aXR5KS5yZXBsYWNlKC9cXC4rL2csICcuJyk7IC8vIEZpeCBwa2cuLmFjdGl2aXR5IGVycm9yXG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnYW0nLCAnaW5zdHJ1bWVudCcsICctZScsICdtYWluX2FjdGl2aXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrZ0FjdGl2aXR5LCBpbnN0cnVtZW50V2l0aF0pO1xuICBpZiAoc3Rkb3V0LmluZGV4T2YoXCJFeGNlcHRpb25cIikgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGV4Y2VwdGlvbiBkdXJpbmcgaW5zdHJ1bWVudGF0aW9uLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3IgJHtzdGRvdXQuc3BsaXQoXCJcXG5cIilbMF19YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29sbGVjdCBBbmRyb2lkIGNvdmVyYWdlIGJ5IGluc3RydW1lbnRpbmcgdGhlIHBhcnRpY3VsYXIgYWN0aXZpdHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGluc3RydW1lbnRDbGFzcyAtIFRoZSBuYW1lIG9mIHRoZSBpbnN0cnVtZW50YXRpb24gY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gd2FpdFBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGJlIGluc3RydW1lbnRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3YWl0QWN0aXZpdHkgLSBUaGUgbmFtZSBvZiB0aGUgbWFpbiBhY3Rpdml0eSBpbiB0aGlzIHBhY2thZ2UuXG4gKlxuICogQHJldHVybiB7cHJvbWlzZX0gVGhlIHByb21pc2UgaXMgc3VjY2Vzc2Z1bGx5IHJlc29sdmVkIGlmIHRoZSBpbnN0cnVtZW50YXRpb24gc3RhcnRzXG4gKiAgICAgICAgICAgICAgICAgICB3aXRob3V0IGVycm9ycy5cbiAqL1xubWV0aG9kcy5hbmRyb2lkQ292ZXJhZ2UgPSBhc3luYyBmdW5jdGlvbiAoaW5zdHJ1bWVudENsYXNzLCB3YWl0UGtnLCB3YWl0QWN0aXZpdHkpIHtcbiAgaWYgKCF0aGlzLmlzVmFsaWRDbGFzcyhpbnN0cnVtZW50Q2xhc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNsYXNzICR7aW5zdHJ1bWVudENsYXNzfWApO1xuICB9XG4gIHJldHVybiBhd2FpdCBuZXcgQihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3NcbiAgICAgIC5jb25jYXQoWydzaGVsbCcsICdhbScsICdpbnN0cnVtZW50JywgJy1lJywgJ2NvdmVyYWdlJywgJ3RydWUnLCAnLXcnXSlcbiAgICAgIC5jb25jYXQoW2luc3RydW1lbnRDbGFzc10pO1xuICAgIGxvZy5kZWJ1ZyhgQ29sbGVjdGluZyBjb3ZlcmFnZSBkYXRhIHdpdGg6ICR7W3RoaXMuZXhlY3V0YWJsZS5wYXRoXS5jb25jYXQoYXJncykuam9pbignICcpfWApO1xuICAgIHRyeSB7XG4gICAgICAvLyBhbSBpbnN0cnVtZW50IHJ1bnMgZm9yIHRoZSBsaWZlIG9mIHRoZSBhcHAgcHJvY2Vzcy5cbiAgICAgIHRoaXMuaW5zdHJ1bWVudFByb2MgPSBuZXcgU3ViUHJvY2Vzcyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncyk7XG4gICAgICBhd2FpdCB0aGlzLmluc3RydW1lbnRQcm9jLnN0YXJ0KDApO1xuICAgICAgdGhpcy5pbnN0cnVtZW50UHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gcnVuIGluc3RydW1lbnRhdGlvbi4gT3JpZ2luYWwgZXJyb3I6ICR7c3RkZXJyfWApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JBY3Rpdml0eSh3YWl0UGtnLCB3YWl0QWN0aXZpdHkpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYEFuZHJvaWQgY292ZXJhZ2UgZmFpbGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcGFydGljdWxhciBwcm9wZXJ0eSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBUaGlzIG5hbWUgc2hvdWxkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBrbm93biB0byBfYWRiIHNoZWxsIGdldHByb3BfIHRvb2wuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICovXG5tZXRob2RzLmdldERldmljZVByb3BlcnR5ID0gYXN5bmMgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZ2V0cHJvcCcsIHByb3BlcnR5XSk7XG4gIGxldCB2YWwgPSBzdGRvdXQudHJpbSgpO1xuICBsb2cuZGVidWcoYEN1cnJlbnQgZGV2aWNlIHByb3BlcnR5ICcke3Byb3BlcnR5fSc6ICR7dmFsfWApO1xuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHBhcnRpY3VsYXIgcHJvcGVydHkgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gVGhpcyBuYW1lIHNob3VsZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUga25vd24gdG8gX2FkYiBzaGVsbCBzZXRwcm9wXyB0b29sLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIFRoZSBuZXcgcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IElmIF9zZXRwcm9wXyB1dGlsaXR5IGZhaWxzIHRvIGNoYW5nZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xubWV0aG9kcy5zZXREZXZpY2VQcm9wZXJ0eSA9IGFzeW5jIGZ1bmN0aW9uIChwcm9wLCB2YWwpIHtcbiAgbGV0IGFwaUxldmVsID0gYXdhaXQgdGhpcy5nZXRBcGlMZXZlbCgpO1xuICBpZiAoYXBpTGV2ZWwgPj0gMjYpIHtcbiAgICBsb2cuZGVidWcoYFJ1bm5pbmcgYWRiIHJvb3QsIEFuZHJvaWQgTyBuZWVkcyBhZGIgdG8gYmUgcm9vdGVkIHRvIHNldERldmljZVByb3BlcnR5YCk7XG4gICAgYXdhaXQgdGhpcy5yb290KCk7XG4gIH1cbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBwcm9wZXJ0eSAnJHtwcm9wfScgdG8gJyR7dmFsfSdgKTtcbiAgbGV0IGVycjtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc2V0cHJvcCcsIHByb3AsIHZhbF0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZTtcbiAgfVxuICBpZiAoYXBpTGV2ZWwgPj0gMjYpIHtcbiAgICBsb2cuZGVidWcoYFJlbW92aW5nIGFkYiByb290IGZvciBzZXREZXZpY2VQcm9wZXJ0eWApO1xuICAgIGF3YWl0IHRoaXMudW5yb290KCk7XG4gIH1cbiAgaWYgKGVycikgdGhyb3cgZXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBzeXN0ZW0gbGFuZ3VhZ2Ugb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5tZXRob2RzLmdldERldmljZVN5c0xhbmd1YWdlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9wZXJ0eShcInBlcnNpc3Quc3lzLmxhbmd1YWdlXCIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG5ldyBzeXN0ZW0gbGFuZ3VhZ2Ugb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSAtIFRoZSBuZXcgbGFuZ3VhZ2UgdmFsdWUuXG4gKi9cbm1ldGhvZHMuc2V0RGV2aWNlU3lzTGFuZ3VhZ2UgPSBhc3luYyBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoXCJwZXJzaXN0LnN5cy5sYW5ndWFnZVwiLCBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IGNvdW50cnkgbmFtZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0RGV2aWNlU3lzQ291bnRyeSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoXCJwZXJzaXN0LnN5cy5jb3VudHJ5XCIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG5ldyBzeXN0ZW0gY291bnRyeSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvdW50cnkgLSBUaGUgbmV3IGNvdW50cnkgdmFsdWUuXG4gKi9cbm1ldGhvZHMuc2V0RGV2aWNlU3lzQ291bnRyeSA9IGFzeW5jIGZ1bmN0aW9uIChjb3VudHJ5KSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLnNldERldmljZVByb3BlcnR5KFwicGVyc2lzdC5zeXMuY291bnRyeVwiLCBjb3VudHJ5LnRvVXBwZXJDYXNlKCkpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgc3lzdGVtIGxvY2FsZSBuYW1lIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xubWV0aG9kcy5nZXREZXZpY2VTeXNMb2NhbGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicGVyc2lzdC5zeXMubG9jYWxlXCIpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG5ldyBzeXN0ZW0gbG9jYWxlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlIC0gVGhlIG5ldyBsb2NhbGUgdmFsdWUuXG4gKi9cbm1ldGhvZHMuc2V0RGV2aWNlU3lzTG9jYWxlID0gYXN5bmMgZnVuY3Rpb24gKGxvY2FsZSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5zZXREZXZpY2VQcm9wZXJ0eShcInBlcnNpc3Quc3lzLmxvY2FsZVwiLCBsb2NhbGUpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgcHJvZHVjdCBsYW5ndWFnZSBuYW1lIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xubWV0aG9kcy5nZXREZXZpY2VQcm9kdWN0TGFuZ3VhZ2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicm8ucHJvZHVjdC5sb2NhbGUubGFuZ3VhZ2VcIik7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gQ3VycmVudCBwcm9kdWN0IGNvdW50cnkgbmFtZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0RGV2aWNlUHJvZHVjdENvdW50cnkgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicm8ucHJvZHVjdC5sb2NhbGUucmVnaW9uXCIpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgcHJvZHVjdCBsb2NhbGUgbmFtZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0RGV2aWNlUHJvZHVjdExvY2FsZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoXCJyby5wcm9kdWN0LmxvY2FsZVwiKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbW9kZWwgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbm1ldGhvZHMuZ2V0TW9kZWwgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KFwicm8ucHJvZHVjdC5tb2RlbFwiKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWFudWZhY3R1cmVyIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5tZXRob2RzLmdldE1hbnVmYWN0dXJlciA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoXCJyby5wcm9kdWN0Lm1hbnVmYWN0dXJlclwiKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHNjcmVlbiBzaXplLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRGV2aWNlIHNjcmVlbiBzaXplIGFzIHN0cmluZyBpbiBmb3JtYXQgJ1d4SCcgb3JcbiAqICAgICAgICAgICAgICAgICAgX251bGxfIGlmIGl0IGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICovXG5tZXRob2RzLmdldFNjcmVlblNpemUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnd20nLCAnc2l6ZSddKTtcbiAgbGV0IHNpemUgPSBuZXcgUmVnRXhwKC9QaHlzaWNhbCBzaXplOiAoW15cXHI/XFxuXSspKi9nKS5leGVjKHN0ZG91dCk7XG4gIGlmIChzaXplICYmIHNpemUubGVuZ3RoID49IDIpIHtcbiAgICByZXR1cm4gc2l6ZVsxXS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzY3JlZW4gZGVuc2l0eSBpbiBkcGlcbiAqXG4gKiBAcmV0dXJuIHs/bnVtYmVyfSBEZXZpY2Ugc2NyZWVuIGRlbnNpdHkgYXMgYSBudW1iZXIgb3IgX251bGxfIGlmIGl0XG4gKiAgICAgICAgICAgICAgICAgIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gKi9cbm1ldGhvZHMuZ2V0U2NyZWVuRGVuc2l0eSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWyd3bScsICdkZW5zaXR5J10pO1xuICBsZXQgZGVuc2l0eSA9IG5ldyBSZWdFeHAoL1BoeXNpY2FsIGRlbnNpdHk6IChbXlxccj9cXG5dKykqL2cpLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKGRlbnNpdHkgJiYgZGVuc2l0eS5sZW5ndGggPj0gMikge1xuICAgIGxldCBkZW5zaXR5TnVtYmVyID0gcGFyc2VJbnQoZGVuc2l0eVsxXS50cmltKCksIDEwKTtcbiAgICByZXR1cm4gaXNOYU4oZGVuc2l0eU51bWJlcikgPyBudWxsIDogZGVuc2l0eU51bWJlcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU2V0dXAgSFRUUCBwcm94eSBpbiBkZXZpY2Ugc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3h5SG9zdCAtIFRoZSBob3N0IG5hbWUgb2YgdGhlIHByb3h5LlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwcm94eVBvcnQgLSBUaGUgcG9ydCBudW1iZXIgdG8gYmUgc2V0LlxuICovXG5tZXRob2RzLnNldEh0dHBQcm94eSA9IGFzeW5jIGZ1bmN0aW9uIChwcm94eUhvc3QsIHByb3h5UG9ydCkge1xuICBsZXQgcHJveHkgPSBgJHtwcm94eUhvc3R9OiR7cHJveHlQb3J0fWA7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHByb3h5SG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgdG8gc2V0SHR0cFByb3h5IG1ldGhvZCB3aXRoIHVuZGVmaW5lZCBwcm94eV9ob3N0OiAke3Byb3h5fWApO1xuICB9XG4gIGlmIChfLmlzVW5kZWZpbmVkKHByb3h5UG9ydCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgdG8gc2V0SHR0cFByb3h5IG1ldGhvZCB3aXRoIHVuZGVmaW5lZCBwcm94eV9wb3J0ICR7cHJveHl9YCk7XG4gIH1cbiAgYXdhaXQgdGhpcy5zZXRTZXR0aW5nKCdnbG9iYWwnLCAnaHR0cF9wcm94eScsIHByb3h5KTtcbiAgYXdhaXQgdGhpcy5zZXRTZXR0aW5nKCdzZWN1cmUnLCAnaHR0cF9wcm94eScsIHByb3h5KTtcbiAgYXdhaXQgdGhpcy5zZXRTZXR0aW5nKCdzeXN0ZW0nLCAnaHR0cF9wcm94eScsIHByb3h5KTtcbiAgYXdhaXQgdGhpcy5zZXRTZXR0aW5nKCdzeXN0ZW0nLCAnZ2xvYmFsX2h0dHBfcHJveHlfaG9zdCcsIHByb3h5SG9zdCk7XG4gIGF3YWl0IHRoaXMuc2V0U2V0dGluZygnc3lzdGVtJywgJ2dsb2JhbF9odHRwX3Byb3h5X3BvcnQnLCBwcm94eVBvcnQpO1xufTtcblxuLyoqXG4gKiBTZXQgZGV2aWNlIHByb3BlcnR5LlxuICogW2FuZHJvaWQucHJvdmlkZXIuU2V0dGluZ3Nde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL3Byb3ZpZGVyL1NldHRpbmdzLmh0bWx9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSAtIG9uZSBvZiB7c3lzdGVtLCBzZWN1cmUsIGdsb2JhbH0sIGNhc2UtaW5zZW5zaXRpdmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2V0dGluZyAtIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIC0gcHJvcGVydHkgdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNvbW1hbmQgb3V0cHV0LlxuICovXG5tZXRob2RzLnNldFNldHRpbmcgPSBhc3luYyBmdW5jdGlvbiAobmFtZXNwYWNlLCBzZXR0aW5nLCB2YWx1ZSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5zaGVsbChbJ3NldHRpbmdzJywgJ3B1dCcsIG5hbWVzcGFjZSwgc2V0dGluZywgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogR2V0IGRldmljZSBwcm9wZXJ0eS5cbiAqIFthbmRyb2lkLnByb3ZpZGVyLlNldHRpbmdzXXtAbGluayBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC9wcm92aWRlci9TZXR0aW5ncy5odG1sfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgLSBvbmUgb2Yge3N5c3RlbSwgc2VjdXJlLCBnbG9iYWx9LCBjYXNlLWluc2Vuc2l0aXZlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNldHRpbmcgLSBwcm9wZXJ0eSBuYW1lLlxuICogQHJldHVybiB7c3RyaW5nfSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xubWV0aG9kcy5nZXRTZXR0aW5nID0gYXN5bmMgZnVuY3Rpb24gKG5hbWVzcGFjZSwgc2V0dGluZykge1xuICByZXR1cm4gYXdhaXQgdGhpcy5zaGVsbChbJ3NldHRpbmdzJywgJ2dldCcsIG5hbWVzcGFjZSwgc2V0dGluZ10pO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYGFkYiBidWdyZXBvcnRgIGNvbW1hbmQgb3V0cHV0LiBUaGlzXG4gKiBvcGVyYXRpb24gbWF5IHRha2UgdXAgdG8gc2V2ZXJhbCBtaW51dGVzLlxuICpcbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbMTIwMDAwXSAtIENvbW1hbmQgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbW1hbmQgc3Rkb3V0XG4gKi9cbm1ldGhvZHMuYnVncmVwb3J0ID0gYXN5bmMgZnVuY3Rpb24gKHRpbWVvdXQgPSAxMjAwMDApIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2J1Z3JlcG9ydCddLCB7dGltZW91dH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
