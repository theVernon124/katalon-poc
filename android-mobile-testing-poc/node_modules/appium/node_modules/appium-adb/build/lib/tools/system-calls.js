'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _helpers = require('../helpers');

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _shellQuote = require('shell-quote');

var systemCallMethods = {};

var DEFAULT_ADB_EXEC_TIMEOUT = 20000; // in milliseconds
var DEFAULT_ADB_REBOOT_RETRIES = 90;

/**
 * Retrieve full path to the given binary.
 *
 * @param {string} binaryName - The name of the binary.
 * @return {string} Full path to the given binary including current SDK root.
 */
systemCallMethods.getSdkBinaryPath = _lodash2['default'].memoize(function callee$0$0(binaryName) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info('Checking whether ' + binaryName + ' is present');

        if (!this.sdkRoot) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getBinaryFromSdkRoot(binaryName));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
        _loggerJs2['default'].warn('The ANDROID_HOME environment variable is not set to the Android SDK ' + 'root directory path. ANDROID_HOME is required for compatibility ' + ('with SDK 23+. Checking along PATH for ' + binaryName + '.'));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getBinaryFromPath(binaryName));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
});

/**
 * Retrieve the name of the tool,
 * which prints full path to the given command shortcut.
 *
 * @return {string} Depending on the current platform this is
 *                  supposed to be either 'which' or 'where'.
 */
systemCallMethods.getCommandForOS = _lodash2['default'].memoize(function () {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});

/**
 * Retrieve full binary name for the current operating system.
 *
 * @param {string} binaryName - simple binary name, for example 'android'.
 * @return {string} Formatted binary name depending on the current platform,
 *                  for example, 'android.bat' on Windows.
 */
systemCallMethods.getBinaryNameForOS = _lodash2['default'].memoize(function (binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return binaryName + '.bat';
  }
  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return binaryName + '.exe';
  }
  return binaryName;
});

/**
 * Retrieve full path to the given binary.
 *
 * @param {string} binaryName - Simple name of a binary file.
 * @return {string} Full path to the given binary. The method tries
 *                  to enumerate all the known locations where the binary
 *                  might be located and stops the search as soon as the first
 *                  match is found on the local file system.
 * @throws {Error} If the binary with given name is not present at any
 *                 of known locations or Android SDK is not installed on the
 *                 local file system.
 */
systemCallMethods.getBinaryFromSdkRoot = _lodash2['default'].memoize(function callee$0$0(binaryName) {
  var binaryLoc, binaryLocs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, loc;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;

        binaryName = this.getBinaryNameForOS(binaryName);
        binaryLocs = [_path2['default'].resolve(this.sdkRoot, "platform-tools", binaryName), _path2['default'].resolve(this.sdkRoot, "emulator", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", "bin", binaryName)];
        context$1$0.t0 = _lodash2['default'];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _helpers.getBuildToolsDirs)(this.sdkRoot));

      case 6:
        context$1$0.t1 = context$1$0.sent;

        context$1$0.t2 = function (dir) {
          return binaryLocs.push(_path2['default'].resolve(dir, binaryName));
        };

        context$1$0.t0.forEach.call(context$1$0.t0, context$1$0.t1, context$1$0.t2);
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 12;
        _iterator = _getIterator(binaryLocs);

      case 14:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 24;
          break;
        }

        loc = _step.value;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(loc));

      case 18:
        if (!context$1$0.sent) {
          context$1$0.next = 21;
          break;
        }

        binaryLoc = loc;
        return context$1$0.abrupt('break', 24);

      case 21:
        _iteratorNormalCompletion = true;
        context$1$0.next = 14;
        break;

      case 24:
        context$1$0.next = 30;
        break;

      case 26:
        context$1$0.prev = 26;
        context$1$0.t3 = context$1$0['catch'](12);
        _didIteratorError = true;
        _iteratorError = context$1$0.t3;

      case 30:
        context$1$0.prev = 30;
        context$1$0.prev = 31;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 33:
        context$1$0.prev = 33;

        if (!_didIteratorError) {
          context$1$0.next = 36;
          break;
        }

        throw _iteratorError;

      case 36:
        return context$1$0.finish(33);

      case 37:
        return context$1$0.finish(30);

      case 38:
        if (!_lodash2['default'].isNull(binaryLoc)) {
          context$1$0.next = 40;
          break;
        }

        throw new Error('Could not find ' + binaryName + ' in ' + binaryLocs + '. ' + ('Do you have the Android SDK installed at \'' + this.sdkRoot + '\'?'));

      case 40:
        binaryLoc = binaryLoc.trim();
        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + binaryLoc);
        return context$1$0.abrupt('return', binaryLoc);

      case 43:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[12, 26, 30, 38], [31,, 33, 37]]);
});

/**
 * Retrieve full path to a binary file using the standard system lookup tool.
 *
 * @param {string} binaryName - The name of the binary.
 * @return {string} Full path to the binary received from 'which'/'where'
 *                  output.
 * @throws {Error} If lookup tool returns non-zero return code.
 */
systemCallMethods.getBinaryFromPath = function callee$0$0(binaryName) {
  var binaryLoc, cmd, _ref, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;
        cmd = this.getCommandForOS();
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, [binaryName]));

      case 5:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + stdout);
        // TODO write a test for binaries with spaces.
        binaryLoc = stdout.trim();
        return context$1$0.abrupt('return', binaryLoc);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](2);
        throw new Error('Could not find ' + binaryName + ' Please set the ANDROID_HOME ' + 'environment variable with the Android SDK root directory path.');

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 12]]);
};

/**
 * @typedef {Object} Device
 * @property {string} udid - The device udid.
 * @property {string} state - Current device state, as it is visible in
 *                            _adb devices -l_ output.
 */

/**
 * Retrieve the list of devices visible to adb.
 *
 * @return {Array.<Device>} The list of devices or an empty list if
 *                          no devices are connected.
 * @throws {Error} If there was an error while listing devices.
 */
systemCallMethods.getConnectedDevices = function callee$0$0() {
  var _ref2, stdout, startingIndex, devices, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, line, lineInfo;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting connected devices...");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices'])));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        startingIndex = stdout.indexOf("List of devices");

        if (!(startingIndex === -1)) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unexpected output while trying to get devices. output was: ' + stdout);

      case 9:
        // slicing ouput we care about.
        stdout = stdout.slice(startingIndex);
        devices = [];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 14;

        for (_iterator2 = _getIterator(stdout.split("\n")); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          line = _step2.value;

          if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
            lineInfo = line.split("\t");

            // state is either "device" or "offline", afaict
            devices.push({ udid: lineInfo[0], state: lineInfo[1] });
          }
        }
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](14);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError2) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError2;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
        _loggerJs2['default'].debug(devices.length + ' device(s) connected');
        return context$1$0.abrupt('return', devices);

      case 34:
        context$1$0.prev = 34;
        context$1$0.t1 = context$1$0['catch'](1);
        throw new Error('Error while getting connected devices. Original error: ' + context$1$0.t1.message);

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 34], [14, 18, 22, 30], [23,, 25, 29]]);
};

/**
 * Retrieve the list of devices visible to adb within the given timeout.
 *
 * @param {number} timeoutMs - The maximum number of milliseconds to get at least
 *                             one list item.
 * @return {Array.<Device>} The list of connected devices.
 * @throws {Error} If no connected devices can be detected within the given timeout.
 */
systemCallMethods.getDevicesWithRetry = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, getDevices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Trying to find a connected android device");

        getDevices = function getDevices() {
          var devices;
          return _regeneratorRuntime.async(function getDevices$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                if (!(Date.now() - start > timeoutMs)) {
                  context$2$0.next = 2;
                  break;
                }

                throw new Error("Could not find a connected Android device.");

              case 2:
                context$2$0.prev = 2;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 5:
                devices = context$2$0.sent;

                if (!(devices.length < 1)) {
                  context$2$0.next = 15;
                  break;
                }

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 12:
                context$2$0.next = 14;
                return _regeneratorRuntime.awrap(getDevices());

              case 14:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 15:
                return context$2$0.abrupt('return', devices);

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](2);

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 23:
                context$2$0.next = 25;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 25:
                context$2$0.next = 27;
                return _regeneratorRuntime.awrap(getDevices());

              case 27:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[2, 18]]);
        };

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(getDevices());

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Restart adb server if _this.suppressKillServer_ property is true.
 */
systemCallMethods.restartAdb = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.suppressKillServer) {
          context$1$0.next = 3;
          break;
        }

        _loggerJs2['default'].debug('Not restarting abd since \'suppressKillServer\' is on');
        return context$1$0.abrupt('return');

      case 3:

        _loggerJs2['default'].debug('Restarting adb');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.killServer());

      case 7:
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](4);

        _loggerJs2['default'].error("Error killing ADB server, going to see if it's online anyway");

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 9]]);
};

/**
 * Kill adb server.
 */
systemCallMethods.killServer = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Killing adb server on port ' + this.adbPort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, [].concat(_toConsumableArray(this.executable.defaultArgs), ['kill-server'])));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Reset Telnet authentication token.
 * @see {@link http://tools.android.com/recent/emulator2516releasenotes} for more details.
 *
 * @returns {boolean} If token reset was successful.
 */
systemCallMethods.resetTelnetAuthToken = _lodash2['default'].memoize(function callee$0$0() {
  var homeFolderPath, dstPath;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

        if (homeFolderPath) {
          context$1$0.next = 4;
          break;
        }

        _loggerJs2['default'].warn('Cannot find the path to user home folder. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 4:
        dstPath = _path2['default'].resolve(homeFolderPath, '.emulator_console_auth_token');

        _loggerJs2['default'].debug('Overriding ' + dstPath + ' with an empty string to avoid telnet authentication for emulator commands');
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstPath, ''));

      case 9:
        context$1$0.next = 15;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Error ' + context$1$0.t0.message + ' while resetting the content of ' + dstPath + '. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 15:
        return context$1$0.abrupt('return', true);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 11]]);
});

/**
 * Execute the given emulator command using _adb emu_ tool.
 *
 * @param {Array.<string>} cmd - The array of rest command line parameters.
 */
systemCallMethods.adbExecEmu = function callee$0$0(cmd) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.verifyEmulatorConnected());

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.resetTelnetAuthToken());

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.adbExec(['emu'].concat(_toConsumableArray(cmd))));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute the given adb command.
 *
 * @param {Array.<string>} cmd - The array of rest command line parameters
 *                      or a single string parameter.
 * @param {Object} opts - Additional options mapping. See
 *                        {@link https://github.com/appium/node-teen_process}
 *                        for more details.
 * @return {string} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.adbExec = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (cmd) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("You need to pass in a command to adbExec()");

      case 2:
        // setting default timeout for each command to prevent infinite wait.
        opts.timeout = opts.timeout || this.execTimeout || DEFAULT_ADB_EXEC_TIMEOUT;

        execFunc = function execFunc() {
          var linkerWarningRe, args, _ref3, stdout, protocolFaultError, deviceNotFoundError;

          return _regeneratorRuntime.async(function execFunc$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                linkerWarningRe = /^WARNING: linker.+$/m;
                context$2$0.prev = 1;

                if (!(cmd instanceof Array)) {
                  cmd = [cmd];
                }
                args = this.executable.defaultArgs.concat(cmd);

                _loggerJs2['default'].debug('Running \'' + this.executable.path + ' ' + (0, _shellQuote.quote)(args) + '\'');
                context$2$0.next = 7;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, args, opts));

              case 7:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;

                // sometimes ADB prints out weird stdout warnings that we don't want
                // to include in any of the response data, so let's strip it out
                stdout = stdout.replace(linkerWarningRe, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 13:
                context$2$0.prev = 13;
                context$2$0.t0 = context$2$0['catch'](1);
                protocolFaultError = new RegExp("protocol fault \\(no status\\)", "i").test(context$2$0.t0);
                deviceNotFoundError = new RegExp("error: device ('.+' )?not found", "i").test(context$2$0.t0);

                if (!(protocolFaultError || deviceNotFoundError)) {
                  context$2$0.next = 23;
                  break;
                }

                _loggerJs2['default'].info('Error sending command, reconnecting device and retrying: ' + cmd);
                context$2$0.next = 21;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(1000));

              case 21:
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.getDevicesWithRetry());

              case 23:
                if (!(context$2$0.t0.code === 0 && context$2$0.t0.stdout)) {
                  context$2$0.next = 27;
                  break;
                }

                stdout = context$2$0.t0.stdout;

                stdout = stdout.replace(linkerWarningRe, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 27:
                throw new Error('Error executing adbExec. Original error: \'' + context$2$0.t0.message + '\'; ' + ('Stderr: \'' + (context$2$0.t0.stderr || '').trim() + '\'; Code: \'' + context$2$0.t0.code + '\''));

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2, [[1, 13]]);
        };

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(2, execFunc));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute the given command using _adb shell_ prefix.
 *
 * @param {Array.<string>|string} cmd - The array of rest command line parameters or a single
 *                                      string parameter.
 * @param {Object} opts - Additional options mapping. See
 *                        {@link https://github.com/appium/node-teen_process}
 *                        for more details.
 * @return {string} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.shell = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(_lodash2['default'].isArray(cmd) ? ['shell'].concat(_toConsumableArray(cmd)) : ['shell', cmd], opts));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.createSubProcess = function () {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  // add the default arguments
  args = this.executable.defaultArgs.concat(args);
  _loggerJs2['default'].debug('Creating ADB subprocess with args: ' + JSON.stringify(args));
  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

/**
 * Retrieve the current adb port.
 * @todo can probably deprecate this now that the logic is just to read this.adbPort
 * @return {number} The current adb port number.
 */
systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

/**
 * Retrieve the current emulator port from _adb devives_ output.
 *
 * @return {number} The current emulator port.
 * @throws {Error} If there are no connected devices.
 */
systemCallMethods.getEmulatorPort = function callee$0$0() {
  var devices, port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting running emulator port");

        if (!(this.emulatorPort !== null)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return', this.emulatorPort);

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 6:
        devices = context$1$0.sent;
        port = this.getPortFromEmulatorString(devices[0].udid);

        if (!port) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', port);

      case 12:
        throw new Error('Emulator port not found');

      case 13:
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('No devices connected. Original error: ' + context$1$0.t0.message);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 15]]);
};

/**
 * Retrieve the current emulator port by parsing emulator name string.
 *
 * @param {string} emStr - Emulator name string.
 * @return {number|boolean} Either the current emulator port or
 *                          _false_ if port number cannot be parsed.
 */
systemCallMethods.getPortFromEmulatorString = function (emStr) {
  var portPattern = /emulator-(\d+)/;
  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }
  return false;
};

/**
 * Retrieve the list of currently connected emulators.
 *
 * @return {Array.<Device>} The list of connected devices.
 */
systemCallMethods.getConnectedEmulators = function callee$0$0() {
  var devices, emulators, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, device, port;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug("Getting connected emulators");
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 4:
        devices = context$1$0.sent;
        emulators = [];
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 9;

        for (_iterator3 = _getIterator(devices); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          device = _step3.value;
          port = this.getPortFromEmulatorString(device.udid);

          if (port) {
            device.port = port;
            emulators.push(device);
          }
        }
        context$1$0.next = 17;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 17:
        context$1$0.prev = 17;
        context$1$0.prev = 18;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 20:
        context$1$0.prev = 20;

        if (!_didIteratorError3) {
          context$1$0.next = 23;
          break;
        }

        throw _iteratorError3;

      case 23:
        return context$1$0.finish(20);

      case 24:
        return context$1$0.finish(17);

      case 25:
        _loggerJs2['default'].debug(emulators.length + ' emulator(s) connected');
        return context$1$0.abrupt('return', emulators);

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting emulators. Original error: ' + context$1$0.t1.message);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 29], [9, 13, 17, 25], [18,, 20, 24]]);
};

/**
 * Set _emulatorPort_ property of the current class.
 *
 * @param {number} emPort - The emulator port to be set.
 */
systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

/**
 * Set the identifier of the current device (_this.curDeviceId_).
 *
 * @param {string} - The device identifier.
 */
systemCallMethods.setDeviceId = function (deviceId) {
  _loggerJs2['default'].debug('Setting device id to ' + deviceId);
  this.curDeviceId = deviceId;
  var argsHasDevice = this.executable.defaultArgs.indexOf('-s');
  if (argsHasDevice !== -1) {
    // remove the old device id from the arguments
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }
  this.executable.defaultArgs.push('-s', deviceId);
};

/**
 * Set the the current device object.
 *
 * @param {Device} deviceObj - The device object to be set.
 */
systemCallMethods.setDevice = function (deviceObj) {
  var deviceId = deviceObj.udid;
  var emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

/**
 * Get the object for the currently running emulator.
 *
 * @param {string} avdName - Emulator name.
 * @return {?Device} Currently running emulator or _null_.
 */
systemCallMethods.getRunningAVD = function callee$0$0(avdName) {
  var emulators, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, emulator, runningAVDName;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Trying to find ' + avdName + ' emulator');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedEmulators());

      case 4:
        emulators = context$1$0.sent;
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 8;
        _iterator4 = _getIterator(emulators);

      case 10:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 23;
          break;
        }

        emulator = _step4.value;

        this.setEmulatorPort(emulator.port);
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.sendTelnetCommand("avd name"));

      case 15:
        runningAVDName = context$1$0.sent;

        if (!(avdName === runningAVDName)) {
          context$1$0.next = 20;
          break;
        }

        _loggerJs2['default'].debug('Found emulator ' + avdName + ' in port ' + emulator.port);
        this.setDeviceId(emulator.udid);
        return context$1$0.abrupt('return', emulator);

      case 20:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 10;
        break;

      case 23:
        context$1$0.next = 29;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 29:
        context$1$0.prev = 29;
        context$1$0.prev = 30;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 32:
        context$1$0.prev = 32;

        if (!_didIteratorError4) {
          context$1$0.next = 35;
          break;
        }

        throw _iteratorError4;

      case 35:
        return context$1$0.finish(32);

      case 36:
        return context$1$0.finish(29);

      case 37:
        _loggerJs2['default'].debug('Emulator ' + avdName + ' not running');
        return context$1$0.abrupt('return', null);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting AVD. Original error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 41], [8, 25, 29, 37], [30,, 32, 36]]);
};

/**
 * Get the object for the currently running emulator.
 *
 * @param {string} avdName - Emulator name.
 * @param {number} timeoutMs [20000] - The maximum number of milliseconds
 *                                     to wait until at least one running AVD object
 *                                     is detected.
 * @return {?Device} Currently running emulator or _null_.
 * @throws {Error} If no device has been detected within the timeout.
 */
systemCallMethods.getRunningAVDWithRetry = function callee$0$0(avdName) {
  var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? 20000 : arguments[1];
  var start, runningAVD;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        start = Date.now();

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName.replace('@', '')));

      case 6:
        runningAVD = context$1$0.sent;

        if (!runningAVD) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return', runningAVD);

      case 9:
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

        // Do nothing.
        _loggerJs2['default'].info('Couldn\'t get running AVD, will retry. Error was: ' + context$1$0.t0.message);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

      case 16:
        context$1$0.next = 2;
        break;

      case 18:
        throw new Error('Could not find ' + avdName + ' emulator.');

      case 21:
        context$1$0.prev = 21;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting AVD with retry. Original error: ' + context$1$0.t1.message);

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 21], [3, 11]]);
};

/**
 * Shutdown all running emulators by killing their processes.
 *
 * @throws {Error} If killing tool returned non-zero return code.
 */
systemCallMethods.killAllEmulators = function callee$0$0() {
  var cmd, args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, args = undefined;

        if (_appiumSupport.system.isWindows()) {
          cmd = 'TASKKILL';
          args = ['TASKKILL', '/IM', 'emulator.exe'];
        } else {
          cmd = '/usr/bin/killall';
          args = ['-m', 'emulator*'];
        }
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](2);
        throw new Error('Error killing emulators. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 7]]);
};

/**
 * Kill emulator with the given name. No error
 * is thrown is given avd does not exist/is not running.
 *
 * @param {string} avdName - The name of the emulator to be killed.
 */
systemCallMethods.killEmulator = function callee$0$0(avdName) {
  var device;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('killing avd \'' + avdName + '\'');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName));

      case 3:
        device = context$1$0.sent;

        if (!device) {
          context$1$0.next = 10;
          break;
        }

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'kill']));

      case 7:
        _loggerJs2['default'].info('successfully killed emulator \'' + avdName + '\'');
        context$1$0.next = 11;
        break;

      case 10:
        _loggerJs2['default'].info('no avd with name \'' + avdName + '\' running. skipping kill step.');

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Start an emulator with given parameters and wait until it is full started.
 *
 * @param {string} avdName - The name of an existing emulator.
 * @param {Array.<string>|string} avdArgs - Additional emulator command line argument.
 * @param {?string} language - Emulator system language.
 * @param {?contry} country - Emulator system country.
 * @param {number} avdLaunchTimeout [60000] - Emulator startup timeout in milliseconds.
 * @param {number} retryTimes [1] - The maximum number of startup retries.
 * @throws {Error} If the emulator fails to start within the given timeout.
 */
systemCallMethods.launchAVD = function callee$0$0(avdName, avdArgs, language, country) {
  var avdLaunchTimeout = arguments.length <= 4 || arguments[4] === undefined ? 60000 : arguments[4];
  var avdReadyTimeout = arguments.length <= 5 || arguments[5] === undefined ? 60000 : arguments[5];
  var retryTimes = arguments.length <= 6 || arguments[6] === undefined ? 1 : arguments[6];
  var emulatorBinaryPath, launchArgs, locale, proc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Launching Emulator with AVD ' + avdName + ', launchTimeout ' + (avdLaunchTimeout + 'ms and readyTimeout ' + avdReadyTimeout + 'ms'));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("emulator"));

      case 3:
        emulatorBinaryPath = context$1$0.sent;

        if (avdName[0] === "@") {
          avdName = avdName.substr(1);
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.checkAvdExist(avdName));

      case 7:
        launchArgs = ["-avd", avdName];

        if (_lodash2['default'].isString(language)) {
          _loggerJs2['default'].debug('Setting Android Device Language to ' + language);
          launchArgs.push("-prop", 'persist.sys.language=' + language.toLowerCase());
        }
        if (_lodash2['default'].isString(country)) {
          _loggerJs2['default'].debug('Setting Android Device Country to ' + country);
          launchArgs.push("-prop", 'persist.sys.country=' + country.toUpperCase());
        }
        locale = undefined;

        if (_lodash2['default'].isString(language) && _lodash2['default'].isString(country)) {
          locale = language.toLowerCase() + "-" + country.toUpperCase();
        } else if (_lodash2['default'].isString(language)) {
          locale = language.toLowerCase();
        } else if (_lodash2['default'].isString(country)) {
          locale = country;
        }
        if (_lodash2['default'].isString(locale)) {
          _loggerJs2['default'].debug('Setting Android Device Locale to ' + locale);
          launchArgs.push("-prop", 'persist.sys.locale=' + locale);
        }
        if (!_lodash2['default'].isEmpty(avdArgs)) {
          launchArgs.push.apply(launchArgs, _toConsumableArray(_lodash2['default'].isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
        }
        _loggerJs2['default'].debug('Running \'' + emulatorBinaryPath + '\' with args: ' + JSON.stringify(launchArgs));
        proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(proc.start(0));

      case 18:
        proc.on('output', function (stdout, stderr) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = _getIterator((stdout || stderr || '').split('\n').filter(Boolean)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var line = _step5.value;

              _loggerJs2['default'].info('[AVD OUTPUT] ' + line);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                _iterator5['return']();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        });
        proc.on('exit', function (code, signal) {
          if (code !== 0) {
            throw new Error('Emulator avd ' + avdName + ' exit with code ' + code + ', signal ' + signal);
          }
        });
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retryTimes, this.getRunningAVDWithRetry.bind(this), avdName, avdLaunchTimeout));

      case 22:
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(this.waitForEmulatorReady(avdReadyTimeout));

      case 24:
        return context$1$0.abrupt('return', proc);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Object} ADBVersion
 * @property {string} versionString - ADB version as a string.
 * @property {float} versionFloat - Version number as float value (useful for comparison).
 * @property {number} major - Major version number.
 * @property {number} minor - Minor version number.
 * @property {number} patch - Patch version number.
 */

/**
 * Get the adb version. The result of this method is cached.
 *
 * @return {ADBVersion} The current adb version.
 * @throws {Error} If it is not possible to parse adb version.
 */
systemCallMethods.getAdbVersion = _lodash2['default'].memoize(function callee$0$0() {
  var adbVersion, parts;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec('version'));

      case 3:
        adbVersion = context$1$0.sent.replace(/Android\sDebug\sBridge\sversion\s([\d\.]*)[\s\w\-]*/, "$1");
        parts = adbVersion.split('.');
        return context$1$0.abrupt('return', {
          versionString: adbVersion,
          versionFloat: parseFloat(adbVersion),
          major: parseInt(parts[0], 10),
          minor: parseInt(parts[1], 10),
          patch: parts[2] ? parseInt(parts[2], 10) : undefined
        });

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Error getting adb version. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
});

/**
 * Check if given emulator exists in the list of available avds.
 *
 * @param {string} avdName - The name of emulator to verify for existence.
 * @throws {Error} If the emulator with given name does not exist.
 */
systemCallMethods.checkAvdExist = function callee$0$0(avdName) {
  var cmd, result, unknownOptionError, sdkVersion, binaryName, existings;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, result = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath('emulator'));

      case 4:
        cmd = context$1$0.sent;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['-list-avds']));

      case 7:
        result = context$1$0.sent;
        context$1$0.next = 26;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);
        unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(context$1$0.t0.stderr);

        if (unknownOptionError) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('Error executing checkAvdExist. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _helpers.getSdkToolsVersion)());

      case 17:
        sdkVersion = context$1$0.sent;
        binaryName = 'android';

        if (sdkVersion) {
          if (sdkVersion.major >= 25) {
            binaryName = 'avdmanager';
          }
        } else {
          _loggerJs2['default'].warn('Defaulting binary name to \'' + binaryName + '\', because SDK version cannot be parsed');
        }
        // If -list-avds option is not available, use android command as an alternative
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath(binaryName));

      case 22:
        cmd = context$1$0.sent;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['list', 'avd', '-c']));

      case 25:
        result = context$1$0.sent;

      case 26:
        if (!(result.stdout.indexOf(avdName) === -1)) {
          context$1$0.next = 29;
          break;
        }

        existings = '(' + result.stdout.trim().replace(/[\n]/g, '), (') + ')';
        throw new Error('Avd \'' + avdName + '\' is not available. please select your avd name from one of these: \'' + existings + '\'');

      case 29:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

/**
 * Check if the current emulator is ready to accept further commands (booting completed).
 *
 * @param {number} timeoutMs [20000] - The maximum number of milliseconds to wait.
 * @throws {Error} If the emulator is not ready within the given timeout.
 */
systemCallMethods.waitForEmulatorReady = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Waiting until emulator is ready");

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.shell(["getprop", "init.svc.bootanim"]));

      case 6:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf('stopped') > -1)) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return');

      case 9:
        context$1$0.next = 13;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(3000));

      case 15:
        context$1$0.next = 2;
        break;

      case 17:
        throw new Error('Emulator not ready');

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 11]]);
};

/**
 * Check if the current device is ready to accept further commands (booting completed).
 *
 * @param {number} appDeviceReadyTimeout [30] - The maximum number of seconds to wait.
 * @throws {Error} If the device is not ready within the given timeout.
 */
systemCallMethods.waitForDevice = function callee$0$0() {
  var appDeviceReadyTimeout = arguments.length <= 0 || arguments[0] === undefined ? 30 : arguments[0];
  var retries, timeout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        this.appDeviceReadyTimeout = appDeviceReadyTimeout;
        retries = 3;
        timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retries, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adbExec('wait-for-device', { timeout: timeout }));

              case 3:
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.ping());

              case 5:
                context$2$0.next = 14;
                break;

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 11:
                context$2$0.next = 13;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 13:
                throw new Error('Error in waiting for device. Original error: \'' + context$2$0.t0.message + '\'. ' + 'Retrying by restarting ADB');

              case 14:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[0, 7]]);
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Reboot the current device and wait until it is completed.
 *
 * @param {number} retries [DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.
 * @throws {Error} If the device failed to reboot and number of retries is exceeded.
 */
systemCallMethods.reboot = function callee$0$0() {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_ADB_REBOOT_RETRIES : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 4:
        context$1$0.next = 15;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        if (!(context$1$0.t0.message.indexOf('must be root') === -1)) {
          context$1$0.next = 10;
          break;
        }

        throw context$1$0.t0;

      case 10:
        // this device needs adb to be running as root to stop.
        // so try to restart the daemon
        _loggerJs2['default'].debug('Device requires adb to be running as root in order to reboot. Restarting daemon');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.root());

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(2000));

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.setDeviceProperty('sys.boot_completed', 0));

      case 19:
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.shell(['start']));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 1000, function callee$1$0() {
          var booted, msg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getDeviceProperty('sys.boot_completed'));

              case 2:
                booted = context$2$0.sent;

                if (!(booted === '1')) {
                  context$2$0.next = 7;
                  break;
                }

                return context$2$0.abrupt('return');

              case 7:
                msg = 'Waiting for reboot. This takes time';

                _loggerJs2['default'].debug(msg);
                throw new Error(msg);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4);
        }));

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(this.unroot());

      case 26:
        return context$1$0.finish(23);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0,, 23, 27], [1, 6]]);
};

/**
 * Switch adb server to root mode.
 *
 * @return {boolean} True of the switch was successful or false
 *                   if the switch failed.
 */
systemCallMethods.root = function callee$0$0() {
  var _ref4, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['root']));

      case 3:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;

        if (!(stdout && stdout.indexOf('adbd cannot run as root') !== -1)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error(stdout.trim());

      case 7:
        return context$1$0.abrupt('return', true);

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to root adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 10]]);
};

/**
 * Switch adb server to non-root mode.
 *
 * @return {boolean} True of the switch was successful or false
 *                   if the switch failed.
 */
systemCallMethods.unroot = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['unroot']));

      case 3:
        return context$1$0.abrupt('return', true);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to unroot adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
};

/**
 * Verify whether a remote path exists on the device under test.
 *
 * @param {string} remotePath - The remote path to verify.
 * @return {boolean} True if the given path exists on the device.
 */
systemCallMethods.fileExists = function callee$0$0(remotePath) {
  var files;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.ls(remotePath));

      case 2:
        files = context$1$0.sent;
        return context$1$0.abrupt('return', files.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the output of _ls_ command on the device under test.
 *
 * @param {string} remotePath - The remote path (the first argument to the _ls_ command).
 * @param {Array.<String>} opts [[]] - Additional _ls_ options.
 * @return {Array.<String>} The _ls_ output as an array of split lines.
 *                          An empty array is returned of the given _remotePath_
 *                          does not exist.
 */
systemCallMethods.ls = function callee$0$0(remotePath) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var args, stdout, lines;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        args = ['ls'].concat(_toConsumableArray(opts), [remotePath]);
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 4:
        stdout = context$1$0.sent;
        lines = stdout.split("\n");
        return context$1$0.abrupt('return', lines.map(function (l) {
          return l.trim();
        }).filter(Boolean).filter(function (l) {
          return l.indexOf("No such file") === -1;
        }));

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(context$1$0.t0.message.indexOf('No such file or directory') === -1)) {
          context$1$0.next = 13;
          break;
        }

        throw context$1$0.t0;

      case 13:
        return context$1$0.abrupt('return', []);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
};

/**
 * Get the size of the particular file located on the device under test.
 *
 * @param {string} remotePath - The remote path to the file.
 * @return {number} File size in bytes.
 * @throws {Error} If there was an error while getting the size of the given file.
 */
systemCallMethods.fileSize = function callee$0$0(remotePath) {
  var files, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.ls(remotePath, ['-la']));

      case 3:
        files = context$1$0.sent;

        if (!(files.length !== 1)) {
          context$1$0.next = 6;
          break;
        }

        throw new Error('Remote path is not a file');

      case 6:
        match = /\s(\d+)\s+\d{4}-\d{2}-\d{2}/.exec(files[0]);

        if (!(!match || _lodash2['default'].isNaN(parseInt(match[1], 10)))) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to parse size from list output: \'' + files[0] + '\'');

      case 9:
        return context$1$0.abrupt('return', parseInt(match[1], 10));

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Unable to get file size for \'' + remotePath + '\': ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 12]]);
};

exports['default'] = systemCallMethods;
module.exports = exports['default'];

// get subpaths for currently installed build tool directories

// expecting adb devices to return output as
// List of devices attached
// emulator-5554	device

// cool down

// cool down

// The methods is used to remove telnet auth token
//

// cool down

// do nothing
// let the emu finish stopping;

// we don't want the stack trace, so no log.errorAndThrow

// on real devices in some situations we get an error in the stdout

// https://regex101.com/r/fOs4P4/3
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCLE1BQU07Ozs7d0JBQ1AsY0FBYzs7Ozt3QkFDaEIsVUFBVTs7Ozs2QkFDRyxnQkFBZ0I7O3VCQUNXLFlBQVk7OzRCQUNqQyxjQUFjOzt3QkFDSCxVQUFVOztzQkFDeEMsUUFBUTs7OzswQkFDQSxhQUFhOztBQUduQyxJQUFJLGlCQUFpQixHQUFHLEVBQUUsQ0FBQzs7QUFFM0IsSUFBTSx3QkFBd0IsR0FBRyxLQUFLLENBQUM7QUFDdkMsSUFBTSwwQkFBMEIsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7O0FBUXRDLGlCQUFpQixDQUFDLGdCQUFnQixHQUFHLG9CQUFFLE9BQU8sQ0FBQyxvQkFBZ0IsVUFBVTs7OztBQUN2RSw4QkFBSSxJQUFJLHVCQUFxQixVQUFVLGlCQUFjLENBQUM7O2FBQ2xELElBQUksQ0FBQyxPQUFPOzs7Ozs7eUNBQ0QsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQzs7Ozs7O0FBRXBELDhCQUFJLElBQUksQ0FBQywySUFDa0UsK0NBQ3pCLFVBQVUsT0FBRyxDQUFDLENBQUM7O3lDQUNwRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDOzs7Ozs7Ozs7O0NBQ2hELENBQUMsQ0FBQzs7Ozs7Ozs7O0FBU0gsaUJBQWlCLENBQUMsZUFBZSxHQUFHLG9CQUFFLE9BQU8sQ0FBQyxZQUFZO0FBQ3hELFNBQU8sc0JBQU8sU0FBUyxFQUFFLEdBQUcsT0FBTyxHQUFHLE9BQU8sQ0FBQztDQUMvQyxDQUFDLENBQUM7Ozs7Ozs7OztBQVNILGlCQUFpQixDQUFDLGtCQUFrQixHQUFHLG9CQUFFLE9BQU8sQ0FBQyxVQUFVLFVBQVUsRUFBRTtBQUNyRSxNQUFJLENBQUMsc0JBQU8sU0FBUyxFQUFFLEVBQUU7QUFDdkIsV0FBTyxVQUFVLENBQUM7R0FDbkI7O0FBRUQsTUFBSSxDQUFDLFNBQVMsRUFBRSxXQUFXLEVB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QyxNQUFNLEtBQUssQ0FBQyxDQUFBOzs7OztjQUNkLElBQUksS0FBSyw2QkFBNkI7OztBQUcxQyxhQUFLLEdBQUcsNkJBQTZCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Y0FDcEQsQ0FBQyxLQUFLLElBQUksb0JBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQTs7Ozs7Y0FDckMsSUFBSSxLQUFLLCtDQUE0QyxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQUk7Ozs0Q0FFbEUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7Ozs7O2NBRXZCLElBQUksS0FBSyxvQ0FBaUMsVUFBVSxZQUFNLGVBQUksT0FBTyxDQUFHOzs7Ozs7O0NBRWpGLENBQUM7O3FCQUVhLGlCQUFpQiIsImZpbGUiOiJsaWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgZ2V0U2RrVG9vbHNWZXJzaW9uLCBnZXRCdWlsZFRvb2xzRGlycyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcXVvdGUgfSBmcm9tICdzaGVsbC1xdW90ZSc7XG5cblxubGV0IHN5c3RlbUNhbGxNZXRob2RzID0ge307XG5cbmNvbnN0IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCA9IDIwMDAwOyAvLyBpbiBtaWxsaXNlY29uZHNcbmNvbnN0IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTID0gOTA7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeSBpbmNsdWRpbmcgY3VycmVudCBTREsgcm9vdC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0U2RrQmluYXJ5UGF0aCA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsb2cuaW5mbyhgQ2hlY2tpbmcgd2hldGhlciAke2JpbmFyeU5hbWV9IGlzIHByZXNlbnRgKTtcbiAgaWYgKHRoaXMuc2RrUm9vdCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEJpbmFyeUZyb21TZGtSb290KGJpbmFyeU5hbWUpO1xuICB9XG4gIGxvZy53YXJuKGBUaGUgQU5EUk9JRF9IT01FIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXQgdG8gdGhlIEFuZHJvaWQgU0RLIGAgK1xuICAgICAgICAgICBgcm9vdCBkaXJlY3RvcnkgcGF0aC4gQU5EUk9JRF9IT01FIGlzIHJlcXVpcmVkIGZvciBjb21wYXRpYmlsaXR5IGAgK1xuICAgICAgICAgICBgd2l0aCBTREsgMjMrLiBDaGVja2luZyBhbG9uZyBQQVRIIGZvciAke2JpbmFyeU5hbWV9LmApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tUGF0aChiaW5hcnlOYW1lKTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBuYW1lIG9mIHRoZSB0b29sLFxuICogd2hpY2ggcHJpbnRzIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gY29tbWFuZCBzaG9ydGN1dC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybSB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgIHN1cHBvc2VkIHRvIGJlIGVpdGhlciAnd2hpY2gnIG9yICd3aGVyZScuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbW1hbmRGb3JPUyA9IF8ubWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzeXN0ZW0uaXNXaW5kb3dzKCkgPyAnd2hlcmUnIDogJ3doaWNoJztcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgYmluYXJ5IG5hbWUgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBzaW1wbGUgYmluYXJ5IG5hbWUsIGZvciBleGFtcGxlICdhbmRyb2lkJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIGJpbmFyeSBuYW1lIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybSxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsICdhbmRyb2lkLmJhdCcgb24gV2luZG93cy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5TmFtZUZvck9TID0gXy5tZW1vaXplKGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGlmICghc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgcmV0dXJuIGJpbmFyeU5hbWU7XG4gIH1cblxuICBpZiAoWydhbmRyb2lkJywgJ2Fwa3NpZ25lcicsICdhcGthbmFseXplciddLmluZGV4T2YoYmluYXJ5TmFtZSkgPj0gMCAmJlxuICAgICAgIWJpbmFyeU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmJhdCcpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmJhdGA7XG4gIH1cbiAgaWYgKCFiaW5hcnlOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5leGUnKSkge1xuICAgIHJldHVybiBgJHtiaW5hcnlOYW1lfS5leGVgO1xuICB9XG4gIHJldHVybiBiaW5hcnlOYW1lO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBTaW1wbGUgbmFtZSBvZiBhIGJpbmFyeSBmaWxlLlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS4gVGhlIG1ldGhvZCB0cmllc1xuICogICAgICAgICAgICAgICAgICB0byBlbnVtZXJhdGUgYWxsIHRoZSBrbm93biBsb2NhdGlvbnMgd2hlcmUgdGhlIGJpbmFyeVxuICogICAgICAgICAgICAgICAgICBtaWdodCBiZSBsb2NhdGVkIGFuZCBzdG9wcyB0aGUgc2VhcmNoIGFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgIG1hdGNoIGlzIGZvdW5kIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYmluYXJ5IHdpdGggZ2l2ZW4gbmFtZSBpcyBub3QgcHJlc2VudCBhdCBhbnlcbiAqICAgICAgICAgICAgICAgICBvZiBrbm93biBsb2NhdGlvbnMgb3IgQW5kcm9pZCBTREsgaXMgbm90IGluc3RhbGxlZCBvbiB0aGVcbiAqICAgICAgICAgICAgICAgICBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QgPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbGV0IGJpbmFyeUxvYyA9IG51bGw7XG4gIGJpbmFyeU5hbWUgPSB0aGlzLmdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbiAgbGV0IGJpbmFyeUxvY3MgPSBbXG4gICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJwbGF0Zm9ybS10b29sc1wiLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcImVtdWxhdG9yXCIsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwidG9vbHNcIiwgYmluYXJ5TmFtZSksXG4gICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJ0b29sc1wiLCBcImJpblwiLCBiaW5hcnlOYW1lKVxuICBdO1xuICAvLyBnZXQgc3VicGF0aHMgZm9yIGN1cnJlbnRseSBpbnN0YWxsZWQgYnVpbGQgdG9vbCBkaXJlY3Rvcmllc1xuICBfLmZvckVhY2goYXdhaXQgZ2V0QnVpbGRUb29sc0RpcnModGhpcy5zZGtSb290KSxcbiAgICAgICAgICAgIChkaXIpID0+IGJpbmFyeUxvY3MucHVzaChwYXRoLnJlc29sdmUoZGlyLCBiaW5hcnlOYW1lKSkpO1xuICBmb3IgKGxldCBsb2Mgb2YgYmluYXJ5TG9jcykge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMobG9jKSkge1xuICAgICAgYmluYXJ5TG9jID0gbG9jO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChfLmlzTnVsbChiaW5hcnlMb2MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IGluICR7YmluYXJ5TG9jc30uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgRG8geW91IGhhdmUgdGhlIEFuZHJvaWQgU0RLIGluc3RhbGxlZCBhdCAnJHt0aGlzLnNka1Jvb3R9Jz9gKTtcbiAgfVxuICBiaW5hcnlMb2MgPSBiaW5hcnlMb2MudHJpbSgpO1xuICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7YmluYXJ5TG9jfWApO1xuICByZXR1cm4gYmluYXJ5TG9jO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBsZXQgY21kID0gdGhpcy5nZXRDb21tYW5kRm9yT1MoKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGNtZCwgW2JpbmFyeU5hbWVdKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7c3Rkb3V0fWApO1xuICAgIC8vIFRPRE8gd3JpdGUgYSB0ZXN0IGZvciBiaW5hcmllcyB3aXRoIHNwYWNlcy5cbiAgICBiaW5hcnlMb2MgPSBzdGRvdXQudHJpbSgpO1xuICAgIHJldHVybiBiaW5hcnlMb2M7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gUGxlYXNlIHNldCB0aGUgQU5EUk9JRF9IT01FIGAgK1xuICAgICAgICAgICAgICBgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCB0aGUgQW5kcm9pZCBTREsgcm9vdCBkaXJlY3RvcnkgcGF0aC5gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXZpY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1ZGlkIC0gVGhlIGRldmljZSB1ZGlkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gQ3VycmVudCBkZXZpY2Ugc3RhdGUsIGFzIGl0IGlzIHZpc2libGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hZGIgZGV2aWNlcyAtbF8gb3V0cHV0LlxuICovXG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYi5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgZGV2aWNlcyBvciBhbiBlbXB0eSBsaXN0IGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gZGV2aWNlcyBhcmUgY29ubmVjdGVkLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsaXN0aW5nIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZERldmljZXMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIkdldHRpbmcgY29ubmVjdGVkIGRldmljZXMuLi5cIik7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChbJ2RldmljZXMnXSkpO1xuICAgIC8vIGV4cGVjdGluZyBhZGIgZGV2aWNlcyB0byByZXR1cm4gb3V0cHV0IGFzXG4gICAgLy8gTGlzdCBvZiBkZXZpY2VzIGF0dGFjaGVkXG4gICAgLy8gZW11bGF0b3ItNTU1NFx0ZGV2aWNlXG4gICAgbGV0IHN0YXJ0aW5nSW5kZXggPSBzdGRvdXQuaW5kZXhPZihcIkxpc3Qgb2YgZGV2aWNlc1wiKTtcbiAgICBpZiAoc3RhcnRpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBvdXRwdXQgd2hpbGUgdHJ5aW5nIHRvIGdldCBkZXZpY2VzLiBvdXRwdXQgd2FzOiAke3N0ZG91dH1gKTtcbiAgICB9XG4gICAgLy8gc2xpY2luZyBvdXB1dCB3ZSBjYXJlIGFib3V0LlxuICAgIHN0ZG91dCA9IHN0ZG91dC5zbGljZShzdGFydGluZ0luZGV4KTtcbiAgICBsZXQgZGV2aWNlcyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc3Rkb3V0LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBpZiAobGluZS50cmltKCkgIT09IFwiXCIgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoXCJMaXN0IG9mIGRldmljZXNcIikgPT09IC0xICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKFwiYWRiIHNlcnZlclwiKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoXCIqIGRhZW1vblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoXCJvZmZsaW5lXCIpID09PSAtMSkge1xuICAgICAgICBsZXQgbGluZUluZm8gPSBsaW5lLnNwbGl0KFwiXFx0XCIpO1xuICAgICAgICAvLyBzdGF0ZSBpcyBlaXRoZXIgXCJkZXZpY2VcIiBvciBcIm9mZmxpbmVcIiwgYWZhaWN0XG4gICAgICAgIGRldmljZXMucHVzaCh7dWRpZDogbGluZUluZm9bMF0sIHN0YXRlOiBsaW5lSW5mb1sxXX0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7ZGV2aWNlcy5sZW5ndGh9IGRldmljZShzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZGV2aWNlcztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgZ2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGdldCBhdCBsZWFzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZSBsaXN0IGl0ZW0uXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gY29ubmVjdGVkIGRldmljZXMgY2FuIGJlIGRldGVjdGVkIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RGV2aWNlc1dpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICBsb2cuZGVidWcoXCJUcnlpbmcgdG8gZmluZCBhIGNvbm5lY3RlZCBhbmRyb2lkIGRldmljZVwiKTtcbiAgbGV0IGdldERldmljZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChEYXRlLm5vdygpIC0gc3RhcnQpID4gdGltZW91dE1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIGNvbm5lY3RlZCBBbmRyb2lkIGRldmljZS5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgICAgaWYgKGRldmljZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICBsb2cuZGVidWcoXCJDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi5cIik7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgICAvLyBjb29sIGRvd25cbiAgICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5kZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLlwiKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgLy8gY29vbCBkb3duXG4gICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG59O1xuXG4vKipcbiAqIFJlc3RhcnQgYWRiIHNlcnZlciBpZiBfdGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXJfIHByb3BlcnR5IGlzIHRydWUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc3RhcnRBZGIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1cHByZXNzS2lsbFNlcnZlcikge1xuICAgIGxvZy5kZWJ1ZyhgTm90IHJlc3RhcnRpbmcgYWJkIHNpbmNlICdzdXBwcmVzc0tpbGxTZXJ2ZXInIGlzIG9uYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nLmRlYnVnKCdSZXN0YXJ0aW5nIGFkYicpO1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMua2lsbFNlcnZlcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yKFwiRXJyb3Iga2lsbGluZyBBREIgc2VydmVyLCBnb2luZyB0byBzZWUgaWYgaXQncyBvbmxpbmUgYW55d2F5XCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgYWRiIHNlcnZlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbFNlcnZlciA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbG9nLmRlYnVnKGBLaWxsaW5nIGFkYiBzZXJ2ZXIgb24gcG9ydCAke3RoaXMuYWRiUG9ydH1gKTtcbiAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWy4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgJ2tpbGwtc2VydmVyJ10pO1xufTtcblxuLyoqXG4gKiBSZXNldCBUZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAc2VlIHtAbGluayBodHRwOi8vdG9vbHMuYW5kcm9pZC5jb20vcmVjZW50L2VtdWxhdG9yMjUxNnJlbGVhc2Vub3Rlc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdG9rZW4gcmVzZXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy9cbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKCdDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3JcXCdzIHRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGhvbWVGb2xkZXJQYXRoLCAnLmVtdWxhdG9yX2NvbnNvbGVfYXV0aF90b2tlbicpO1xuICBsb2cuZGVidWcoYE92ZXJyaWRpbmcgJHtkc3RQYXRofSB3aXRoIGFuIGVtcHR5IHN0cmluZyB0byBhdm9pZCB0ZWxuZXQgYXV0aGVudGljYXRpb24gZm9yIGVtdWxhdG9yIGNvbW1hbmRzYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdFBhdGgsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy53YXJuKGBFcnJvciAke2UubWVzc2FnZX0gd2hpbGUgcmVzZXR0aW5nIHRoZSBjb250ZW50IG9mICR7ZHN0UGF0aH0uIElnbm9yaW5nIHJlc2V0dGluZyBvZiBlbXVsYXRvclxcJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gZW11bGF0b3IgY29tbWFuZCB1c2luZyBfYWRiIGVtdV8gdG9vbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlY0VtdSA9IGFzeW5jIGZ1bmN0aW9uIChjbWQpIHtcbiAgYXdhaXQgdGhpcy52ZXJpZnlFbXVsYXRvckNvbm5lY3RlZCgpO1xuICBhd2FpdCB0aGlzLnJlc2V0VGVsbmV0QXV0aFRva2VuKCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsIC4uLmNtZF0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIHBhc3MgaW4gYSBjb21tYW5kIHRvIGFkYkV4ZWMoKVwiKTtcbiAgfVxuICAvLyBzZXR0aW5nIGRlZmF1bHQgdGltZW91dCBmb3IgZWFjaCBjb21tYW5kIHRvIHByZXZlbnQgaW5maW5pdGUgd2FpdC5cbiAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IHRoaXMuZXhlY1RpbWVvdXQgfHwgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUO1xuICBsZXQgZXhlY0Z1bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGxpbmtlcldhcm5pbmdSZSA9IC9eV0FSTklORzogbGlua2VyLiskL207XG4gICAgdHJ5IHtcbiAgICAgIGlmICghKGNtZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBjbWQgPSBbY21kXTtcbiAgICAgIH1cbiAgICAgIGxldCBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChjbWQpO1xuICAgICAgbG9nLmRlYnVnKGBSdW5uaW5nICcke3RoaXMuZXhlY3V0YWJsZS5wYXRofSAke3F1b3RlKGFyZ3MpfSdgKTtcbiAgICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIGFyZ3MsIG9wdHMpO1xuICAgICAgLy8gc29tZXRpbWVzIEFEQiBwcmludHMgb3V0IHdlaXJkIHN0ZG91dCB3YXJuaW5ncyB0aGF0IHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGluY2x1ZGUgaW4gYW55IG9mIHRoZSByZXNwb25zZSBkYXRhLCBzbyBsZXQncyBzdHJpcCBpdCBvdXRcbiAgICAgIHN0ZG91dCA9IHN0ZG91dC5yZXBsYWNlKGxpbmtlcldhcm5pbmdSZSwgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbGV0IHByb3RvY29sRmF1bHRFcnJvciA9IG5ldyBSZWdFeHAoXCJwcm90b2NvbCBmYXVsdCBcXFxcKG5vIHN0YXR1c1xcXFwpXCIsIFwiaVwiKS50ZXN0KGUpO1xuICAgICAgbGV0IGRldmljZU5vdEZvdW5kRXJyb3IgPSBuZXcgUmVnRXhwKFwiZXJyb3I6IGRldmljZSAoJy4rJyApP25vdCBmb3VuZFwiLCBcImlcIikudGVzdChlKTtcbiAgICAgIGlmIChwcm90b2NvbEZhdWx0RXJyb3IgfHwgZGV2aWNlTm90Rm91bmRFcnJvcikge1xuICAgICAgICBsb2cuaW5mbyhgRXJyb3Igc2VuZGluZyBjb21tYW5kLCByZWNvbm5lY3RpbmcgZGV2aWNlIGFuZCByZXRyeWluZzogJHtjbWR9YCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICBhd2FpdCB0aGlzLmdldERldmljZXNXaXRoUmV0cnkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY29kZSA9PT0gMCAmJiBlLnN0ZG91dCkge1xuICAgICAgICBsZXQgc3Rkb3V0ID0gZS5zdGRvdXQ7XG4gICAgICAgIHN0ZG91dCA9IHN0ZG91dC5yZXBsYWNlKGxpbmtlcldhcm5pbmdSZSwgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgYWRiRXhlYy4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXdhaXQgcmV0cnkoMiwgZXhlY0Z1bmMpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBjb21tYW5kIHVzaW5nIF9hZGIgc2hlbGxfIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMgb3IgYSBzaW5nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy4gU2VlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL25vZGUtdGVlbl9wcm9jZXNzfVxuICogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybiB7c3RyaW5nfSAtIENvbW1hbmQncyBzdGRvdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGNvbW1hbmQgcmV0dXJuZWQgbm9uLXplcm8gZXhpdCBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zaGVsbCA9IGFzeW5jIGZ1bmN0aW9uIChjbWQsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5hZGJFeGVjKF8uaXNBcnJheShjbWQpID8gWydzaGVsbCcsIC4uLmNtZF0gOiBbJ3NoZWxsJywgY21kXSwgb3B0cyk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5jcmVhdGVTdWJQcm9jZXNzID0gZnVuY3Rpb24gKGFyZ3MgPSBbXSkge1xuICAvLyBhZGQgdGhlIGRlZmF1bHQgYXJndW1lbnRzXG4gIGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGFyZ3MpO1xuICBsb2cuZGVidWcoYENyZWF0aW5nIEFEQiBzdWJwcm9jZXNzIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgcmV0dXJuIG5ldyBTdWJQcm9jZXNzKHRoaXMuZ2V0QWRiUGF0aCgpLCBhcmdzKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgYWRiIHBvcnQuXG4gKiBAdG9kbyBjYW4gcHJvYmFibHkgZGVwcmVjYXRlIHRoaXMgbm93IHRoYXQgdGhlIGxvZ2ljIGlzIGp1c3QgdG8gcmVhZCB0aGlzLmFkYlBvcnRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgYWRiIHBvcnQgbnVtYmVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJTZXJ2ZXJQb3J0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hZGJQb3J0O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGZyb20gX2FkYiBkZXZpdmVzXyBvdXRwdXQuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBlbXVsYXRvciBwb3J0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RW11bGF0b3JQb3J0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoXCJHZXR0aW5nIHJ1bm5pbmcgZW11bGF0b3IgcG9ydFwiKTtcbiAgaWYgKHRoaXMuZW11bGF0b3JQb3J0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW11bGF0b3JQb3J0O1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VzWzBdLnVkaWQpO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICByZXR1cm4gcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBwb3J0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGV2aWNlcyBjb25uZWN0ZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGJ5IHBhcnNpbmcgZW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVtU3RyIC0gRW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gRWl0aGVyIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBfZmFsc2VfIGlmIHBvcnQgbnVtYmVyIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgPSBmdW5jdGlvbiAoZW1TdHIpIHtcbiAgbGV0IHBvcnRQYXR0ZXJuID0gL2VtdWxhdG9yLShcXGQrKS87XG4gIGlmIChwb3J0UGF0dGVybi50ZXN0KGVtU3RyKSkge1xuICAgIHJldHVybiBwYXJzZUludChwb3J0UGF0dGVybi5leGVjKGVtU3RyKVsxXSwgMTApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBlbXVsYXRvcnMuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKFwiR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzXCIpO1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2UudWRpZCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBkZXZpY2UucG9ydCA9IHBvcnQ7XG4gICAgICAgIGVtdWxhdG9ycy5wdXNoKGRldmljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtlbXVsYXRvcnMubGVuZ3RofSBlbXVsYXRvcihzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBfZW11bGF0b3JQb3J0XyBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW1Qb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXRFbXVsYXRvclBvcnQgPSBmdW5jdGlvbiAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VPYmopIHtcbiAgbGV0IGRldmljZUlkID0gZGV2aWNlT2JqLnVkaWQ7XG4gIGxldCBlbVBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlSWQpO1xuICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbVBvcnQpO1xuICB0aGlzLnNldERldmljZUlkKGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkQgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICB0cnkge1xuICAgIGxvZy5kZWJ1ZyhgVHJ5aW5nIHRvIGZpbmQgJHthdmROYW1lfSBlbXVsYXRvcmApO1xuICAgIGxldCBlbXVsYXRvcnMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZEVtdWxhdG9ycygpO1xuICAgIGZvciAobGV0IGVtdWxhdG9yIG9mIGVtdWxhdG9ycykge1xuICAgICAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW11bGF0b3IucG9ydCk7XG4gICAgICBsZXQgcnVubmluZ0FWRE5hbWUgPSBhd2FpdCB0aGlzLnNlbmRUZWxuZXRDb21tYW5kKFwiYXZkIG5hbWVcIik7XG4gICAgICBpZiAoYXZkTmFtZSA9PT0gcnVubmluZ0FWRE5hbWUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBGb3VuZCBlbXVsYXRvciAke2F2ZE5hbWV9IGluIHBvcnQgJHtlbXVsYXRvci5wb3J0fWApO1xuICAgICAgICB0aGlzLnNldERldmljZUlkKGVtdWxhdG9yLnVkaWQpO1xuICAgICAgICByZXR1cm4gZW11bGF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3IgJHthdmROYW1lfSBub3QgcnVubmluZ2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCB1bnRpbCBhdCBsZWFzdCBvbmUgcnVubmluZyBBVkQgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBkZXRlY3RlZC5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBkZXZpY2UgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIHRoZSB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIHRyeSB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB3aGlsZSAoKERhdGUubm93KCkgLSBzdGFydCkgPCB0aW1lb3V0TXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBydW5uaW5nQVZEID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUucmVwbGFjZSgnQCcsICcnKSk7XG4gICAgICAgIGlmIChydW5uaW5nQVZEKSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bm5pbmdBVkQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgbG9nLmluZm8oYENvdWxkbid0IGdldCBydW5uaW5nIEFWRCwgd2lsbCByZXRyeS4gRXJyb3Igd2FzOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvb2wgZG93blxuICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2F2ZE5hbWV9IGVtdWxhdG9yLmApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRCB3aXRoIHJldHJ5LiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2h1dGRvd24gYWxsIHJ1bm5pbmcgZW11bGF0b3JzIGJ5IGtpbGxpbmcgdGhlaXIgcHJvY2Vzc2VzLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBraWxsaW5nIHRvb2wgcmV0dXJuZWQgbm9uLXplcm8gcmV0dXJuIGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxBbGxFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBjbWQsIGFyZ3M7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBjbWQgPSAnVEFTS0tJTEwnO1xuICAgIGFyZ3MgPSBbJ1RBU0tLSUxMJywgJy9JTScsICdlbXVsYXRvci5leGUnXTtcbiAgfSBlbHNlIHtcbiAgICBjbWQgPSAnL3Vzci9iaW4va2lsbGFsbCc7XG4gICAgYXJncyA9IFsnLW0nLCAnZW11bGF0b3IqJ107XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKGNtZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGtpbGxpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBlbXVsYXRvciB3aXRoIHRoZSBnaXZlbiBuYW1lLiBObyBlcnJvclxuICogaXMgdGhyb3duIGlzIGdpdmVuIGF2ZCBkb2VzIG5vdCBleGlzdC9pcyBub3QgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlbXVsYXRvciB0byBiZSBraWxsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxFbXVsYXRvciA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lKSB7XG4gIGxvZy5kZWJ1Zyhga2lsbGluZyBhdmQgJyR7YXZkTmFtZX0nYCk7XG4gIGxldCBkZXZpY2UgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSk7XG4gIGlmIChkZXZpY2UpIHtcbiAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAna2lsbCddKTtcbiAgICBsb2cuaW5mbyhgc3VjY2Vzc2Z1bGx5IGtpbGxlZCBlbXVsYXRvciAnJHthdmROYW1lfSdgKTtcbiAgfSBlbHNlIHtcbiAgICBsb2cuaW5mbyhgbm8gYXZkIHdpdGggbmFtZSAnJHthdmROYW1lfScgcnVubmluZy4gc2tpcHBpbmcga2lsbCBzdGVwLmApO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGFuIGVtdWxhdG9yIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyBhbmQgd2FpdCB1bnRpbCBpdCBpcyBmdWxsIHN0YXJ0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiBhbiBleGlzdGluZyBlbXVsYXRvci5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBhdmRBcmdzIC0gQWRkaXRpb25hbCBlbXVsYXRvciBjb21tYW5kIGxpbmUgYXJndW1lbnQuXG4gKiBAcGFyYW0gez9zdHJpbmd9IGxhbmd1YWdlIC0gRW11bGF0b3Igc3lzdGVtIGxhbmd1YWdlLlxuICogQHBhcmFtIHs/Y29udHJ5fSBjb3VudHJ5IC0gRW11bGF0b3Igc3lzdGVtIGNvdW50cnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYXZkTGF1bmNoVGltZW91dCBbNjAwMDBdIC0gRW11bGF0b3Igc3RhcnR1cCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeVRpbWVzIFsxXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGFydHVwIHJldHJpZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGZhaWxzIHRvIHN0YXJ0IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUsIGF2ZEFyZ3MsIGxhbmd1YWdlLCBjb3VudHJ5LFxuICBhdmRMYXVuY2hUaW1lb3V0ID0gNjAwMDAsIGF2ZFJlYWR5VGltZW91dCA9IDYwMDAwLCByZXRyeVRpbWVzID0gMSkge1xuICBsb2cuZGVidWcoYExhdW5jaGluZyBFbXVsYXRvciB3aXRoIEFWRCAke2F2ZE5hbWV9LCBsYXVuY2hUaW1lb3V0IGAgK1xuICAgICAgICAgICAgYCR7YXZkTGF1bmNoVGltZW91dH1tcyBhbmQgcmVhZHlUaW1lb3V0ICR7YXZkUmVhZHlUaW1lb3V0fW1zYCk7XG4gIGxldCBlbXVsYXRvckJpbmFyeVBhdGggPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoXCJlbXVsYXRvclwiKTtcbiAgaWYgKGF2ZE5hbWVbMF0gPT09IFwiQFwiKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcbiAgbGV0IGxhdW5jaEFyZ3MgPSBbXCItYXZkXCIsIGF2ZE5hbWVdO1xuICBpZiAoXy5pc1N0cmluZyhsYW5ndWFnZSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgTGFuZ3VhZ2UgdG8gJHtsYW5ndWFnZX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goXCItcHJvcFwiLCBgcGVyc2lzdC5zeXMubGFuZ3VhZ2U9JHtsYW5ndWFnZS50b0xvd2VyQ2FzZSgpfWApO1xuICB9XG4gIGlmIChfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIENvdW50cnkgdG8gJHtjb3VudHJ5fWApO1xuICAgIGxhdW5jaEFyZ3MucHVzaChcIi1wcm9wXCIsIGBwZXJzaXN0LnN5cy5jb3VudHJ5PSR7Y291bnRyeS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGxldCBsb2NhbGU7XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSAmJiBfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSArIFwiLVwiICsgY291bnRyeS50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gY291bnRyeTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhsb2NhbGUpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExvY2FsZSB0byAke2xvY2FsZX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goXCItcHJvcFwiLCBgcGVyc2lzdC5zeXMubG9jYWxlPSR7bG9jYWxlfWApO1xuICB9XG4gIGlmICghXy5pc0VtcHR5KGF2ZEFyZ3MpKSB7XG4gICAgbGF1bmNoQXJncy5wdXNoKC4uLihfLmlzQXJyYXkoYXZkQXJncykgPyBhdmRBcmdzIDogYXZkQXJncy5zcGxpdCgnICcpKSk7XG4gIH1cbiAgbG9nLmRlYnVnKGBSdW5uaW5nICcke2VtdWxhdG9yQmluYXJ5UGF0aH0nIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShsYXVuY2hBcmdzKX1gKTtcbiAgbGV0IHByb2MgPSBuZXcgU3ViUHJvY2VzcyhlbXVsYXRvckJpbmFyeVBhdGgsIGxhdW5jaEFyZ3MpO1xuICBhd2FpdCBwcm9jLnN0YXJ0KDApO1xuICBwcm9jLm9uKCdvdXRwdXQnLCAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIChzdGRvdXQgfHwgc3RkZXJyIHx8ICcnKS5zcGxpdCgnXFxuJykuZmlsdGVyKEJvb2xlYW4pKSB7XG4gICAgICBsb2cuaW5mbyhgW0FWRCBPVVRQVVRdICR7bGluZX1gKTtcbiAgICB9XG4gIH0pO1xuICBwcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIGF2ZCAke2F2ZE5hbWV9IGV4aXQgd2l0aCBjb2RlICR7Y29kZX0sIHNpZ25hbCAke3NpZ25hbH1gKTtcbiAgICB9XG4gIH0pO1xuICBhd2FpdCByZXRyeShyZXRyeVRpbWVzLCB0aGlzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkuYmluZCh0aGlzKSwgYXZkTmFtZSwgYXZkTGF1bmNoVGltZW91dCk7XG4gIGF3YWl0IHRoaXMud2FpdEZvckVtdWxhdG9yUmVhZHkoYXZkUmVhZHlUaW1lb3V0KTtcbiAgcmV0dXJuIHByb2M7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFEQlZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uU3RyaW5nIC0gQURCIHZlcnNpb24gYXMgYSBzdHJpbmcuXG4gKiBAcHJvcGVydHkge2Zsb2F0fSB2ZXJzaW9uRmxvYXQgLSBWZXJzaW9uIG51bWJlciBhcyBmbG9hdCB2YWx1ZSAodXNlZnVsIGZvciBjb21wYXJpc29uKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYWpvciAtIE1ham9yIHZlcnNpb24gbnVtYmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbm9yIC0gTWlub3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGF0Y2ggLSBQYXRjaCB2ZXJzaW9uIG51bWJlci5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYWRiIHZlcnNpb24uIFRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgY2FjaGVkLlxuICpcbiAqIEByZXR1cm4ge0FEQlZlcnNpb259IFRoZSBjdXJyZW50IGFkYiB2ZXJzaW9uLlxuICogQHRocm93cyB7RXJyb3J9IElmIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBwYXJzZSBhZGIgdmVyc2lvbi5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QWRiVmVyc2lvbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IGFkYlZlcnNpb24gPSAoYXdhaXQgdGhpcy5hZGJFeGVjKCd2ZXJzaW9uJykpXG4gICAgICAucmVwbGFjZSgvQW5kcm9pZFxcc0RlYnVnXFxzQnJpZGdlXFxzdmVyc2lvblxccyhbXFxkXFwuXSopW1xcc1xcd1xcLV0qLywgXCIkMVwiKTtcbiAgICBsZXQgcGFydHMgPSBhZGJWZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb25TdHJpbmc6IGFkYlZlcnNpb24sXG4gICAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQoYWRiVmVyc2lvbiksXG4gICAgICBtYWpvcjogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgIG1pbm9yOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgcGF0Y2g6IHBhcnRzWzJdID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGFkYiB2ZXJzaW9uLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gZW11bGF0b3IgZXhpc3RzIGluIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBhdmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgZW11bGF0b3IgdG8gdmVyaWZ5IGZvciBleGlzdGVuY2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIHdpdGggZ2l2ZW4gbmFtZSBkb2VzIG5vdCBleGlzdC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuY2hlY2tBdmRFeGlzdCA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lKSB7XG4gIGxldCBjbWQsIHJlc3VsdDtcbiAgdHJ5IHtcbiAgICBjbWQgPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoJ2VtdWxhdG9yJyk7XG4gICAgcmVzdWx0ID0gYXdhaXQgZXhlYyhjbWQsIFsnLWxpc3QtYXZkcyddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxldCB1bmtub3duT3B0aW9uRXJyb3IgPSBuZXcgUmVnRXhwKFwidW5rbm93biBvcHRpb246IC1saXN0LWF2ZHNcIiwgXCJpXCIpLnRlc3QoZS5zdGRlcnIpO1xuICAgIGlmICghdW5rbm93bk9wdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGV4ZWN1dGluZyBjaGVja0F2ZEV4aXN0LiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG5cbiAgICB9XG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IGF3YWl0IGdldFNka1Rvb2xzVmVyc2lvbigpO1xuICAgIGxldCBiaW5hcnlOYW1lID0gJ2FuZHJvaWQnO1xuICAgIGlmIChzZGtWZXJzaW9uKSB7XG4gICAgICBpZiAoc2RrVmVyc2lvbi5tYWpvciA+PSAyNSkge1xuICAgICAgICBiaW5hcnlOYW1lID0gJ2F2ZG1hbmFnZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2cud2FybihgRGVmYXVsdGluZyBiaW5hcnkgbmFtZSB0byAnJHtiaW5hcnlOYW1lfScsIGJlY2F1c2UgU0RLIHZlcnNpb24gY2Fubm90IGJlIHBhcnNlZGApO1xuICAgIH1cbiAgICAvLyBJZiAtbGlzdC1hdmRzIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlLCB1c2UgYW5kcm9pZCBjb21tYW5kIGFzIGFuIGFsdGVybmF0aXZlXG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKGJpbmFyeU5hbWUpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJ2xpc3QnLCAnYXZkJywgJy1jJ10pO1xuICB9XG4gIGlmIChyZXN1bHQuc3Rkb3V0LmluZGV4T2YoYXZkTmFtZSkgPT09IC0xKSB7XG4gICAgbGV0IGV4aXN0aW5ncyA9IGAoJHtyZXN1bHQuc3Rkb3V0LnRyaW0oKS5yZXBsYWNlKC9bXFxuXS9nLCAnKSwgKCcpfSlgO1xuICAgIHRocm93IG5ldyBFcnJvcihgQXZkICcke2F2ZE5hbWV9JyBpcyBub3QgYXZhaWxhYmxlLiBwbGVhc2Ugc2VsZWN0IHlvdXIgYXZkIG5hbWUgZnJvbSBvbmUgb2YgdGhlc2U6ICcke2V4aXN0aW5nc30nYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZW11bGF0b3IgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsyMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JFbXVsYXRvclJlYWR5ID0gYXN5bmMgZnVuY3Rpb24gKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZyhcIldhaXRpbmcgdW50aWwgZW11bGF0b3IgaXMgcmVhZHlcIik7XG4gIHdoaWxlICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA8IHRpbWVvdXRNcykge1xuICAgIHRyeSB7XG4gICAgICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChbXCJnZXRwcm9wXCIsIFwiaW5pdC5zdmMuYm9vdGFuaW1cIl0pO1xuICAgICAgaWYgKHN0ZG91dC5pbmRleE9mKCdzdG9wcGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICBhd2FpdCBzbGVlcCgzMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0VtdWxhdG9yIG5vdCByZWFkeScpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBkZXZpY2UgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0IFszMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckRldmljZSA9IGFzeW5jIGZ1bmN0aW9uIChhcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSAzMCkge1xuICB0aGlzLmFwcERldmljZVJlYWR5VGltZW91dCA9IGFwcERldmljZVJlYWR5VGltZW91dDtcbiAgY29uc3QgcmV0cmllcyA9IDM7XG4gIGNvbnN0IHRpbWVvdXQgPSBwYXJzZUludCh0aGlzLmFwcERldmljZVJlYWR5VGltZW91dCwgMTApIC8gcmV0cmllcyAqIDEwMDA7XG4gIGF3YWl0IHJldHJ5KHJldHJpZXMsIGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5hZGJFeGVjKCd3YWl0LWZvci1kZXZpY2UnLCB7dGltZW91dH0pO1xuICAgICAgYXdhaXQgdGhpcy5waW5nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gd2FpdGluZyBmb3IgZGV2aWNlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfScuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGBSZXRyeWluZyBieSByZXN0YXJ0aW5nIEFEQmApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYm9vdCB0aGUgY3VycmVudCBkZXZpY2UgYW5kIHdhaXQgdW50aWwgaXQgaXMgY29tcGxldGVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyaWVzIFtERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFU10gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVib290IHJldHJpZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRldmljZSBmYWlsZWQgdG8gcmVib290IGFuZCBudW1iZXIgb2YgcmV0cmllcyBpcyBleGNlZWRlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVib290ID0gYXN5bmMgZnVuY3Rpb24gKHJldHJpZXMgPSBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUykge1xuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RvcCddKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdtdXN0IGJlIHJvb3QnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBkZXZpY2UgbmVlZHMgYWRiIHRvIGJlIHJ1bm5pbmcgYXMgcm9vdCB0byBzdG9wLlxuICAgICAgLy8gc28gdHJ5IHRvIHJlc3RhcnQgdGhlIGRhZW1vblxuICAgICAgbG9nLmRlYnVnKCdEZXZpY2UgcmVxdWlyZXMgYWRiIHRvIGJlIHJ1bm5pbmcgYXMgcm9vdCBpbiBvcmRlciB0byByZWJvb3QuIFJlc3RhcnRpbmcgZGFlbW9uJyk7XG4gICAgICBhd2FpdCB0aGlzLnJvb3QoKTtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10pO1xuICAgIH1cbiAgICBhd2FpdCBCLmRlbGF5KDIwMDApOyAvLyBsZXQgdGhlIGVtdSBmaW5pc2ggc3RvcHBpbmc7XG4gICAgYXdhaXQgdGhpcy5zZXREZXZpY2VQcm9wZXJ0eSgnc3lzLmJvb3RfY29tcGxldGVkJywgMCk7XG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0YXJ0J10pO1xuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwocmV0cmllcywgMTAwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IGJvb3RlZCA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcpO1xuICAgICAgaWYgKGJvb3RlZCA9PT0gJzEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHN0YWNrIHRyYWNlLCBzbyBubyBsb2cuZXJyb3JBbmRUaHJvd1xuICAgICAgICBsZXQgbXNnID0gJ1dhaXRpbmcgZm9yIHJlYm9vdC4gVGhpcyB0YWtlcyB0aW1lJztcbiAgICAgICAgbG9nLmRlYnVnKG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IHRoaXMudW5yb290KCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgdG8gcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bCBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgaWYgdGhlIHN3aXRjaCBmYWlsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJvb3QgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWydyb290J10pO1xuXG4gICAgLy8gb24gcmVhbCBkZXZpY2VzIGluIHNvbWUgc2l0dWF0aW9ucyB3ZSBnZXQgYW4gZXJyb3IgaW4gdGhlIHN0ZG91dFxuICAgIGlmIChzdGRvdXQgJiYgc3Rkb3V0LmluZGV4T2YoJ2FkYmQgY2Fubm90IHJ1biBhcyByb290JykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3Rkb3V0LnRyaW0oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gcm9vdCBhZGIgZGFlbW9uOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIG5vbi1yb290IG1vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvZiB0aGUgc3dpdGNoIHdhcyBzdWNjZXNzZnVsIG9yIGZhbHNlXG4gKiAgICAgICAgICAgICAgICAgICBpZiB0aGUgc3dpdGNoIGZhaWxlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMudW5yb290ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsndW5yb290J10pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHVucm9vdCBhZGIgZGFlbW9uOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmeSB3aGV0aGVyIGEgcmVtb3RlIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB2ZXJpZnkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlRXhpc3RzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoKTtcbiAgcmV0dXJuIGZpbGVzLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdChcIlxcblwiKTtcbiAgICByZXR1cm4gbGluZXMubWFwKChsKSA9PiBsLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgIC5maWx0ZXIoKGwpID0+IGwuaW5kZXhPZihcIk5vIHN1Y2ggZmlsZVwiKSA9PT0gLTEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScpID09PSAtMSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSBwYXJ0aWN1bGFyIGZpbGUgbG9jYXRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdGhlIGZpbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEZpbGUgc2l6ZSBpbiBieXRlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gZmlsZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZVNpemUgPSBhc3luYyBmdW5jdGlvbiAocmVtb3RlUGF0aCkge1xuICB0cnkge1xuICAgIGxldCBmaWxlcyA9IGF3YWl0IHRoaXMubHMocmVtb3RlUGF0aCwgWyctbGEnXSk7XG4gICAgaWYgKGZpbGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZW1vdGUgcGF0aCBpcyBub3QgYSBmaWxlYCk7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvZk9zNFA0LzNcbiAgICBsZXQgbWF0Y2ggPSAvXFxzKFxcZCspXFxzK1xcZHs0fS1cXGR7Mn0tXFxkezJ9Ly5leGVjKGZpbGVzWzBdKTtcbiAgICBpZiAoIW1hdGNoIHx8IF8uaXNOYU4ocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHNpemUgZnJvbSBsaXN0IG91dHB1dDogJyR7ZmlsZXNbMF19J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGZpbGUgc2l6ZSBmb3IgJyR7cmVtb3RlUGF0aH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
