'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _appiumBaseDriver = require('appium-base-driver');

var _appiumSupport = require('appium-support');

var _appiumIosDriver = require('appium-ios-driver');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var helpers = {},
    extensions = {},
    commands = {};

commands.moveTo = _appiumIosDriver.iosCommands.gesture.moveTo;

commands.mobileShake = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.isSimulator()) {
          context$1$0.next = 2;
          break;
        }

        throw new _appiumBaseDriver.errors.UnknownError('Shake is not supported on real devices');

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.opts.device.shake());

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.click = function callee$0$0(el) {
  var atomsElement;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.isWebContext()) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.nativeClick(el));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        el = _appiumSupport.util.unwrapElement(el);
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.settings.getSettings());

      case 7:
        if (!context$1$0.sent.nativeWebTap) {
          context$1$0.next = 13;
          break;
        }

        // atoms-based clicks don't always work in safari 7
        _logger2['default'].debug('Using native web tap');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.nativeWebTap(el));

      case 11:
        context$1$0.next = 17;
        break;

      case 13:
        atomsElement = this.useAtomsElement(el);
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.executeAtom('click', [atomsElement]));

      case 16:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function gesturesChainToString(gestures) {
  var keysToInclude = arguments.length <= 1 || arguments[1] === undefined ? ['options'] : arguments[1];

  return gestures.map(function (item) {
    var otherKeys = _lodash2['default'].difference(_lodash2['default'].keys(item), ['action']);
    otherKeys = _lodash2['default'].isArray(keysToInclude) ? _lodash2['default'].intersection(otherKeys, keysToInclude) : otherKeys;
    if (otherKeys.length) {
      return '' + item.action + ('(' + _lodash2['default'].map(otherKeys, function (x) {
        return x + '=' + (_lodash2['default'].isPlainObject(item[x]) ? JSON.stringify(item[x]) : item[x]);
      }).join(', ') + ')');
    }
    return item.action;
  }).join('-');
}

commands.performActions = function callee$0$0(actions) {
  var preprocessedActions;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Received the following W3C actions: ' + JSON.stringify(actions, null, '  '));
        // This is mandatory, since WDA only supports TOUCH pointer type
        // and Selenium API uses MOUSE as the default one
        preprocessedActions = actions.map(function (action) {
          return _Object$assign({}, action, action.type === 'pointer' ? {
            parameters: {
              pointerType: 'touch'
            }
          } : {});
        });

        _logger2['default'].debug('Preprocessed actions: ' + JSON.stringify(preprocessedActions, null, '  '));
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.proxyCommand('/actions', 'POST', { actions: preprocessedActions }));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.performTouch = function callee$0$0(gestures) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Received the following touch action: ' + gesturesChainToString(gestures));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/touch/perform', 'POST', { actions: gestures }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.performMultiAction = function callee$0$0(actions) {
  var i;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Received the following multi touch action:');
        for (i in actions) {
          _logger2['default'].debug('    ' + (i + 1) + ': ' + _lodash2['default'].map(actions[i], 'action').join('-'));
        }
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/touch/multi/perform', 'POST', { actions: actions }));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.nativeClick = function callee$0$0(el) {
  var endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = _appiumSupport.util.unwrapElement(el);
        endpoint = '/element/' + el + '/click';
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', {}));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleScroll = function callee$0$0(gestures) {
  var dragGestures;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!gestures[1].options.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.mobileScroll({
          element: gestures[1].options.element,
          toVisible: true
        }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        dragGestures = [gestures[0], { action: 'wait', options: { ms: 0 } }, gestures[1], gestures[2]];
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.handleDrag(dragGestures));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleDrag = function callee$0$0(gestures) {
  var press, wait, moveTo, pressCoordinates, duration, moveToCoordinates, params, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        press = undefined, wait = undefined, moveTo = undefined;

        if (gestures[0].action === 'longpress') {
          press = gestures[0];
          wait = { action: 'wait', options: { ms: press.options.duration } };
          moveTo = gestures[1];
        } else {
          press = gestures[0];
          wait = gestures[1];
          moveTo = gestures[2];
        }

        // get drag data
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getCoordinates(press));

      case 4:
        pressCoordinates = context$1$0.sent;
        duration = parseInt(wait.options.ms, 10) / 1000;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getCoordinates(moveTo));

      case 8:
        moveToCoordinates = context$1$0.sent;

        // update moveTo coordinates with offset
        moveToCoordinates = this.applyMoveToOffset(pressCoordinates, moveToCoordinates);

        // build drag command
        params = {};

        params.fromX = pressCoordinates.x;
        params.fromY = pressCoordinates.y;
        params.toX = moveToCoordinates.x;
        params.toY = moveToCoordinates.y;
        params.duration = duration;

        endpoint = '/wda/dragfromtoforduration';
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 19:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleTap = function callee$0$0(gesture) {
  var options, params, el, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        options = gesture.options || {};
        params = {};

        if (_appiumSupport.util.hasValue(options.x) && _appiumSupport.util.hasValue(options.y)) {
          params.x = options.x;
          params.y = options.y;
        }

        el = _appiumSupport.util.hasValue(options.element) ? options.element : '0';
        endpoint = '/wda/tap/' + el;

        if (_appiumSupport.util.hasValue(this.opts.tapWithShortPressDuration)) {
          // in some cases `tap` is too slow, so allow configurable long press
          _logger2['default'].debug('Translating tap into long press with \'' + this.opts.tapWithShortPressDuration + '\' duration');
          params.duration = parseFloat(this.opts.tapWithShortPressDuration);
          endpoint = '/wda/element/' + el + '/touchAndHold';
          params.duration = parseFloat(this.opts.tapWithShortPressDuration);
        }

        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleDoubleTap = function callee$0$0(gestures) {
  var gesture, opts, el, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        gesture = gestures[0];
        opts = gesture.options || {};

        if (!opts.element) {
          _logger2['default'].errorAndThrow('WDA double tap needs an element');
        }

        el = _appiumSupport.util.unwrapElement(opts.element);
        endpoint = '/wda/element/' + el + '/doubleTap';
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST'));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.handleLongPress = function callee$0$0(gestures) {
  var pressOpts, el, duration, params, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        pressOpts = _lodash2['default'].isPlainObject(gestures[0].options) ? gestures[0].options : {};
        el = _appiumSupport.util.unwrapElement(pressOpts.element);
        duration = undefined;
        // In seconds (not milliseconds)
        if (_appiumSupport.util.hasValue(pressOpts.duration)) {
          duration = pressOpts.duration / 1000;
        } else if (gestures.length === 3 && gestures[1].action === 'wait') {
          // duration is the `wait` action
          // upstream system expects seconds not milliseconds
          duration = parseFloat(gestures[1].options.ms) / 1000;
        } else {
          // give a sane default duration
          duration = 0.8;
        }

        params = {
          duration: duration,
          x: pressOpts.x,
          y: pressOpts.y
        };
        endpoint = undefined;

        if (el) {
          endpoint = '/wda/element/' + el + '/touchAndHold';
        } else {
          params.x = pressOpts.x;
          params.y = pressOpts.y;

          endpoint = '/wda/touchAndHold';
        }
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function determinePinchScale(x, y, pinch) {
  var scale = x > y ? x - y : y - x;
  if (pinch) {
    // TODO: revisit this when pinching actually works, since it is impossible to
    // know what the scale factor does at this point (Xcode 8.1)
    scale = 1 / scale;
    if (scale < 0.02) {
      // this is the minimum that Apple will allow
      // but WDA will not throw an error if it is too low
      scale = 0.02;
    }
  } else {
    // for zoom, each 10px is one scale factor
    scale = scale / 10;
  }
  return scale;
}

helpers.handlePinchOrZoom = function callee$0$0(actions) {
  var el, scale, velocity, thumb, forefinger, params;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // currently we can only do this action on an element
        if (!actions[0][0].options.element || actions[0][0].options.element !== actions[1][0].options.element) {
          _logger2['default'].errorAndThrow('Pinch/zoom actions must be done on a single element');
        }
        el = actions[0][0].options.element;
        scale = undefined, velocity = undefined;

        if (actions[0][0].options.y === actions[0][1].options.y) {
          thumb = actions[0][0].options.x <= actions[1][0].options.x ? actions[0] : actions[1];

          // now decipher pinch vs. zoom,
          //   pinch: thumb moving from left to right
          //   zoom: thumb moving from right to left
          scale = determinePinchScale(thumb[0].options.x, thumb[1].options.x, thumb[0].options.x <= thumb[1].options.x);
        } else {
          forefinger = actions[0][0].options.y <= actions[1][0].options.y ? actions[0] : actions[1];

          // now decipher pinch vs. zoom
          //   pinch: forefinger moving from top to bottom
          //   zoom: forefinger moving from bottom to top
          scale = determinePinchScale(forefinger[0].options.y, forefinger[1].options.y, forefinger[0].options.y <= forefinger[1].options.y);
        }
        velocity = scale < 1 ? -1 : 1;

        _logger2['default'].debug('Decoded ' + (scale < 1 ? 'pinch' : 'zoom') + ' action with scale \'' + scale + '\' and velocity \'' + velocity + '\'');
        if (scale < 1) {
          _logger2['default'].warn('Pinch actions may not work, due to Apple issue.');
        }

        params = {
          scale: scale,
          velocity: velocity
        };
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/pinch', 'POST', params));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/*
 * See https://github.com/facebook/WebDriverAgent/blob/master/WebDriverAgentLib/Commands/FBElementCommands.m
 * to get the info about available WDA gestures API
 *
 * See https://developer.apple.com/reference/xctest/xcuielement and
 * https://developer.apple.com/reference/xctest/xcuicoordinate to get the detailed description of
 * all XCTest gestures
*/

helpers.mobileScroll = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var swipe = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var params, msg, element, endpoint;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (opts.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findNativeElementOrElements('class name', 'XCUIElementTypeApplication', false));

      case 3:
        opts.element = context$1$0.sent;

      case 4:
        params = {};

        if (opts.name && !swipe) {
          params.name = opts.name;
        } else if (opts.direction) {
          if (['up', 'down', 'left', 'right'].indexOf(opts.direction.toLowerCase()) < 0) {
            msg = 'Direction must be up, down, left or right';

            _logger2['default'].errorAndThrow(msg);
          }
          params.direction = opts.direction;
        } else if (opts.predicateString && !swipe) {
          params.predicateString = opts.predicateString;
        } else if (opts.toVisible && !swipe) {
          params.toVisible = opts.toVisible;
        } else {
          msg = swipe ? 'Mobile swipe requires direction' : 'Mobile scroll supports the following strategies: name, direction, predicateString, and toVisible. Specify one of these';

          _logger2['default'].errorAndThrow(msg);
        }

        // we can also optionally pass a distance which appears to be a ratio of
        // screen height, so 1.0 means a full screen's worth of scrolling
        if (!swipe && opts.distance) {
          params.distance = opts.distance;
        }

        element = opts.element.ELEMENT || opts.element;
        endpoint = '/wda/element/' + element + '/' + (swipe ? 'swipe' : 'scroll');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.proxyCommand(endpoint, 'POST', params));

      case 11:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileSwipe = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.mobileScroll(opts, true));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

function parseFloatParameter(paramName, paramValue, methodName) {
  if (_lodash2['default'].isUndefined(paramValue)) {
    _logger2['default'].errorAndThrow('"' + paramName + '" parameter is mandatory for "' + methodName + '" call');
  }
  var result = parseFloat(paramValue);
  if (isNaN(result)) {
    _logger2['default'].errorAndThrow('"' + paramName + '" parameter should be a valid number. "' + paramValue + '" is given instead');
  }
  return result;
}

helpers.mobilePinch = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (opts.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findNativeElementOrElements('class name', 'XCUIElementTypeApplication', false));

      case 3:
        opts.element = context$1$0.sent;

      case 4:
        params = {
          scale: parseFloatParameter('scale', opts.scale, 'pinch'),
          velocity: parseFloatParameter('velocity', opts.velocity, 'pinch')
        };
        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/pinch', 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileDoubleTap = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var el, params;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!opts.element) {
          context$1$0.next = 5;
          break;
        }

        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/doubleTap', 'POST'));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
        params = {
          x: parseFloatParameter('x', opts.x, 'doubleTap'),
          y: parseFloatParameter('y', opts.y, 'doubleTap')
        };
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/doubleTap', 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileTwoFingerTap = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (opts.element) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findNativeElementOrElements('class name', 'XCUIElementTypeApplication', false));

      case 3:
        opts.element = context$1$0.sent;

      case 4:
        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/twoFingerTap', 'POST'));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileTouchAndHold = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        params = {
          duration: parseFloatParameter('duration', opts.duration, 'touchAndHold')
        };

        if (!opts.element) {
          context$1$0.next = 6;
          break;
        }

        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/touchAndHold', 'POST', params));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        // Long tap coordinates
        params.x = parseFloatParameter('x', opts.x, 'touchAndHold');
        params.y = parseFloatParameter('y', opts.y, 'touchAndHold');
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/touchAndHold', 'POST', params));

      case 10:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileTap = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        params = {
          x: parseFloatParameter('x', opts.x, 'tap'),
          y: parseFloatParameter('y', opts.y, 'tap')
        };
        el = opts.element ? opts.element.ELEMENT || opts.element : '0';
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/tap/' + el, 'POST', params));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileDragFromToForDuration = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var params, el;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        params = {
          duration: parseFloatParameter('duration', opts.duration, 'dragFromToForDuration'),
          fromX: parseFloatParameter('fromX', opts.fromX, 'dragFromToForDuration'),
          fromY: parseFloatParameter('fromY', opts.fromY, 'dragFromToForDuration'),
          toX: parseFloatParameter('toX', opts.toX, 'dragFromToForDuration'),
          toY: parseFloatParameter('toY', opts.toY, 'dragFromToForDuration')
        };

        if (!opts.element) {
          context$1$0.next = 6;
          break;
        }

        el = opts.element.ELEMENT || opts.element;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/element/' + el + '/dragfromtoforduration', 'POST', params));

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/dragfromtoforduration', 'POST', params));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.mobileSelectPickerWheelValue = function callee$0$0() {
  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var el, params;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!opts.element) {
          _logger2['default'].errorAndThrow('Element id is expected to be set for selectPickerWheelValue method');
        }
        if (!_lodash2['default'].isString(opts.order) || ['next', 'previous'].indexOf(opts.order.toLowerCase()) === -1) {
          _logger2['default'].errorAndThrow('The mandatory "order" parameter is expected to be equal either to \'next\' or \'previous\'. ' + ('\'' + opts.order + '\' is given instead'));
        }
        el = opts.element.ELEMENT || opts.element;
        params = { order: opts.order };

        if (opts.offset) {
          params.offset = parseFloatParameter('offset', opts.offset, 'selectPickerWheelValue');
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.proxyCommand('/wda/pickerwheel/' + el + '/select', 'POST', params));

      case 7:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.getCoordinates = function callee$0$0(gesture) {
  var el, coordinates, optionX, optionY, rect, pos, size, offsetX, offsetY;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        el = gesture.options.element;
        coordinates = { x: 0, y: 0, areOffsets: false };
        optionX = null;

        if (gesture.options.x) {
          optionX = parseFloatParameter('x', gesture.options.x, 'getCoordinates');
        }
        optionY = null;

        if (gesture.options.y) {
          optionY = parseFloatParameter('y', gesture.options.y, 'getCoordinates');
        }

        // figure out the element coordinates.

        if (!el) {
          context$1$0.next = 19;
          break;
        }

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.getRect(el));

      case 9:
        rect = context$1$0.sent;
        pos = { x: rect.x, y: rect.y };
        size = { w: rect.width, h: rect.height };
        offsetX = 0;
        offsetY = 0;

        // get the real offsets
        if (optionX || optionY) {
          offsetX = optionX || 0;
          offsetY = optionY || 0;
        } else {
          offsetX = size.w / 2;
          offsetY = size.h / 2;
        }

        // apply the offsets
        coordinates.x = pos.x + offsetX;
        coordinates.y = pos.y + offsetY;
        context$1$0.next = 22;
        break;

      case 19:
        // moveTo coordinates are passed in as offsets
        coordinates.areOffsets = gesture.action === 'moveTo';
        coordinates.x = optionX || 0;
        coordinates.y = optionY || 0;

      case 22:
        return context$1$0.abrupt('return', coordinates);

      case 23:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

helpers.applyMoveToOffset = function (firstCoordinates, secondCoordinates) {
  if (secondCoordinates.areOffsets) {
    return {
      x: firstCoordinates.x + secondCoordinates.x,
      y: firstCoordinates.y + secondCoordinates.y
    };
  } else {
    return secondCoordinates;
  }
};

_Object$assign(extensions, helpers, commands);
exports.extensions = extensions;
exports.helpers = helpers;
exports.commands = commands;
exports.gesturesChainToString = gesturesChainToString;
exports['default'] = extensions;

// there are multiple commands that map here, so manually proxy

// use the to-visible option of scrolling in WDA

// otherwise, for now, just translate into a drag with short duration

// assume that action is in a single plane (x or y, not horizontal at all)
// terminology all assuming right handedness

// horizontal, since y offset is the same in press and moveTo

// vertical

// WDA supports four scrolling strategies: predication based on name, direction,
// predicateString, and toVisible, in that order. Swiping requires direction.

// Double tap element

// Double tap coordinates

// Long tap element

// Drag element

// Drag coordinates

// defaults

// defaults
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9nZXN0dXJlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztnQ0FBdUIsb0JBQW9COzs2QkFDdEIsZ0JBQWdCOzsrQkFDVCxtQkFBbUI7O3NCQUNqQyxRQUFROzs7O3NCQUNOLFdBQVc7Ozs7QUFHM0IsSUFBSSxPQUFPLEdBQUcsRUFBRTtJQUFFLFVBQVUsR0FBRyxFQUFFO0lBQUUsUUFBUSxHQUFHLEVBQUUsQ0FBQzs7QUFFakQsUUFBUSxDQUFDLE1BQU0sR0FBRyw2QkFBWSxPQUFPLENBQUMsTUFBTSxDQUFDOztBQUU3QyxRQUFRLENBQUMsV0FBVyxHQUFHOzs7O1lBQ2hCLElBQUksQ0FBQyxXQUFXLEVBQUU7Ozs7O2NBQ2YsSUFBSSx5QkFBTyxZQUFZLENBQUMsd0NBQXdDLENBQUM7Ozs7eUNBRW5FLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRTs7Ozs7OztDQUMvQixDQUFDOztBQUVGLFFBQVEsQ0FBQyxLQUFLLEdBQUcsb0JBQWdCLEVBQUU7TUFXM0IsWUFBWTs7OztZQVZiLElBQUksQ0FBQyxZQUFZLEVBQUU7Ozs7Ozt5Q0FFVCxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQzs7Ozs7O0FBRW5DLFVBQUUsR0FBRyxvQkFBSyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7O3lDQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRTs7OzhCQUFFLFlBQVk7Ozs7OztBQUVsRCw0QkFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7eUNBQzVCLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDOzs7Ozs7O0FBRXZCLG9CQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUM7O3lDQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7Ozs7O0NBRXpELENBQUM7O0FBRUYsU0FBUyxxQkFBcUIs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QUFpQixDQUFDLFVBQVUsRUFBRTtBQUNoQyxXQUFPO0FBQ0wsT0FBQyxFQUFFLGdCQUFnQixDQUFDLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzNDLE9BQUMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsQ0FBQztLQUM1QyxDQUFDO0dBQ0gsTUFBTTtBQUNMLFdBQU8saUJBQWlCLENBQUM7R0FDMUI7Q0FDRixDQUFDOztBQUVGLGVBQWMsVUFBVSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNwQyxVQUFVLEdBQVYsVUFBVTtRQUFFLE9BQU8sR0FBUCxPQUFPO1FBQUUsUUFBUSxHQUFSLFFBQVE7UUFBRSxxQkFBcUIsR0FBckIscUJBQXFCO3FCQUM5QyxVQUFVIiwiZmlsZSI6ImxpYi9jb21tYW5kcy9nZXN0dXJlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXJyb3JzIH0gZnJvbSAnYXBwaXVtLWJhc2UtZHJpdmVyJztcbmltcG9ydCB7IHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBpb3NDb21tYW5kcyB9IGZyb20gJ2FwcGl1bS1pb3MtZHJpdmVyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5cblxubGV0IGhlbHBlcnMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9LCBjb21tYW5kcyA9IHt9O1xuXG5jb21tYW5kcy5tb3ZlVG8gPSBpb3NDb21tYW5kcy5nZXN0dXJlLm1vdmVUbztcblxuY29tbWFuZHMubW9iaWxlU2hha2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1NpbXVsYXRvcigpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5Vbmtub3duRXJyb3IoJ1NoYWtlIGlzIG5vdCBzdXBwb3J0ZWQgb24gcmVhbCBkZXZpY2VzJyk7XG4gIH1cbiAgYXdhaXQgdGhpcy5vcHRzLmRldmljZS5zaGFrZSgpO1xufTtcblxuY29tbWFuZHMuY2xpY2sgPSBhc3luYyBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCF0aGlzLmlzV2ViQ29udGV4dCgpKSB7XG4gICAgLy8gdGhlcmUgYXJlIG11bHRpcGxlIGNvbW1hbmRzIHRoYXQgbWFwIGhlcmUsIHNvIG1hbnVhbGx5IHByb3h5XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubmF0aXZlQ2xpY2soZWwpO1xuICB9XG4gIGVsID0gdXRpbC51bndyYXBFbGVtZW50KGVsKTtcbiAgaWYgKChhd2FpdCB0aGlzLnNldHRpbmdzLmdldFNldHRpbmdzKCkpLm5hdGl2ZVdlYlRhcCkge1xuICAgIC8vIGF0b21zLWJhc2VkIGNsaWNrcyBkb24ndCBhbHdheXMgd29yayBpbiBzYWZhcmkgN1xuICAgIGxvZy5kZWJ1ZygnVXNpbmcgbmF0aXZlIHdlYiB0YXAnKTtcbiAgICBhd2FpdCB0aGlzLm5hdGl2ZVdlYlRhcChlbCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGF0b21zRWxlbWVudCA9IHRoaXMudXNlQXRvbXNFbGVtZW50KGVsKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlQXRvbSgnY2xpY2snLCBbYXRvbXNFbGVtZW50XSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdlc3R1cmVzQ2hhaW5Ub1N0cmluZyAoZ2VzdHVyZXMsIGtleXNUb0luY2x1ZGUgPSBbJ29wdGlvbnMnXSkge1xuICByZXR1cm4gZ2VzdHVyZXMubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IG90aGVyS2V5cyA9IF8uZGlmZmVyZW5jZShfLmtleXMoaXRlbSksIFsnYWN0aW9uJ10pO1xuICAgIG90aGVyS2V5cyA9IF8uaXNBcnJheShrZXlzVG9JbmNsdWRlKSA/IF8uaW50ZXJzZWN0aW9uKG90aGVyS2V5cywga2V5c1RvSW5jbHVkZSkgOiBvdGhlcktleXM7XG4gICAgaWYgKG90aGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBgJHtpdGVtLmFjdGlvbn1gICtcbiAgICAgICAgYCgke18ubWFwKG90aGVyS2V5cywgKHgpID0+IHggKyAnPScgKyAoXy5pc1BsYWluT2JqZWN0KGl0ZW1beF0pID8gSlNPTi5zdHJpbmdpZnkoaXRlbVt4XSkgOiBpdGVtW3hdKSkuam9pbignLCAnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0uYWN0aW9uO1xuICB9KS5qb2luKCctJyk7XG59XG5cbmNvbW1hbmRzLnBlcmZvcm1BY3Rpb25zID0gYXN5bmMgZnVuY3Rpb24gKGFjdGlvbnMpIHtcbiAgbG9nLmRlYnVnKGBSZWNlaXZlZCB0aGUgZm9sbG93aW5nIFczQyBhY3Rpb25zOiAke0pTT04uc3RyaW5naWZ5KGFjdGlvbnMsIG51bGwsICcgICcpfWApO1xuICAvLyBUaGlzIGlzIG1hbmRhdG9yeSwgc2luY2UgV0RBIG9ubHkgc3VwcG9ydHMgVE9VQ0ggcG9pbnRlciB0eXBlXG4gIC8vIGFuZCBTZWxlbml1bSBBUEkgdXNlcyBNT1VTRSBhcyB0aGUgZGVmYXVsdCBvbmVcbiAgY29uc3QgcHJlcHJvY2Vzc2VkQWN0aW9ucyA9IGFjdGlvbnNcbiAgICAubWFwKChhY3Rpb24pID0+IE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiwgYWN0aW9uLnR5cGUgPT09ICdwb2ludGVyJyA/IHtcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgcG9pbnRlclR5cGU6ICd0b3VjaCdcbiAgICAgIH1cbiAgICB9IDoge30pKTtcbiAgbG9nLmRlYnVnKGBQcmVwcm9jZXNzZWQgYWN0aW9uczogJHtKU09OLnN0cmluZ2lmeShwcmVwcm9jZXNzZWRBY3Rpb25zLCBudWxsLCAnICAnKX1gKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKCcvYWN0aW9ucycsICdQT1NUJywge2FjdGlvbnM6IHByZXByb2Nlc3NlZEFjdGlvbnN9KTtcbn07XG5cbmNvbW1hbmRzLnBlcmZvcm1Ub3VjaCA9IGFzeW5jIGZ1bmN0aW9uIChnZXN0dXJlcykge1xuICBsb2cuZGVidWcoYFJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdG91Y2ggYWN0aW9uOiAke2dlc3R1cmVzQ2hhaW5Ub1N0cmluZyhnZXN0dXJlcyl9YCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZCgnL3dkYS90b3VjaC9wZXJmb3JtJywgJ1BPU1QnLCB7YWN0aW9uczogZ2VzdHVyZXN9KTtcbn07XG5cbmNvbW1hbmRzLnBlcmZvcm1NdWx0aUFjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIChhY3Rpb25zKSB7XG4gIGxvZy5kZWJ1ZyhgUmVjZWl2ZWQgdGhlIGZvbGxvd2luZyBtdWx0aSB0b3VjaCBhY3Rpb246YCk7XG4gIGZvciAobGV0IGkgaW4gYWN0aW9ucykge1xuICAgIGxvZy5kZWJ1ZyhgICAgICR7aSsxfTogJHtfLm1hcChhY3Rpb25zW2ldLCAnYWN0aW9uJykuam9pbignLScpfWApO1xuICB9XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZCgnL3dkYS90b3VjaC9tdWx0aS9wZXJmb3JtJywgJ1BPU1QnLCB7YWN0aW9uc30pO1xufTtcblxuY29tbWFuZHMubmF0aXZlQ2xpY2sgPSBhc3luYyBmdW5jdGlvbiAoZWwpIHtcbiAgZWwgPSB1dGlsLnVud3JhcEVsZW1lbnQoZWwpO1xuICBsZXQgZW5kcG9pbnQgPSBgL2VsZW1lbnQvJHtlbH0vY2xpY2tgO1xuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoZW5kcG9pbnQsICdQT1NUJywge30pO1xufTtcblxuaGVscGVycy5oYW5kbGVTY3JvbGwgPSBhc3luYyBmdW5jdGlvbiAoZ2VzdHVyZXMpIHtcbiAgaWYgKGdlc3R1cmVzWzFdLm9wdGlvbnMuZWxlbWVudCkge1xuICAgIC8vIHVzZSB0aGUgdG8tdmlzaWJsZSBvcHRpb24gb2Ygc2Nyb2xsaW5nIGluIFdEQVxuICAgIHJldHVybiBhd2FpdCB0aGlzLm1vYmlsZVNjcm9sbCh7XG4gICAgICBlbGVtZW50OiBnZXN0dXJlc1sxXS5vcHRpb25zLmVsZW1lbnQsXG4gICAgICB0b1Zpc2libGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgZm9yIG5vdywganVzdCB0cmFuc2xhdGUgaW50byBhIGRyYWcgd2l0aCBzaG9ydCBkdXJhdGlvblxuICBsZXQgZHJhZ0dlc3R1cmVzID0gW1xuICAgIGdlc3R1cmVzWzBdLFxuICAgIHthY3Rpb246ICd3YWl0Jywgb3B0aW9uczoge21zOiAwfX0sXG4gICAgZ2VzdHVyZXNbMV0sXG4gICAgZ2VzdHVyZXNbMl1cbiAgXTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlRHJhZyhkcmFnR2VzdHVyZXMpO1xufTtcblxuaGVscGVycy5oYW5kbGVEcmFnID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmVzKSB7XG4gIGxldCBwcmVzcywgd2FpdCwgbW92ZVRvO1xuICBpZiAoZ2VzdHVyZXNbMF0uYWN0aW9uID09PSAnbG9uZ3ByZXNzJykge1xuICAgIHByZXNzID0gZ2VzdHVyZXNbMF07XG4gICAgd2FpdCA9IHthY3Rpb246ICd3YWl0Jywgb3B0aW9uczoge21zOiBwcmVzcy5vcHRpb25zLmR1cmF0aW9ufX07XG4gICAgbW92ZVRvID0gZ2VzdHVyZXNbMV07XG4gIH0gZWxzZSB7XG4gICAgcHJlc3MgPSBnZXN0dXJlc1swXTtcbiAgICB3YWl0ID0gZ2VzdHVyZXNbMV07XG4gICAgbW92ZVRvID0gZ2VzdHVyZXNbMl07XG4gIH1cblxuICAvLyBnZXQgZHJhZyBkYXRhXG4gIGxldCBwcmVzc0Nvb3JkaW5hdGVzID0gYXdhaXQgdGhpcy5nZXRDb29yZGluYXRlcyhwcmVzcyk7XG4gIGxldCBkdXJhdGlvbiA9IChwYXJzZUludCh3YWl0Lm9wdGlvbnMubXMsIDEwKSAvIDEwMDApO1xuICBsZXQgbW92ZVRvQ29vcmRpbmF0ZXMgPSBhd2FpdCB0aGlzLmdldENvb3JkaW5hdGVzKG1vdmVUbyk7XG5cbiAgLy8gdXBkYXRlIG1vdmVUbyBjb29yZGluYXRlcyB3aXRoIG9mZnNldFxuICBtb3ZlVG9Db29yZGluYXRlcyA9IHRoaXMuYXBwbHlNb3ZlVG9PZmZzZXQocHJlc3NDb29yZGluYXRlcywgbW92ZVRvQ29vcmRpbmF0ZXMpO1xuXG4gIC8vIGJ1aWxkIGRyYWcgY29tbWFuZFxuICBsZXQgcGFyYW1zID0ge307XG4gIHBhcmFtcy5mcm9tWCA9IHByZXNzQ29vcmRpbmF0ZXMueDtcbiAgcGFyYW1zLmZyb21ZID0gcHJlc3NDb29yZGluYXRlcy55O1xuICBwYXJhbXMudG9YID0gbW92ZVRvQ29vcmRpbmF0ZXMueDtcbiAgcGFyYW1zLnRvWSA9IG1vdmVUb0Nvb3JkaW5hdGVzLnk7XG4gIHBhcmFtcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG4gIGxldCBlbmRwb2ludCA9IGAvd2RhL2RyYWdmcm9tdG9mb3JkdXJhdGlvbmA7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChlbmRwb2ludCwgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuaGVscGVycy5oYW5kbGVUYXAgPSBhc3luYyBmdW5jdGlvbiAoZ2VzdHVyZSkge1xuICBsZXQgb3B0aW9ucyA9IGdlc3R1cmUub3B0aW9ucyB8fCB7fTtcblxuICBsZXQgcGFyYW1zID0ge307XG4gIGlmICh1dGlsLmhhc1ZhbHVlKG9wdGlvbnMueCkgJiYgdXRpbC5oYXNWYWx1ZShvcHRpb25zLnkpKSB7XG4gICAgcGFyYW1zLnggPSBvcHRpb25zLng7XG4gICAgcGFyYW1zLnkgPSBvcHRpb25zLnk7XG4gIH1cblxuICBsZXQgZWwgPSB1dGlsLmhhc1ZhbHVlKG9wdGlvbnMuZWxlbWVudCkgPyBvcHRpb25zLmVsZW1lbnQgOiAnMCc7XG4gIGxldCBlbmRwb2ludCA9IGAvd2RhL3RhcC8ke2VsfWA7XG5cbiAgaWYgKHV0aWwuaGFzVmFsdWUodGhpcy5vcHRzLnRhcFdpdGhTaG9ydFByZXNzRHVyYXRpb24pKSB7XG4gICAgLy8gaW4gc29tZSBjYXNlcyBgdGFwYCBpcyB0b28gc2xvdywgc28gYWxsb3cgY29uZmlndXJhYmxlIGxvbmcgcHJlc3NcbiAgICBsb2cuZGVidWcoYFRyYW5zbGF0aW5nIHRhcCBpbnRvIGxvbmcgcHJlc3Mgd2l0aCAnJHt0aGlzLm9wdHMudGFwV2l0aFNob3J0UHJlc3NEdXJhdGlvbn0nIGR1cmF0aW9uYCk7XG4gICAgcGFyYW1zLmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0aGlzLm9wdHMudGFwV2l0aFNob3J0UHJlc3NEdXJhdGlvbik7XG4gICAgZW5kcG9pbnQgPSBgL3dkYS9lbGVtZW50LyR7ZWx9L3RvdWNoQW5kSG9sZGA7XG4gICAgcGFyYW1zLmR1cmF0aW9uID0gcGFyc2VGbG9hdCh0aGlzLm9wdHMudGFwV2l0aFNob3J0UHJlc3NEdXJhdGlvbik7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoZW5kcG9pbnQsICdQT1NUJywgcGFyYW1zKTtcbn07XG5cbmhlbHBlcnMuaGFuZGxlRG91YmxlVGFwID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmVzKSB7XG4gIGxldCBnZXN0dXJlID0gZ2VzdHVyZXNbMF07XG4gIGxldCBvcHRzID0gZ2VzdHVyZS5vcHRpb25zIHx8IHt9O1xuXG4gIGlmICghb3B0cy5lbGVtZW50KSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coJ1dEQSBkb3VibGUgdGFwIG5lZWRzIGFuIGVsZW1lbnQnKTtcbiAgfVxuXG4gIGxldCBlbCA9IHV0aWwudW53cmFwRWxlbWVudChvcHRzLmVsZW1lbnQpO1xuICBsZXQgZW5kcG9pbnQgPSBgL3dkYS9lbGVtZW50LyR7ZWx9L2RvdWJsZVRhcGA7XG5cbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGVuZHBvaW50LCAnUE9TVCcpO1xufTtcblxuaGVscGVycy5oYW5kbGVMb25nUHJlc3MgPSBhc3luYyBmdW5jdGlvbiAoZ2VzdHVyZXMpIHtcbiAgbGV0IHByZXNzT3B0cyA9IF8uaXNQbGFpbk9iamVjdChnZXN0dXJlc1swXS5vcHRpb25zKSA/IGdlc3R1cmVzWzBdLm9wdGlvbnMgOiB7fTtcblxuICBsZXQgZWwgPSB1dGlsLnVud3JhcEVsZW1lbnQocHJlc3NPcHRzLmVsZW1lbnQpO1xuICBsZXQgZHVyYXRpb247IC8vIEluIHNlY29uZHMgKG5vdCBtaWxsaXNlY29uZHMpXG4gIGlmICh1dGlsLmhhc1ZhbHVlKHByZXNzT3B0cy5kdXJhdGlvbikpIHtcbiAgICBkdXJhdGlvbiA9IHByZXNzT3B0cy5kdXJhdGlvbiAvIDEwMDA7XG4gIH0gZWxzZSBpZiAoZ2VzdHVyZXMubGVuZ3RoID09PSAzICYmIGdlc3R1cmVzWzFdLmFjdGlvbiA9PT0gJ3dhaXQnKSB7XG4gICAgLy8gZHVyYXRpb24gaXMgdGhlIGB3YWl0YCBhY3Rpb25cbiAgICAvLyB1cHN0cmVhbSBzeXN0ZW0gZXhwZWN0cyBzZWNvbmRzIG5vdCBtaWxsaXNlY29uZHNcbiAgICBkdXJhdGlvbiA9IHBhcnNlRmxvYXQoZ2VzdHVyZXNbMV0ub3B0aW9ucy5tcykgLyAxMDAwO1xuICB9IGVsc2Uge1xuICAgIC8vIGdpdmUgYSBzYW5lIGRlZmF1bHQgZHVyYXRpb25cbiAgICBkdXJhdGlvbiA9IDAuODtcbiAgfVxuXG4gIGxldCBwYXJhbXMgPSB7XG4gICAgZHVyYXRpb24sXG4gICAgeDogcHJlc3NPcHRzLngsXG4gICAgeTogcHJlc3NPcHRzLnksXG4gIH07XG5cbiAgbGV0IGVuZHBvaW50O1xuICBpZiAoZWwpIHtcbiAgICBlbmRwb2ludCA9IGAvd2RhL2VsZW1lbnQvJHtlbH0vdG91Y2hBbmRIb2xkYDtcbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMueCA9IHByZXNzT3B0cy54O1xuICAgIHBhcmFtcy55ID0gcHJlc3NPcHRzLnk7XG5cbiAgICBlbmRwb2ludCA9ICcvd2RhL3RvdWNoQW5kSG9sZCc7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGVuZHBvaW50LCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVQaW5jaFNjYWxlICh4LCB5LCBwaW5jaCkge1xuICBsZXQgc2NhbGUgPSB4ID4geSA/IHggLSB5IDogeSAtIHg7XG4gIGlmIChwaW5jaCkge1xuICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHBpbmNoaW5nIGFjdHVhbGx5IHdvcmtzLCBzaW5jZSBpdCBpcyBpbXBvc3NpYmxlIHRvXG4gICAgLy8ga25vdyB3aGF0IHRoZSBzY2FsZSBmYWN0b3IgZG9lcyBhdCB0aGlzIHBvaW50IChYY29kZSA4LjEpXG4gICAgc2NhbGUgPSAxIC8gc2NhbGU7XG4gICAgaWYgKHNjYWxlIDwgMC4wMikge1xuICAgICAgLy8gdGhpcyBpcyB0aGUgbWluaW11bSB0aGF0IEFwcGxlIHdpbGwgYWxsb3dcbiAgICAgIC8vIGJ1dCBXREEgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgaXQgaXMgdG9vIGxvd1xuICAgICAgc2NhbGUgPSAwLjAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBmb3Igem9vbSwgZWFjaCAxMHB4IGlzIG9uZSBzY2FsZSBmYWN0b3JcbiAgICBzY2FsZSA9IHNjYWxlIC8gMTA7XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5oZWxwZXJzLmhhbmRsZVBpbmNoT3Jab29tID0gYXN5bmMgZnVuY3Rpb24gKGFjdGlvbnMpIHtcbiAgLy8gY3VycmVudGx5IHdlIGNhbiBvbmx5IGRvIHRoaXMgYWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgaWYgKCFhY3Rpb25zWzBdWzBdLm9wdGlvbnMuZWxlbWVudCB8fFxuICAgICAgYWN0aW9uc1swXVswXS5vcHRpb25zLmVsZW1lbnQgIT09IGFjdGlvbnNbMV1bMF0ub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coJ1BpbmNoL3pvb20gYWN0aW9ucyBtdXN0IGJlIGRvbmUgb24gYSBzaW5nbGUgZWxlbWVudCcpO1xuICB9XG4gIGxldCBlbCA9IGFjdGlvbnNbMF1bMF0ub3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGFzc3VtZSB0aGF0IGFjdGlvbiBpcyBpbiBhIHNpbmdsZSBwbGFuZSAoeCBvciB5LCBub3QgaG9yaXpvbnRhbCBhdCBhbGwpXG4gIC8vIHRlcm1pbm9sb2d5IGFsbCBhc3N1bWluZyByaWdodCBoYW5kZWRuZXNzXG4gIGxldCBzY2FsZSwgdmVsb2NpdHk7XG4gIGlmIChhY3Rpb25zWzBdWzBdLm9wdGlvbnMueSA9PT0gYWN0aW9uc1swXVsxXS5vcHRpb25zLnkpIHtcbiAgICAvLyBob3Jpem9udGFsLCBzaW5jZSB5IG9mZnNldCBpcyB0aGUgc2FtZSBpbiBwcmVzcyBhbmQgbW92ZVRvXG4gICAgbGV0IHRodW1iID0gKGFjdGlvbnNbMF1bMF0ub3B0aW9ucy54IDw9IGFjdGlvbnNbMV1bMF0ub3B0aW9ucy54KSA/IGFjdGlvbnNbMF0gOiBhY3Rpb25zWzFdO1xuXG4gICAgLy8gbm93IGRlY2lwaGVyIHBpbmNoIHZzLiB6b29tLFxuICAgIC8vICAgcGluY2g6IHRodW1iIG1vdmluZyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICAvLyAgIHpvb206IHRodW1iIG1vdmluZyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBzY2FsZSA9IGRldGVybWluZVBpbmNoU2NhbGUodGh1bWJbMF0ub3B0aW9ucy54LCB0aHVtYlsxXS5vcHRpb25zLngsIHRodW1iWzBdLm9wdGlvbnMueCA8PSB0aHVtYlsxXS5vcHRpb25zLngpO1xuICB9IGVsc2Uge1xuICAgIC8vIHZlcnRpY2FsXG4gICAgbGV0IGZvcmVmaW5nZXIgPSAoYWN0aW9uc1swXVswXS5vcHRpb25zLnkgPD0gYWN0aW9uc1sxXVswXS5vcHRpb25zLnkpID8gYWN0aW9uc1swXSA6IGFjdGlvbnNbMV07XG5cbiAgICAvLyBub3cgZGVjaXBoZXIgcGluY2ggdnMuIHpvb21cbiAgICAvLyAgIHBpbmNoOiBmb3JlZmluZ2VyIG1vdmluZyBmcm9tIHRvcCB0byBib3R0b21cbiAgICAvLyAgIHpvb206IGZvcmVmaW5nZXIgbW92aW5nIGZyb20gYm90dG9tIHRvIHRvcFxuICAgIHNjYWxlID0gZGV0ZXJtaW5lUGluY2hTY2FsZShmb3JlZmluZ2VyWzBdLm9wdGlvbnMueSwgZm9yZWZpbmdlclsxXS5vcHRpb25zLnksIGZvcmVmaW5nZXJbMF0ub3B0aW9ucy55IDw9IGZvcmVmaW5nZXJbMV0ub3B0aW9ucy55KTtcbiAgfVxuICB2ZWxvY2l0eSA9IHNjYWxlIDwgMSA/IC0xIDogMTtcblxuICBsb2cuZGVidWcoYERlY29kZWQgJHtzY2FsZSA8IDEgPyAncGluY2gnIDogJ3pvb20nfSBhY3Rpb24gd2l0aCBzY2FsZSAnJHtzY2FsZX0nIGFuZCB2ZWxvY2l0eSAnJHt2ZWxvY2l0eX0nYCk7XG4gIGlmIChzY2FsZSA8IDEpIHtcbiAgICBsb2cud2FybignUGluY2ggYWN0aW9ucyBtYXkgbm90IHdvcmssIGR1ZSB0byBBcHBsZSBpc3N1ZS4nKTtcbiAgfVxuXG4gIGxldCBwYXJhbXMgPSB7XG4gICAgc2NhbGUsXG4gICAgdmVsb2NpdHlcbiAgfTtcbiAgYXdhaXQgdGhpcy5wcm94eUNvbW1hbmQoYC93ZGEvZWxlbWVudC8ke2VsfS9waW5jaGAsICdQT1NUJywgcGFyYW1zKTtcbn07XG5cbi8qXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL1dlYkRyaXZlckFnZW50L2Jsb2IvbWFzdGVyL1dlYkRyaXZlckFnZW50TGliL0NvbW1hbmRzL0ZCRWxlbWVudENvbW1hbmRzLm1cbiAqIHRvIGdldCB0aGUgaW5mbyBhYm91dCBhdmFpbGFibGUgV0RBIGdlc3R1cmVzIEFQSVxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vcmVmZXJlbmNlL3hjdGVzdC94Y3VpZWxlbWVudCBhbmRcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9yZWZlcmVuY2UveGN0ZXN0L3hjdWljb29yZGluYXRlIHRvIGdldCB0aGUgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2ZcbiAqIGFsbCBYQ1Rlc3QgZ2VzdHVyZXNcbiovXG5cbmhlbHBlcnMubW9iaWxlU2Nyb2xsID0gYXN5bmMgZnVuY3Rpb24gKG9wdHM9e30sIHN3aXBlPWZhbHNlKSB7XG4gIGlmICghb3B0cy5lbGVtZW50KSB7XG4gICAgb3B0cy5lbGVtZW50ID0gYXdhaXQgdGhpcy5maW5kTmF0aXZlRWxlbWVudE9yRWxlbWVudHMoYGNsYXNzIG5hbWVgLCBgWENVSUVsZW1lbnRUeXBlQXBwbGljYXRpb25gLCBmYWxzZSk7XG4gIH1cbiAgLy8gV0RBIHN1cHBvcnRzIGZvdXIgc2Nyb2xsaW5nIHN0cmF0ZWdpZXM6IHByZWRpY2F0aW9uIGJhc2VkIG9uIG5hbWUsIGRpcmVjdGlvbixcbiAgLy8gcHJlZGljYXRlU3RyaW5nLCBhbmQgdG9WaXNpYmxlLCBpbiB0aGF0IG9yZGVyLiBTd2lwaW5nIHJlcXVpcmVzIGRpcmVjdGlvbi5cbiAgbGV0IHBhcmFtcyA9IHt9O1xuICBpZiAob3B0cy5uYW1lICYmICFzd2lwZSkge1xuICAgIHBhcmFtcy5uYW1lID0gb3B0cy5uYW1lO1xuICB9IGVsc2UgaWYgKG9wdHMuZGlyZWN0aW9uKSB7XG4gICAgaWYgKFsndXAnLCAnZG93bicsICdsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihvcHRzLmRpcmVjdGlvbi50b0xvd2VyQ2FzZSgpKSA8IDApIHtcbiAgICAgIGxldCBtc2cgPSAnRGlyZWN0aW9uIG11c3QgYmUgdXAsIGRvd24sIGxlZnQgb3IgcmlnaHQnO1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3cobXNnKTtcbiAgICB9XG4gICAgcGFyYW1zLmRpcmVjdGlvbiA9IG9wdHMuZGlyZWN0aW9uO1xuICB9ICBlbHNlIGlmIChvcHRzLnByZWRpY2F0ZVN0cmluZyAmJiAhc3dpcGUpIHtcbiAgICBwYXJhbXMucHJlZGljYXRlU3RyaW5nID0gb3B0cy5wcmVkaWNhdGVTdHJpbmc7XG4gIH0gZWxzZSBpZiAob3B0cy50b1Zpc2libGUgJiYgIXN3aXBlKSB7XG4gICAgcGFyYW1zLnRvVmlzaWJsZSA9IG9wdHMudG9WaXNpYmxlO1xuICB9IGVsc2Uge1xuICAgIGxldCBtc2cgPSBzd2lwZSA/ICdNb2JpbGUgc3dpcGUgcmVxdWlyZXMgZGlyZWN0aW9uJyA6ICAnTW9iaWxlIHNjcm9sbCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHN0cmF0ZWdpZXM6IG5hbWUsIGRpcmVjdGlvbiwgcHJlZGljYXRlU3RyaW5nLCBhbmQgdG9WaXNpYmxlLiBTcGVjaWZ5IG9uZSBvZiB0aGVzZSc7XG4gICAgbG9nLmVycm9yQW5kVGhyb3cobXNnKTtcbiAgfVxuXG4gIC8vIHdlIGNhbiBhbHNvIG9wdGlvbmFsbHkgcGFzcyBhIGRpc3RhbmNlIHdoaWNoIGFwcGVhcnMgdG8gYmUgYSByYXRpbyBvZlxuICAvLyBzY3JlZW4gaGVpZ2h0LCBzbyAxLjAgbWVhbnMgYSBmdWxsIHNjcmVlbidzIHdvcnRoIG9mIHNjcm9sbGluZ1xuICBpZiAoIXN3aXBlICYmIG9wdHMuZGlzdGFuY2UpIHtcbiAgICBwYXJhbXMuZGlzdGFuY2UgPSBvcHRzLmRpc3RhbmNlO1xuICB9XG5cbiAgbGV0IGVsZW1lbnQgPSBvcHRzLmVsZW1lbnQuRUxFTUVOVCB8fCBvcHRzLmVsZW1lbnQ7XG4gIGxldCBlbmRwb2ludCA9IGAvd2RhL2VsZW1lbnQvJHtlbGVtZW50fS8ke3N3aXBlID8gJ3N3aXBlJyA6ICdzY3JvbGwnfWA7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChlbmRwb2ludCwgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuaGVscGVycy5tb2JpbGVTd2lwZSA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLm1vYmlsZVNjcm9sbChvcHRzLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRQYXJhbWV0ZXIgKHBhcmFtTmFtZSwgcGFyYW1WYWx1ZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbVZhbHVlKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBcIiR7cGFyYW1OYW1lfVwiIHBhcmFtZXRlciBpcyBtYW5kYXRvcnkgZm9yIFwiJHttZXRob2ROYW1lfVwiIGNhbGxgKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBwYXJzZUZsb2F0KHBhcmFtVmFsdWUpO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBcIiR7cGFyYW1OYW1lfVwiIHBhcmFtZXRlciBzaG91bGQgYmUgYSB2YWxpZCBudW1iZXIuIFwiJHtwYXJhbVZhbHVlfVwiIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5oZWxwZXJzLm1vYmlsZVBpbmNoID0gYXN5bmMgZnVuY3Rpb24gKG9wdHM9e30pIHtcbiAgaWYgKCFvcHRzLmVsZW1lbnQpIHtcbiAgICBvcHRzLmVsZW1lbnQgPSBhd2FpdCB0aGlzLmZpbmROYXRpdmVFbGVtZW50T3JFbGVtZW50cyhgY2xhc3MgbmFtZWAsIGBYQ1VJRWxlbWVudFR5cGVBcHBsaWNhdGlvbmAsIGZhbHNlKTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgc2NhbGU6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3NjYWxlJywgb3B0cy5zY2FsZSwgJ3BpbmNoJyksXG4gICAgdmVsb2NpdHk6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3ZlbG9jaXR5Jywgb3B0cy52ZWxvY2l0eSwgJ3BpbmNoJylcbiAgfTtcbiAgY29uc3QgZWwgPSBvcHRzLmVsZW1lbnQuRUxFTUVOVCB8fCBvcHRzLmVsZW1lbnQ7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS9lbGVtZW50LyR7ZWx9L3BpbmNoYCwgJ1BPU1QnLCBwYXJhbXMpO1xufTtcblxuaGVscGVycy5tb2JpbGVEb3VibGVUYXAgPSBhc3luYyBmdW5jdGlvbiAob3B0cz17fSkge1xuICBpZiAob3B0cy5lbGVtZW50KSB7XG4gICAgLy8gRG91YmxlIHRhcCBlbGVtZW50XG4gICAgY29uc3QgZWwgPSBvcHRzLmVsZW1lbnQuRUxFTUVOVCB8fCBvcHRzLmVsZW1lbnQ7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGAvd2RhL2VsZW1lbnQvJHtlbH0vZG91YmxlVGFwYCwgJ1BPU1QnKTtcbiAgfVxuICAvLyBEb3VibGUgdGFwIGNvb3JkaW5hdGVzXG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB4OiBwYXJzZUZsb2F0UGFyYW1ldGVyKCd4Jywgb3B0cy54LCAnZG91YmxlVGFwJyksXG4gICAgeTogcGFyc2VGbG9hdFBhcmFtZXRlcigneScsIG9wdHMueSwgJ2RvdWJsZVRhcCcpXG4gIH07XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZCgnL3dkYS9kb3VibGVUYXAnLCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5oZWxwZXJzLm1vYmlsZVR3b0ZpbmdlclRhcCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIGlmICghb3B0cy5lbGVtZW50KSB7XG4gICAgb3B0cy5lbGVtZW50ID0gYXdhaXQgdGhpcy5maW5kTmF0aXZlRWxlbWVudE9yRWxlbWVudHMoYGNsYXNzIG5hbWVgLCBgWENVSUVsZW1lbnRUeXBlQXBwbGljYXRpb25gLCBmYWxzZSk7XG4gIH1cbiAgY29uc3QgZWwgPSBvcHRzLmVsZW1lbnQuRUxFTUVOVCB8fCBvcHRzLmVsZW1lbnQ7XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS9lbGVtZW50LyR7ZWx9L3R3b0ZpbmdlclRhcGAsICdQT1NUJyk7XG59O1xuXG5oZWxwZXJzLm1vYmlsZVRvdWNoQW5kSG9sZCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gIGxldCBwYXJhbXMgPSB7XG4gICAgZHVyYXRpb246IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ2R1cmF0aW9uJywgb3B0cy5kdXJhdGlvbiwgJ3RvdWNoQW5kSG9sZCcpXG4gIH07XG4gIGlmIChvcHRzLmVsZW1lbnQpIHtcbiAgICAvLyBMb25nIHRhcCBlbGVtZW50XG4gICAgY29uc3QgZWwgPSBvcHRzLmVsZW1lbnQuRUxFTUVOVCB8fCBvcHRzLmVsZW1lbnQ7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGAvd2RhL2VsZW1lbnQvJHtlbH0vdG91Y2hBbmRIb2xkYCwgJ1BPU1QnLCBwYXJhbXMpO1xuICB9XG4gIC8vIExvbmcgdGFwIGNvb3JkaW5hdGVzXG4gIHBhcmFtcy54ID0gcGFyc2VGbG9hdFBhcmFtZXRlcigneCcsIG9wdHMueCwgJ3RvdWNoQW5kSG9sZCcpO1xuICBwYXJhbXMueSA9IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3knLCBvcHRzLnksICd0b3VjaEFuZEhvbGQnKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKCcvd2RhL3RvdWNoQW5kSG9sZCcsICdQT1NUJywgcGFyYW1zKTtcbn07XG5cbmhlbHBlcnMubW9iaWxlVGFwID0gYXN5bmMgZnVuY3Rpb24gKG9wdHM9e30pIHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIHg6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3gnLCBvcHRzLngsICd0YXAnKSxcbiAgICB5OiBwYXJzZUZsb2F0UGFyYW1ldGVyKCd5Jywgb3B0cy55LCAndGFwJylcbiAgfTtcbiAgY29uc3QgZWwgPSBvcHRzLmVsZW1lbnQgPyAob3B0cy5lbGVtZW50LkVMRU1FTlQgfHwgb3B0cy5lbGVtZW50KSA6ICcwJztcbiAgcmV0dXJuIGF3YWl0IHRoaXMucHJveHlDb21tYW5kKGAvd2RhL3RhcC8ke2VsfWAsICdQT1NUJywgcGFyYW1zKTtcbn07XG5cbmhlbHBlcnMubW9iaWxlRHJhZ0Zyb21Ub0ZvckR1cmF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG9wdHM9e30pIHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIGR1cmF0aW9uOiBwYXJzZUZsb2F0UGFyYW1ldGVyKCdkdXJhdGlvbicsIG9wdHMuZHVyYXRpb24sICdkcmFnRnJvbVRvRm9yRHVyYXRpb24nKSxcbiAgICBmcm9tWDogcGFyc2VGbG9hdFBhcmFtZXRlcignZnJvbVgnLCBvcHRzLmZyb21YLCAnZHJhZ0Zyb21Ub0ZvckR1cmF0aW9uJyksXG4gICAgZnJvbVk6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ2Zyb21ZJywgb3B0cy5mcm9tWSwgJ2RyYWdGcm9tVG9Gb3JEdXJhdGlvbicpLFxuICAgIHRvWDogcGFyc2VGbG9hdFBhcmFtZXRlcigndG9YJywgb3B0cy50b1gsICdkcmFnRnJvbVRvRm9yRHVyYXRpb24nKSxcbiAgICB0b1k6IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3RvWScsIG9wdHMudG9ZLCAnZHJhZ0Zyb21Ub0ZvckR1cmF0aW9uJylcbiAgfTtcbiAgaWYgKG9wdHMuZWxlbWVudCkge1xuICAgIC8vIERyYWcgZWxlbWVudFxuICAgIGNvbnN0IGVsID0gb3B0cy5lbGVtZW50LkVMRU1FTlQgfHwgb3B0cy5lbGVtZW50O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS9lbGVtZW50LyR7ZWx9L2RyYWdmcm9tdG9mb3JkdXJhdGlvbmAsICdQT1NUJywgcGFyYW1zKTtcbiAgfVxuICAvLyBEcmFnIGNvb3JkaW5hdGVzXG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZCgnL3dkYS9kcmFnZnJvbXRvZm9yZHVyYXRpb24nLCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5oZWxwZXJzLm1vYmlsZVNlbGVjdFBpY2tlcldoZWVsVmFsdWUgPSBhc3luYyBmdW5jdGlvbiAob3B0cz17fSkge1xuICBpZiAoIW9wdHMuZWxlbWVudCkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KCdFbGVtZW50IGlkIGlzIGV4cGVjdGVkIHRvIGJlIHNldCBmb3Igc2VsZWN0UGlja2VyV2hlZWxWYWx1ZSBtZXRob2QnKTtcbiAgfVxuICBpZiAoIV8uaXNTdHJpbmcob3B0cy5vcmRlcikgfHwgWyduZXh0JywgJ3ByZXZpb3VzJ10uaW5kZXhPZihvcHRzLm9yZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgbWFuZGF0b3J5IFwib3JkZXJcIiBwYXJhbWV0ZXIgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1YWwgZWl0aGVyIHRvICduZXh0JyBvciAncHJldmlvdXMnLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7b3B0cy5vcmRlcn0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCBlbCA9IG9wdHMuZWxlbWVudC5FTEVNRU5UIHx8IG9wdHMuZWxlbWVudDtcbiAgY29uc3QgcGFyYW1zID0ge29yZGVyOiBvcHRzLm9yZGVyfTtcbiAgaWYgKG9wdHMub2Zmc2V0KSB7XG4gICAgcGFyYW1zLm9mZnNldCA9IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ29mZnNldCcsIG9wdHMub2Zmc2V0LCAnc2VsZWN0UGlja2VyV2hlZWxWYWx1ZScpO1xuICB9XG4gIHJldHVybiBhd2FpdCB0aGlzLnByb3h5Q29tbWFuZChgL3dkYS9waWNrZXJ3aGVlbC8ke2VsfS9zZWxlY3RgLCAnUE9TVCcsIHBhcmFtcyk7XG59O1xuXG5oZWxwZXJzLmdldENvb3JkaW5hdGVzID0gYXN5bmMgZnVuY3Rpb24gKGdlc3R1cmUpIHtcbiAgbGV0IGVsID0gZ2VzdHVyZS5vcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gZGVmYXVsdHNcbiAgbGV0IGNvb3JkaW5hdGVzID0ge3g6IDAsIHk6IDAsIGFyZU9mZnNldHM6IGZhbHNlfTtcblxuICBsZXQgb3B0aW9uWCA9IG51bGw7XG4gIGlmIChnZXN0dXJlLm9wdGlvbnMueCkge1xuICAgIG9wdGlvblggPSBwYXJzZUZsb2F0UGFyYW1ldGVyKCd4JywgZ2VzdHVyZS5vcHRpb25zLngsICdnZXRDb29yZGluYXRlcycpO1xuICB9XG4gIGxldCBvcHRpb25ZID0gbnVsbDtcbiAgaWYgKGdlc3R1cmUub3B0aW9ucy55KSB7XG4gICAgb3B0aW9uWSA9IHBhcnNlRmxvYXRQYXJhbWV0ZXIoJ3knLCBnZXN0dXJlLm9wdGlvbnMueSwgJ2dldENvb3JkaW5hdGVzJyk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IHRoZSBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICBpZiAoZWwpIHtcbiAgICBsZXQgcmVjdCA9IGF3YWl0IHRoaXMuZ2V0UmVjdChlbCk7XG4gICAgbGV0IHBvcyA9IHt4OiByZWN0LngsIHk6IHJlY3QueX07XG4gICAgbGV0IHNpemUgPSB7dzogcmVjdC53aWR0aCwgaDogcmVjdC5oZWlnaHR9O1xuXG4gICAgLy8gZGVmYXVsdHNcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuXG4gICAgLy8gZ2V0IHRoZSByZWFsIG9mZnNldHNcbiAgICBpZiAob3B0aW9uWCB8fCBvcHRpb25ZKSB7XG4gICAgICBvZmZzZXRYID0gKG9wdGlvblggfHwgMCk7XG4gICAgICBvZmZzZXRZID0gKG9wdGlvblkgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFggPSAoc2l6ZS53IC8gMik7XG4gICAgICBvZmZzZXRZID0gKHNpemUuaCAvIDIpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBvZmZzZXRzXG4gICAgY29vcmRpbmF0ZXMueCA9IHBvcy54ICsgb2Zmc2V0WDtcbiAgICBjb29yZGluYXRlcy55ID0gcG9zLnkgKyBvZmZzZXRZO1xuICB9IGVsc2Uge1xuICAgIC8vIG1vdmVUbyBjb29yZGluYXRlcyBhcmUgcGFzc2VkIGluIGFzIG9mZnNldHNcbiAgICBjb29yZGluYXRlcy5hcmVPZmZzZXRzID0gKGdlc3R1cmUuYWN0aW9uID09PSAnbW92ZVRvJyk7XG4gICAgY29vcmRpbmF0ZXMueCA9IChvcHRpb25YIHx8IDApO1xuICAgIGNvb3JkaW5hdGVzLnkgPSAob3B0aW9uWSB8fCAwKTtcbiAgfVxuICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuXG5oZWxwZXJzLmFwcGx5TW92ZVRvT2Zmc2V0ID0gZnVuY3Rpb24gKGZpcnN0Q29vcmRpbmF0ZXMsIHNlY29uZENvb3JkaW5hdGVzKSB7XG4gIGlmIChzZWNvbmRDb29yZGluYXRlcy5hcmVPZmZzZXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGZpcnN0Q29vcmRpbmF0ZXMueCArIHNlY29uZENvb3JkaW5hdGVzLngsXG4gICAgICB5OiBmaXJzdENvb3JkaW5hdGVzLnkgKyBzZWNvbmRDb29yZGluYXRlcy55LFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlY29uZENvb3JkaW5hdGVzO1xuICB9XG59O1xuXG5PYmplY3QuYXNzaWduKGV4dGVuc2lvbnMsIGhlbHBlcnMsIGNvbW1hbmRzKTtcbmV4cG9ydCB7IGV4dGVuc2lvbnMsIGhlbHBlcnMsIGNvbW1hbmRzLCBnZXN0dXJlc0NoYWluVG9TdHJpbmcgfTtcbmV4cG9ydCBkZWZhdWx0IGV4dGVuc2lvbnM7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
