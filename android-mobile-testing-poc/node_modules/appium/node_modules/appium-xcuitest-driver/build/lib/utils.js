'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _appiumIosDriver = require('appium-ios-driver');

var _teen_process = require('teen_process');

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _v8 = require('v8');

var _v82 = _interopRequireDefault(_v8);

var DEFAULT_TIMEOUT_KEY = 'default';

function detectUdid() {
  var cmd, args, udid, _ref, stdout, udids;

  return _regeneratorRuntime.async(function detectUdid$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Auto-detecting real device udid...');
        cmd = undefined, args = [];
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevice_id'));

      case 5:
        cmd = context$1$0.sent;

        args.push('-l');
        _logger2['default'].debug('Using idevice_id');
        context$1$0.next = 14;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](2);

        _logger2['default'].debug('Using udidetect');
        cmd = require.resolve('udidetect');

      case 14:
        udid = undefined;
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: 3000 }));

      case 18:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        udids = _lodash2['default'].filter(stdout.split('\n'), Boolean);

        udid = _lodash2['default'].last(udids);
        if (udids.length > 1) {
          _logger2['default'].warn('Multiple devices found: ' + udids.join(', '));
          _logger2['default'].warn('Choosing \'' + udid + '\'. If this is wrong, manually set with \'udid\' desired capability');
        }
        context$1$0.next = 28;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t1 = context$1$0['catch'](15);

        _logger2['default'].errorAndThrow('Error detecting udid: ' + context$1$0.t1.message);

      case 28:
        if (!(!udid || udid.length <= 2)) {
          context$1$0.next = 30;
          break;
        }

        throw new Error('Could not detect udid.');

      case 30:
        _logger2['default'].debug('Detected real device udid: \'' + udid + '\'');
        return context$1$0.abrupt('return', udid);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 10], [15, 25]]);
}

function getAndCheckXcodeVersion() {
  var version;
  return _regeneratorRuntime.async(function getAndCheckXcodeVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        version = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getVersion(true));

      case 4:
        version = context$1$0.sent;
        context$1$0.next = 11;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug(context$1$0.t0);
        _logger2['default'].errorAndThrow('Could not determine Xcode version: ' + context$1$0.t0.message);

      case 11:
        if (version.toolsVersion) {
          context$1$0.next = 20;
          break;
        }

        context$1$0.prev = 12;
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getCommandLineToolsVersion());

      case 15:
        version.toolsVersion = context$1$0.sent;
        context$1$0.next = 20;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t1 = context$1$0['catch'](12);

      case 20:

        // we do not support Xcodes < 7.3,
        if (version.versionFloat < 7.3) {
          _logger2['default'].errorAndThrow('Xcode version \'' + version.versionString + '\'. Support for ' + ('Xcode ' + version.versionString + ' is not supported. ') + 'Please upgrade to version 7.3 or higher');
        }
        return context$1$0.abrupt('return', version);

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7], [12, 18]]);
}

function getAndCheckIosSdkVersion() {
  var versionNumber;
  return _regeneratorRuntime.async(function getAndCheckIosSdkVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        versionNumber = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumXcode2['default'].getMaxIOSSDK());

      case 4:
        versionNumber = context$1$0.sent;
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].errorAndThrow('Could not determine iOS SDK version: ' + context$1$0.t0.message);

      case 10:
        return context$1$0.abrupt('return', versionNumber);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
}

function translateDeviceName(xcodeVersion, platformVersion) {
  var devName = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
  var deviceName, namesMapping;
  return _regeneratorRuntime.async(function translateDeviceName$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        deviceName = devName;
        context$1$0.t0 = devName.toLowerCase().trim();
        context$1$0.next = context$1$0.t0 === 'iphone simulator' ? 4 : context$1$0.t0 === 'ipad simulator' ? 6 : context$1$0.t0 === 'iphone 8' ? 8 : context$1$0.t0 === 'iphone 8 plus' ? 8 : context$1$0.t0 === 'iphone x' ? 8 : 10;
        break;

      case 4:
        deviceName = 'iPhone 6';
        return context$1$0.abrupt('break', 10);

      case 6:
        // no need to worry about floating point comparison because of the
        //   nature of the numbers being compared
        // iPad Retina is no longer available for ios 10.3
        //   so we pick another iPad to use as default
        deviceName = parseFloat(platformVersion) < 10.3 ? 'iPad Retina' : 'iPad Air';
        return context$1$0.abrupt('break', 10);

      case 8:
        // Xcode 9.0(.0) mis-named the new devices
        if (xcodeVersion.major === 9 && xcodeVersion.minor === 0 && (!_appiumSupport.util.hasValue(xcodeVersion.patch) || xcodeVersion.patch === 0)) {
          namesMapping = {
            'iphone 8': 'iPhone2017-A',
            'iphone 8 plus': 'iPhone2017-B',
            'iphone x': 'iPhone2017-C'
          };

          deviceName = namesMapping[devName.toLowerCase().trim()];
        }
        return context$1$0.abrupt('break', 10);

      case 10:

        if (deviceName !== devName) {
          _logger2['default'].debug('Changing deviceName from \'' + devName + '\' to \'' + deviceName + '\'');
        }
        return context$1$0.abrupt('return', deviceName);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// This map contains derived data attachment folders as keys
// and values are stacks of permssion masks
// It is used to synchronize permissions change
// on shared folders
var derivedDataPermissionsStacks = new _Map();

function adjustWDAAttachmentsPermissions(wda, perms) {
  var attachmentsFolder, permsStack;
  return _regeneratorRuntime.async(function adjustWDAAttachmentsPermissions$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to set permissions on WDA attachments folder');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        attachmentsFolder = context$1$0.t1.join.call(context$1$0.t1, context$1$0.t2, 'Logs/Test/Attachments');
        permsStack = derivedDataPermissionsStacks.get(attachmentsFolder) || [];

        if (!permsStack.length) {
          context$1$0.next = 23;
          break;
        }

        if (!(_lodash2['default'].last(permsStack) === perms)) {
          context$1$0.next = 19;
          break;
        }

        permsStack.push(perms);
        _logger2['default'].info('Not changing permissions of \'' + attachmentsFolder + '\' to \'' + perms + '\', because they were already set by the other session');
        return context$1$0.abrupt('return');

      case 19:
        if (!(permsStack.length > 1)) {
          context$1$0.next = 23;
          break;
        }

        permsStack.pop();
        _logger2['default'].info('Not changing permissions of \'' + attachmentsFolder + '\' to \'' + perms + '\', because the other session does not expect them to be changed');
        return context$1$0.abrupt('return');

      case 23:
        derivedDataPermissionsStacks.set(attachmentsFolder, [perms]);

        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(attachmentsFolder));

      case 26:
        if (!context$1$0.sent) {
          context$1$0.next = 31;
          break;
        }

        _logger2['default'].info('Setting \'' + perms + '\' permissions to \'' + attachmentsFolder + '\' folder');
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.chmod(attachmentsFolder, perms));

      case 30:
        return context$1$0.abrupt('return');

      case 31:
        _logger2['default'].info('There is no ' + attachmentsFolder + ' folder, so not changing permissions');

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

// This map contains derived data logs folders as keys
// and values are the count of times the particular
// folder has been scheduled for removal
var derivedDataCleanupMarkers = new _Map();

function markSystemFilesForCleanup(wda) {
  var logsRoot, markersCount;
  return _regeneratorRuntime.async(function markSystemFilesForCleanup$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to mark system files for cleanup');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        logsRoot = context$1$0.t1.resolve.call(context$1$0.t1, context$1$0.t2, 'Logs');
        markersCount = 0;

        if (derivedDataCleanupMarkers.has(logsRoot)) {
          markersCount = derivedDataCleanupMarkers.get(logsRoot);
        }
        derivedDataCleanupMarkers.set(logsRoot, ++markersCount);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function clearSystemFiles(wda) {
  var logsRoot, markersCount, cleanupCmd, cleanupTask;
  return _regeneratorRuntime.async(function clearSystemFiles$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = !wda;

        if (context$1$0.t0) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 4:
        context$1$0.t0 = !context$1$0.sent;

      case 5:
        if (!context$1$0.t0) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].warn('No WebDriverAgent derived data available, so unable to clear system files');
        return context$1$0.abrupt('return');

      case 8:
        context$1$0.t1 = _path2['default'];
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(wda.retrieveDerivedDataPath());

      case 11:
        context$1$0.t2 = context$1$0.sent;
        logsRoot = context$1$0.t1.resolve.call(context$1$0.t1, context$1$0.t2, 'Logs');

        if (!derivedDataCleanupMarkers.has(logsRoot)) {
          context$1$0.next = 19;
          break;
        }

        markersCount = derivedDataCleanupMarkers.get(logsRoot);

        derivedDataCleanupMarkers.set(logsRoot, --markersCount);

        if (!(markersCount > 0)) {
          context$1$0.next = 19;
          break;
        }

        _logger2['default'].info('Not cleaning \'' + logsRoot + '\' folder, because the other session does not expect it to be cleaned');
        return context$1$0.abrupt('return');

      case 19:
        derivedDataCleanupMarkers.set(logsRoot, 0);

        // Cleaning up big temporary files created by XCTest: https://github.com/appium/appium/issues/9410
        cleanupCmd = 'find -E /private/var/folders ' + '-regex \'.*/Session-WebDriverAgentRunner.*\\.log$|.*/StandardOutputAndStandardError\\.txt$\' ' + '-type f -exec sh -c \'echo "" > "{}"\' \\;';
        cleanupTask = new _teen_process.SubProcess('bash', ['-c', cleanupCmd], {
          detached: true,
          stdio: ['ignore', 'pipe', 'pipe']
        });
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(cleanupTask.start(0));

      case 24:
        // Do not wait for the task to be completed, since it might take a lot of time
        // We keep it running after Appium process is killed
        cleanupTask.proc.unref();
        _logger2['default'].debug('Started background XCTest logs cleanup: ' + cleanupCmd);

        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(logsRoot));

      case 28:
        if (!context$1$0.sent) {
          context$1$0.next = 33;
          break;
        }

        _logger2['default'].info('Cleaning test logs in \'' + logsRoot + '\' folder');
        context$1$0.next = 32;
        return _regeneratorRuntime.awrap(_appiumIosDriver.utils.clearLogs([logsRoot]));

      case 32:
        return context$1$0.abrupt('return');

      case 33:
        _logger2['default'].info('There is no ' + logsRoot + ' folder, so not cleaning files');

      case 34:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function checkAppPresent(app) {
  return _regeneratorRuntime.async(function checkAppPresent$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Checking whether app \'' + app + '\' is actually present on file system');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(app));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        _logger2['default'].errorAndThrow('Could not find app at \'' + app + '\'');

      case 5:
        _logger2['default'].debug('App is present');

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getDriverInfo() {
  var stat, built, pkg, version, info;
  return _regeneratorRuntime.async(function getDriverInfo$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(_path2['default'].resolve(__dirname, '..')));

      case 2:
        stat = context$1$0.sent;
        built = stat.mtime.getTime();
        pkg = require(__filename.indexOf('build/lib/utils') !== -1 ? '../../package.json' : '../package.json');
        version = pkg.version;
        info = {
          built: built,
          version: version
        };
        return context$1$0.abrupt('return', info);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function normalizeCommandTimeouts(value) {
  // The value is normalized already
  if (typeof value !== 'string') {
    return value;
  }

  var result = {};
  // Use as default timeout for all commands if a single integer value is provided
  if (!isNaN(value)) {
    result[DEFAULT_TIMEOUT_KEY] = _lodash2['default'].toInteger(value);
    return result;
  }

  // JSON object has been provided. Let's parse it
  try {
    result = JSON.parse(value);
    if (!_lodash2['default'].isPlainObject(result)) {
      throw new Error();
    }
  } catch (err) {
    _logger2['default'].errorAndThrow('"commandTimeouts" capability should be a valid JSON object. "' + value + '" was given instead');
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_lodash2['default'].toPairs(result)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2);

      var cmd = _step$value[0];
      var timeout = _step$value[1];

      if (!_lodash2['default'].isInteger(timeout) || timeout <= 0) {
        _logger2['default'].errorAndThrow('The timeout for "' + cmd + '" should be a valid natural number of milliseconds. "' + timeout + '" was given instead');
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

/**
 * Get the process id of the most recent running application
 * having the particular command line pattern.
 *
 * @param {string} pgrepPattern - pgrep-compatible search pattern.
 * @return {string} Either a process id or null if no matches were found.
 */
function getPidUsingPattern(pgrepPattern) {
  var args, _ref2, stdout, pid;

  return _regeneratorRuntime.async(function getPidUsingPattern$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-nif', pgrepPattern];
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', args));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        pid = parseInt(stdout, 10);

        if (!isNaN(pid)) {
          context$1$0.next = 10;
          break;
        }

        _logger2['default'].debug('Cannot parse process id from \'pgrep ' + args.join(' ') + '\' output: ' + stdout);
        return context$1$0.abrupt('return', null);

      case 10:
        return context$1$0.abrupt('return', '' + pid);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].debug('\'pgrep ' + args.join(' ') + '\' didn\'t detect any matching processes. Return code: ' + context$1$0.t0.code);
        return context$1$0.abrupt('return', null);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 13]]);
}

/**
 * Kill a process having the particular command line pattern.
 * This method tries to send SIGINT, SIGTERM and SIGKILL to the
 * matched processes in this order if the process is still running.
 *
 * @param {string} pgrepPattern - pgrep-compatible search pattern.
 */
function killAppUsingPattern(pgrepPattern) {
  var _arr, _i, signal, args;

  return _regeneratorRuntime.async(function killAppUsingPattern$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _arr = [2, 15, 9];
        _i = 0;

      case 2:
        if (!(_i < _arr.length)) {
          context$1$0.next = 22;
          break;
        }

        signal = _arr[_i];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(getPidUsingPattern(pgrepPattern));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        return context$1$0.abrupt('return');

      case 8:
        args = ['-' + signal, '-if', pgrepPattern];
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', args));

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t0 = context$1$0['catch'](9);

        _logger2['default'].debug('pkill ' + args.join(' ') + ' -> ' + context$1$0.t0.message);

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(100));

      case 19:
        _i++;
        context$1$0.next = 2;
        break;

      case 22:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 14]]);
}

/**
 * Kills running XCTest processes for the particular device.
 *
 * @param {string} udid - The device UDID.
 * @param {boolean} isSimulator - Equals to true if the current device is a Simulator
 * @param {object} opts - Additional options mapping. Possible keys are:
 *   - {string|number} wdaLocalPort: The number of local port WDA is listening on.
 */
function resetXCTestProcesses(udid, isSimulator) {
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var processPatterns, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, pgrepPattern;

  return _regeneratorRuntime.async(function resetXCTestProcesses$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        processPatterns = ['xcodebuild.*' + udid];

        if (opts.wdaLocalPort) {
          processPatterns.push('iproxy ' + opts.wdaLocalPort);
        } else if (!isSimulator) {
          processPatterns.push('iproxy.*' + udid);
        }
        if (isSimulator) {
          processPatterns.push(udid + '.*XCTRunner');
        }
        _logger2['default'].debug('Killing running processes \'' + processPatterns.join(', ') + '\' for the device ' + udid + '...');
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 7;
        _iterator2 = _getIterator(processPatterns);

      case 9:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 16;
          break;
        }

        pgrepPattern = _step2.value;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(killAppUsingPattern(pgrepPattern));

      case 13:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 9;
        break;

      case 16:
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](7);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError2) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError2;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 18, 22, 30], [23,, 25, 29]]);
}

function printUser() {
  var _ref3, stdout;

  return _regeneratorRuntime.async(function printUser$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('whoami'));

      case 3:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;

        _logger2['default'].debug('Current user: \'' + stdout.trim() + '\'');
        context$1$0.next = 11;
        break;

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Unable to get username running server: ' + context$1$0.t0.message);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
}

function printLibimobiledeviceInfo() {
  var _ref4, stdout, match;

  return _regeneratorRuntime.async(function printLibimobiledeviceInfo$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('brew', ['info', 'libimobiledevice']));

      case 3:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;
        match = /libimobiledevice:(.+)/.exec(stdout);

        if (match && match[1]) {
          _logger2['default'].debug('Current version of libimobiledevice: ' + match[1].trim());
        }
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Unable to get version of libimobiledevice: ' + context$1$0.t0.message);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
}

/**
 * Get the IDs of processes listening on the particular system port.
 * It is also possible to apply additional filtering based on the
 * process command line.
 *
 * @param {string|number} port - The port number.
 * @param {?Function} filteringFunc - Optional lambda function, which
 *                                    receives command line string of the particular process
 *                                    listening on given port, and is expected to return
 *                                    either true or false to include/exclude the corresponding PID
 *                                    from the resulting array.
 * @returns {Array<string>} - the list of matched process ids.
 */
function getPIDsListeningOnPort(port) {
  var filteringFunc = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

  var result, _ref5,
  // This only works since Mac OS X El Capitan
  stdout;

  return _regeneratorRuntime.async(function getPIDsListeningOnPort$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        result = [];
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('lsof', ['-ti', 'tcp:' + port]));

      case 4:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;

        result.push.apply(result, _toConsumableArray(stdout.trim().split(/\n+/)));
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](1);
        return context$1$0.abrupt('return', result);

      case 12:
        if (_lodash2['default'].isFunction(filteringFunc)) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt('return', result);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_bluebird2['default'].filter(result, function callee$1$0(x) {
          var _ref6, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('ps', ['-p', x, '-o', 'command']));

              case 2:
                _ref6 = context$2$0.sent;
                stdout = _ref6.stdout;
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap(filteringFunc(stdout));

              case 6:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 7:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 16:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 9]]);
}

/**
 * @typedef {Object} UploadOptions
 *
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 */

/**
 * Encodes the given local file to base64 and returns the resulting string
 * or uploads it to a remote server using http/https or ftp protocols
 * if `remotePath` is set
 *
 * @param {string} localFile - The path to an existing local file
 * @param {?string} remotePath - The path to the remote location, where
 *                               this file should be uploaded
 * @param {?UploadOptions} uploadOptions - Set of upload options
 * @returns {string} Either an empty string if the upload was successful or
 * base64-encoded file representation if `remotePath` is falsy
 * @throws {Error} If there was upload failure or the file content is too big
 * to fit in the available process memory.
 */
function encodeBase64OrUpload(localFile) {
  var remotePath = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var uploadOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref7, size, maxMemoryLimit, content, remoteUrl, options, user, pass, method;

  return _regeneratorRuntime.async(function encodeBase64OrUpload$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(localFile));

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        _logger2['default'].errorAndThrow('The file at \'' + localFile + '\' does not exist or is not accessible');

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localFile));

      case 6:
        _ref7 = context$1$0.sent;
        size = _ref7.size;

        _logger2['default'].debug('The size of the file is ' + _appiumSupport.util.toReadableSizeString(size));

        if (!_lodash2['default'].isEmpty(remotePath)) {
          context$1$0.next = 17;
          break;
        }

        maxMemoryLimit = _v82['default'].getHeapStatistics().total_available_size / 2;

        if (!(size >= maxMemoryLimit)) {
          context$1$0.next = 13;
          break;
        }

        throw new Error('Cannot read \'' + localFile + '\' to the memory, because the file is too large ' + ('(' + _appiumSupport.util.toReadableSizeString(size) + ' >= ' + _appiumSupport.util.toReadableSizeString(maxMemoryLimit) + '). ') + 'Try to provide a link to a remote writable location instead or increase the value of ' + '\'max_old_space_size\' server argument.');

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localFile));

      case 15:
        content = context$1$0.sent;
        return context$1$0.abrupt('return', content.toString('base64'));

      case 17:
        remoteUrl = _url2['default'].parse(remotePath);
        options = {};
        user = uploadOptions.user;
        pass = uploadOptions.pass;
        method = uploadOptions.method;

        if (remoteUrl.protocol.startsWith('http')) {
          options = {
            url: remoteUrl.href,
            method: method || 'PUT',
            multipart: [{ body: _fs3['default'].createReadStream(localFile) }]
          };
          if (user && pass) {
            options.auth = { user: user, pass: pass };
          }
        } else if (remoteUrl.protocol === 'ftp:') {
          options = {
            host: remoteUrl.hostname,
            port: remoteUrl.port || 21
          };
          if (user && pass) {
            options.user = user;
            options.pass = pass;
          }
        }
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(_appiumSupport.net.uploadFile(localFile, remotePath, options));

      case 25:
        return context$1$0.abrupt('return', '');

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Stops and removes all web socket handlers that are listening
 * in scope of the currect session.
 *
 * @param {Object} server - The instance of NodeJs HTTP server,
 * which hosts Appium
 * @param {string} sessionId - The id of the current session
 */
function removeAllSessionWebSocketHandlers(server, sessionId) {
  var activeHandlers, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, pathname;

  return _regeneratorRuntime.async(function removeAllSessionWebSocketHandlers$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(!server || !_lodash2['default'].isFunction(server.getWebSocketHandlers))) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(server.getWebSocketHandlers(sessionId));

      case 4:
        activeHandlers = context$1$0.sent;
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 8;
        _iterator3 = _getIterator(_lodash2['default'].keys(activeHandlers));

      case 10:
        if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
          context$1$0.next = 17;
          break;
        }

        pathname = _step3.value;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(server.removeWebSocketHandler(pathname));

      case 14:
        _iteratorNormalCompletion3 = true;
        context$1$0.next = 10;
        break;

      case 17:
        context$1$0.next = 23;
        break;

      case 19:
        context$1$0.prev = 19;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 23:
        context$1$0.prev = 23;
        context$1$0.prev = 24;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 26:
        context$1$0.prev = 26;

        if (!_didIteratorError3) {
          context$1$0.next = 29;
          break;
        }

        throw _iteratorError3;

      case 29:
        return context$1$0.finish(26);

      case 30:
        return context$1$0.finish(23);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[8, 19, 23, 31], [24,, 26, 30]]);
}

/**
 * Verify whether the given application is compatible to the
 * platform where it is going to be installed and tested.
 *
 * @param {string} app - The actual path to the application bundle
 * @param {boolean} isSimulator - Should be set to `true` if the test will be executed on Simulator
 * @returns {?boolean} The function returns `null` if the application does not exist or there is no
 * `CFBundleSupportedPlatforms` key in its Info.plist manifest.
 * `true` is returned if the bundle architecture matches the device architecture.
 * @throws {Error} If bundle architecture does not match the device architecture.
 */
function verifyApplicationPlatform(app, isSimulator) {
  var infoPlist, _ref8, CFBundleSupportedPlatforms, isAppSupported;

  return _regeneratorRuntime.async(function verifyApplicationPlatform$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Verifying application platform');

        infoPlist = _path2['default'].resolve(app, 'Info.plist');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(infoPlist));

      case 4:
        if (context$1$0.sent) {
          context$1$0.next = 7;
          break;
        }

        _logger2['default'].debug('\'' + infoPlist + '\' does not exist');
        return context$1$0.abrupt('return', null);

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.plist.parsePlistFile(infoPlist));

      case 9:
        _ref8 = context$1$0.sent;
        CFBundleSupportedPlatforms = _ref8.CFBundleSupportedPlatforms;

        _logger2['default'].debug('CFBundleSupportedPlatforms: ' + JSON.stringify(CFBundleSupportedPlatforms));

        if (_lodash2['default'].isArray(CFBundleSupportedPlatforms)) {
          context$1$0.next = 15;
          break;
        }

        _logger2['default'].debug('CFBundleSupportedPlatforms key does not exist in \'' + infoPlist + '\'');
        return context$1$0.abrupt('return', null);

      case 15:
        isAppSupported = isSimulator && CFBundleSupportedPlatforms.includes('iPhoneSimulator') || !isSimulator && CFBundleSupportedPlatforms.includes('iPhoneOS');

        if (!isAppSupported) {
          context$1$0.next = 18;
          break;
        }

        return context$1$0.abrupt('return', true);

      case 18:
        throw new Error((isSimulator ? 'Simulator' : 'Real device') + ' architecture is unsupported by the \'' + app + '\' application. ' + 'Make sure the correct deployment target has been selected for its compilation in Xcode.');

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.detectUdid = detectUdid;
exports.getAndCheckXcodeVersion = getAndCheckXcodeVersion;
exports.getAndCheckIosSdkVersion = getAndCheckIosSdkVersion;
exports.adjustWDAAttachmentsPermissions = adjustWDAAttachmentsPermissions;
exports.checkAppPresent = checkAppPresent;
exports.getDriverInfo = getDriverInfo;
exports.clearSystemFiles = clearSystemFiles;
exports.translateDeviceName = translateDeviceName;
exports.normalizeCommandTimeouts = normalizeCommandTimeouts;
exports.DEFAULT_TIMEOUT_KEY = DEFAULT_TIMEOUT_KEY;
exports.resetXCTestProcesses = resetXCTestProcesses;
exports.getPidUsingPattern = getPidUsingPattern;
exports.markSystemFilesForCleanup = markSystemFilesForCleanup;
exports.printUser = printUser;
exports.printLibimobiledeviceInfo = printLibimobiledeviceInfo;
exports.getPIDsListeningOnPort = getPIDsListeningOnPort;
exports.encodeBase64OrUpload = encodeBase64OrUpload;
exports.removeAllSessionWebSocketHandlers = removeAllSessionWebSocketHandlers;
exports.verifyApplicationPlatform = verifyApplicationPlatform;

// only want to clear the system files for the particular WDA xcode run

// get the package.json and the version from it
//# sourceMappingURL=data:application/json;charset=utf8;base64,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eUIsR0FBekIseUJBQXlCO1FBQUUsU0FBUyxHQUFULFNBQVM7UUFBRSx5QkFBeUIsR0FBekIseUJBQXlCO1FBQy9ELHNCQUFzQixHQUF0QixzQkFBc0I7UUFBRSxvQkFBb0IsR0FBcEIsb0JBQW9CO1FBQUUsaUNBQWlDLEdBQWpDLGlDQUFpQztRQUMvRSx5QkFBeUIsR0FBekIseUJBQXlCIiwiZmlsZSI6ImxpYi91dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IGZzLCB1dGlsLCBuZXQsIHBsaXN0IH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyB1dGlscyBhcyBpb3NVdGlscyB9IGZyb20gJ2FwcGl1bS1pb3MtZHJpdmVyJztcbmltcG9ydCB7IFN1YlByb2Nlc3MsIGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHhjb2RlIGZyb20gJ2FwcGl1bS14Y29kZSc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgX2ZzIGZyb20gJ2ZzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCB2OCBmcm9tICd2OCc7XG5cbmNvbnN0IERFRkFVTFRfVElNRU9VVF9LRVkgPSAnZGVmYXVsdCc7XG5cblxuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0VWRpZCAoKSB7XG4gIGxvZy5kZWJ1ZygnQXV0by1kZXRlY3RpbmcgcmVhbCBkZXZpY2UgdWRpZC4uLicpO1xuICBsZXQgIGNtZCwgYXJncyA9IFtdO1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IGZzLndoaWNoKCdpZGV2aWNlX2lkJyk7XG4gICAgYXJncy5wdXNoKCctbCcpO1xuICAgIGxvZy5kZWJ1ZygnVXNpbmcgaWRldmljZV9pZCcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZGVidWcoJ1VzaW5nIHVkaWRldGVjdCcpO1xuICAgIGNtZCA9IHJlcXVpcmUucmVzb2x2ZSgndWRpZGV0ZWN0Jyk7XG4gIH1cbiAgbGV0IHVkaWQ7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0OiAzMDAwfSk7XG4gICAgbGV0IHVkaWRzID0gXy5maWx0ZXIoc3Rkb3V0LnNwbGl0KCdcXG4nKSwgQm9vbGVhbik7XG4gICAgdWRpZCA9IF8ubGFzdCh1ZGlkcyk7XG4gICAgaWYgKHVkaWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxvZy53YXJuKGBNdWx0aXBsZSBkZXZpY2VzIGZvdW5kOiAke3VkaWRzLmpvaW4oJywgJyl9YCk7XG4gICAgICBsb2cud2FybihgQ2hvb3NpbmcgJyR7dWRpZH0nLiBJZiB0aGlzIGlzIHdyb25nLCBtYW51YWxseSBzZXQgd2l0aCAndWRpZCcgZGVzaXJlZCBjYXBhYmlsaXR5YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgRXJyb3IgZGV0ZWN0aW5nIHVkaWQ6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbiAgaWYgKCF1ZGlkIHx8IHVkaWQubGVuZ3RoIDw9IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlY3QgdWRpZC4nKTtcbiAgfVxuICBsb2cuZGVidWcoYERldGVjdGVkIHJlYWwgZGV2aWNlIHVkaWQ6ICcke3VkaWR9J2ApO1xuICByZXR1cm4gdWRpZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0QW5kQ2hlY2tYY29kZVZlcnNpb24gKCkge1xuICBsZXQgdmVyc2lvbjtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uID0gYXdhaXQgeGNvZGUuZ2V0VmVyc2lvbih0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGVycik7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBkZXRlcm1pbmUgWGNvZGUgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuXG4gIGlmICghdmVyc2lvbi50b29sc1ZlcnNpb24pIHtcbiAgICB0cnkge1xuICAgICAgdmVyc2lvbi50b29sc1ZlcnNpb24gPSBhd2FpdCB4Y29kZS5nZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbigpO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgfVxuXG4gIC8vIHdlIGRvIG5vdCBzdXBwb3J0IFhjb2RlcyA8IDcuMyxcbiAgaWYgKHZlcnNpb24udmVyc2lvbkZsb2F0IDwgNy4zKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFhjb2RlIHZlcnNpb24gJyR7dmVyc2lvbi52ZXJzaW9uU3RyaW5nfScuIFN1cHBvcnQgZm9yIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBYY29kZSAke3ZlcnNpb24udmVyc2lvblN0cmluZ30gaXMgbm90IHN1cHBvcnRlZC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFBsZWFzZSB1cGdyYWRlIHRvIHZlcnNpb24gNy4zIG9yIGhpZ2hlcmApO1xuICB9XG4gIHJldHVybiB2ZXJzaW9uO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBbmRDaGVja0lvc1Nka1ZlcnNpb24gKCkge1xuICBsZXQgdmVyc2lvbk51bWJlcjtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uTnVtYmVyID0gYXdhaXQgeGNvZGUuZ2V0TWF4SU9TU0RLKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZGV0ZXJtaW5lIGlPUyBTREsgdmVyc2lvbjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gdmVyc2lvbk51bWJlcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdHJhbnNsYXRlRGV2aWNlTmFtZSAoeGNvZGVWZXJzaW9uLCBwbGF0Zm9ybVZlcnNpb24sIGRldk5hbWUgPSAnJykge1xuICBsZXQgZGV2aWNlTmFtZSA9IGRldk5hbWU7XG4gIHN3aXRjaCAoZGV2TmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSkge1xuICAgIGNhc2UgJ2lwaG9uZSBzaW11bGF0b3InOlxuICAgICAgZGV2aWNlTmFtZSA9ICdpUGhvbmUgNic7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpcGFkIHNpbXVsYXRvcic6XG4gICAgICAvLyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGZsb2F0aW5nIHBvaW50IGNvbXBhcmlzb24gYmVjYXVzZSBvZiB0aGVcbiAgICAgIC8vICAgbmF0dXJlIG9mIHRoZSBudW1iZXJzIGJlaW5nIGNvbXBhcmVkXG4gICAgICAvLyBpUGFkIFJldGluYSBpcyBubyBsb25nZXIgYXZhaWxhYmxlIGZvciBpb3MgMTAuM1xuICAgICAgLy8gICBzbyB3ZSBwaWNrIGFub3RoZXIgaVBhZCB0byB1c2UgYXMgZGVmYXVsdFxuICAgICAgZGV2aWNlTmFtZSA9IChwYXJzZUZsb2F0KHBsYXRmb3JtVmVyc2lvbikgPCAxMC4zKSA/ICdpUGFkIFJldGluYScgOiAnaVBhZCBBaXInO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaXBob25lIDgnOlxuICAgIGNhc2UgJ2lwaG9uZSA4IHBsdXMnOlxuICAgIGNhc2UgJ2lwaG9uZSB4JzpcbiAgICAgIC8vIFhjb2RlIDkuMCguMCkgbWlzLW5hbWVkIHRoZSBuZXcgZGV2aWNlc1xuICAgICAgaWYgKHhjb2RlVmVyc2lvbi5tYWpvciA9PT0gOSAmJlxuICAgICAgICAgIHhjb2RlVmVyc2lvbi5taW5vciA9PT0gMCAmJlxuICAgICAgICAgICghdXRpbC5oYXNWYWx1ZSh4Y29kZVZlcnNpb24ucGF0Y2gpIHx8IHhjb2RlVmVyc2lvbi5wYXRjaCA9PT0gMCkpIHtcbiAgICAgICAgY29uc3QgbmFtZXNNYXBwaW5nID0ge1xuICAgICAgICAgICdpcGhvbmUgOCc6ICdpUGhvbmUyMDE3LUEnLFxuICAgICAgICAgICdpcGhvbmUgOCBwbHVzJzogJ2lQaG9uZTIwMTctQicsXG4gICAgICAgICAgJ2lwaG9uZSB4JzogJ2lQaG9uZTIwMTctQydcbiAgICAgICAgfTtcbiAgICAgICAgZGV2aWNlTmFtZSA9IG5hbWVzTWFwcGluZ1tkZXZOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKGRldmljZU5hbWUgIT09IGRldk5hbWUpIHtcbiAgICBsb2cuZGVidWcoYENoYW5naW5nIGRldmljZU5hbWUgZnJvbSAnJHtkZXZOYW1lfScgdG8gJyR7ZGV2aWNlTmFtZX0nYCk7XG4gIH1cbiAgcmV0dXJuIGRldmljZU5hbWU7XG59XG5cbi8vIFRoaXMgbWFwIGNvbnRhaW5zIGRlcml2ZWQgZGF0YSBhdHRhY2htZW50IGZvbGRlcnMgYXMga2V5c1xuLy8gYW5kIHZhbHVlcyBhcmUgc3RhY2tzIG9mIHBlcm1zc2lvbiBtYXNrc1xuLy8gSXQgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSBwZXJtaXNzaW9ucyBjaGFuZ2Vcbi8vIG9uIHNoYXJlZCBmb2xkZXJzXG5jb25zdCBkZXJpdmVkRGF0YVBlcm1pc3Npb25zU3RhY2tzID0gbmV3IE1hcCgpO1xuXG5hc3luYyBmdW5jdGlvbiBhZGp1c3RXREFBdHRhY2htZW50c1Blcm1pc3Npb25zICh3ZGEsIHBlcm1zKSB7XG4gIGlmICghd2RhIHx8ICFhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSkge1xuICAgIGxvZy53YXJuKCdObyBXZWJEcml2ZXJBZ2VudCBkZXJpdmVkIGRhdGEgYXZhaWxhYmxlLCBzbyB1bmFibGUgdG8gc2V0IHBlcm1pc3Npb25zIG9uIFdEQSBhdHRhY2htZW50cyBmb2xkZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhdHRhY2htZW50c0ZvbGRlciA9IHBhdGguam9pbihhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSwgJ0xvZ3MvVGVzdC9BdHRhY2htZW50cycpO1xuICBjb25zdCBwZXJtc1N0YWNrID0gZGVyaXZlZERhdGFQZXJtaXNzaW9uc1N0YWNrcy5nZXQoYXR0YWNobWVudHNGb2xkZXIpIHx8IFtdO1xuICBpZiAocGVybXNTdGFjay5sZW5ndGgpIHtcbiAgICBpZiAoXy5sYXN0KHBlcm1zU3RhY2spID09PSBwZXJtcykge1xuICAgICAgcGVybXNTdGFjay5wdXNoKHBlcm1zKTtcbiAgICAgIGxvZy5pbmZvKGBOb3QgY2hhbmdpbmcgcGVybWlzc2lvbnMgb2YgJyR7YXR0YWNobWVudHNGb2xkZXJ9JyB0byAnJHtwZXJtc30nLCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IHNldCBieSB0aGUgb3RoZXIgc2Vzc2lvbmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGVybXNTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICBwZXJtc1N0YWNrLnBvcCgpO1xuICAgICAgbG9nLmluZm8oYE5vdCBjaGFuZ2luZyBwZXJtaXNzaW9ucyBvZiAnJHthdHRhY2htZW50c0ZvbGRlcn0nIHRvICcke3Blcm1zfScsIGJlY2F1c2UgdGhlIG90aGVyIHNlc3Npb24gZG9lcyBub3QgZXhwZWN0IHRoZW0gdG8gYmUgY2hhbmdlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBkZXJpdmVkRGF0YVBlcm1pc3Npb25zU3RhY2tzLnNldChhdHRhY2htZW50c0ZvbGRlciwgW3Blcm1zXSk7XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyhhdHRhY2htZW50c0ZvbGRlcikpIHtcbiAgICBsb2cuaW5mbyhgU2V0dGluZyAnJHtwZXJtc30nIHBlcm1pc3Npb25zIHRvICcke2F0dGFjaG1lbnRzRm9sZGVyfScgZm9sZGVyYCk7XG4gICAgYXdhaXQgZnMuY2htb2QoYXR0YWNobWVudHNGb2xkZXIsIHBlcm1zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9nLmluZm8oYFRoZXJlIGlzIG5vICR7YXR0YWNobWVudHNGb2xkZXJ9IGZvbGRlciwgc28gbm90IGNoYW5naW5nIHBlcm1pc3Npb25zYCk7XG59XG5cbi8vIFRoaXMgbWFwIGNvbnRhaW5zIGRlcml2ZWQgZGF0YSBsb2dzIGZvbGRlcnMgYXMga2V5c1xuLy8gYW5kIHZhbHVlcyBhcmUgdGhlIGNvdW50IG9mIHRpbWVzIHRoZSBwYXJ0aWN1bGFyXG4vLyBmb2xkZXIgaGFzIGJlZW4gc2NoZWR1bGVkIGZvciByZW1vdmFsXG5jb25zdCBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzID0gbmV3IE1hcCgpO1xuXG5hc3luYyBmdW5jdGlvbiBtYXJrU3lzdGVtRmlsZXNGb3JDbGVhbnVwICh3ZGEpIHtcbiAgaWYgKCF3ZGEgfHwgIWF3YWl0IHdkYS5yZXRyaWV2ZURlcml2ZWREYXRhUGF0aCgpKSB7XG4gICAgbG9nLndhcm4oJ05vIFdlYkRyaXZlckFnZW50IGRlcml2ZWQgZGF0YSBhdmFpbGFibGUsIHNvIHVuYWJsZSB0byBtYXJrIHN5c3RlbSBmaWxlcyBmb3IgY2xlYW51cCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGxvZ3NSb290ID0gcGF0aC5yZXNvbHZlKGF3YWl0IHdkYS5yZXRyaWV2ZURlcml2ZWREYXRhUGF0aCgpLCAnTG9ncycpO1xuICBsZXQgbWFya2Vyc0NvdW50ID0gMDtcbiAgaWYgKGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuaGFzKGxvZ3NSb290KSkge1xuICAgIG1hcmtlcnNDb3VudCA9IGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuZ2V0KGxvZ3NSb290KTtcbiAgfVxuICBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLnNldChsb2dzUm9vdCwgKyttYXJrZXJzQ291bnQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjbGVhclN5c3RlbUZpbGVzICh3ZGEpIHtcbiAgLy8gb25seSB3YW50IHRvIGNsZWFyIHRoZSBzeXN0ZW0gZmlsZXMgZm9yIHRoZSBwYXJ0aWN1bGFyIFdEQSB4Y29kZSBydW5cbiAgaWYgKCF3ZGEgfHwgIWF3YWl0IHdkYS5yZXRyaWV2ZURlcml2ZWREYXRhUGF0aCgpKSB7XG4gICAgbG9nLndhcm4oJ05vIFdlYkRyaXZlckFnZW50IGRlcml2ZWQgZGF0YSBhdmFpbGFibGUsIHNvIHVuYWJsZSB0byBjbGVhciBzeXN0ZW0gZmlsZXMnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsb2dzUm9vdCA9IHBhdGgucmVzb2x2ZShhd2FpdCB3ZGEucmV0cmlldmVEZXJpdmVkRGF0YVBhdGgoKSwgJ0xvZ3MnKTtcbiAgaWYgKGRlcml2ZWREYXRhQ2xlYW51cE1hcmtlcnMuaGFzKGxvZ3NSb290KSkge1xuICAgIGxldCBtYXJrZXJzQ291bnQgPSBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLmdldChsb2dzUm9vdCk7XG4gICAgZGVyaXZlZERhdGFDbGVhbnVwTWFya2Vycy5zZXQobG9nc1Jvb3QsIC0tbWFya2Vyc0NvdW50KTtcbiAgICBpZiAobWFya2Vyc0NvdW50ID4gMCkge1xuICAgICAgbG9nLmluZm8oYE5vdCBjbGVhbmluZyAnJHtsb2dzUm9vdH0nIGZvbGRlciwgYmVjYXVzZSB0aGUgb3RoZXIgc2Vzc2lvbiBkb2VzIG5vdCBleHBlY3QgaXQgdG8gYmUgY2xlYW5lZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBkZXJpdmVkRGF0YUNsZWFudXBNYXJrZXJzLnNldChsb2dzUm9vdCwgMCk7XG5cbiAgLy8gQ2xlYW5pbmcgdXAgYmlnIHRlbXBvcmFyeSBmaWxlcyBjcmVhdGVkIGJ5IFhDVGVzdDogaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzk0MTBcbiAgY29uc3QgY2xlYW51cENtZCA9IGBmaW5kIC1FIC9wcml2YXRlL3Zhci9mb2xkZXJzIGAgK1xuICAgIGAtcmVnZXggJy4qL1Nlc3Npb24tV2ViRHJpdmVyQWdlbnRSdW5uZXIuKlxcXFwubG9nJHwuKi9TdGFuZGFyZE91dHB1dEFuZFN0YW5kYXJkRXJyb3JcXFxcLnR4dCQnIGAgK1xuICAgIGAtdHlwZSBmIC1leGVjIHNoIC1jICdlY2hvIFwiXCIgPiBcInt9XCInIFxcXFw7YDtcbiAgY29uc3QgY2xlYW51cFRhc2sgPSBuZXcgU3ViUHJvY2VzcygnYmFzaCcsIFsnLWMnLCBjbGVhbnVwQ21kXSwge1xuICAgIGRldGFjaGVkOiB0cnVlLFxuICAgIHN0ZGlvOiBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnXSxcbiAgfSk7XG4gIGF3YWl0IGNsZWFudXBUYXNrLnN0YXJ0KDApO1xuICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhlIHRhc2sgdG8gYmUgY29tcGxldGVkLCBzaW5jZSBpdCBtaWdodCB0YWtlIGEgbG90IG9mIHRpbWVcbiAgLy8gV2Uga2VlcCBpdCBydW5uaW5nIGFmdGVyIEFwcGl1bSBwcm9jZXNzIGlzIGtpbGxlZFxuICBjbGVhbnVwVGFzay5wcm9jLnVucmVmKCk7XG4gIGxvZy5kZWJ1ZyhgU3RhcnRlZCBiYWNrZ3JvdW5kIFhDVGVzdCBsb2dzIGNsZWFudXA6ICR7Y2xlYW51cENtZH1gKTtcblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGxvZ3NSb290KSkge1xuICAgIGxvZy5pbmZvKGBDbGVhbmluZyB0ZXN0IGxvZ3MgaW4gJyR7bG9nc1Jvb3R9JyBmb2xkZXJgKTtcbiAgICBhd2FpdCBpb3NVdGlscy5jbGVhckxvZ3MoW2xvZ3NSb290XSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvZy5pbmZvKGBUaGVyZSBpcyBubyAke2xvZ3NSb290fSBmb2xkZXIsIHNvIG5vdCBjbGVhbmluZyBmaWxlc2ApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja0FwcFByZXNlbnQgKGFwcCkge1xuICBsb2cuZGVidWcoYENoZWNraW5nIHdoZXRoZXIgYXBwICcke2FwcH0nIGlzIGFjdHVhbGx5IHByZXNlbnQgb24gZmlsZSBzeXN0ZW1gKTtcbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKGFwcCkpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvdWxkIG5vdCBmaW5kIGFwcCBhdCAnJHthcHB9J2ApO1xuICB9XG4gIGxvZy5kZWJ1ZygnQXBwIGlzIHByZXNlbnQnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0RHJpdmVySW5mbyAoKSB7XG4gIGxldCBzdGF0ID0gYXdhaXQgZnMuc3RhdChwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nKSk7XG4gIGxldCBidWlsdCA9IHN0YXQubXRpbWUuZ2V0VGltZSgpO1xuXG4gIC8vIGdldCB0aGUgcGFja2FnZS5qc29uIGFuZCB0aGUgdmVyc2lvbiBmcm9tIGl0XG4gIGxldCBwa2cgPSByZXF1aXJlKF9fZmlsZW5hbWUuaW5kZXhPZignYnVpbGQvbGliL3V0aWxzJykgIT09IC0xID8gJy4uLy4uL3BhY2thZ2UuanNvbicgOiAnLi4vcGFja2FnZS5qc29uJyk7XG4gIGxldCB2ZXJzaW9uID0gcGtnLnZlcnNpb247XG5cbiAgbGV0IGluZm8gPSB7XG4gICAgYnVpbHQsXG4gICAgdmVyc2lvbixcbiAgfTtcbiAgcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbW1hbmRUaW1lb3V0cyAodmFsdWUpIHtcbiAgLy8gVGhlIHZhbHVlIGlzIG5vcm1hbGl6ZWQgYWxyZWFkeVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSB7fTtcbiAgLy8gVXNlIGFzIGRlZmF1bHQgdGltZW91dCBmb3IgYWxsIGNvbW1hbmRzIGlmIGEgc2luZ2xlIGludGVnZXIgdmFsdWUgaXMgcHJvdmlkZWRcbiAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICByZXN1bHRbREVGQVVMVF9USU1FT1VUX0tFWV0gPSBfLnRvSW50ZWdlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIEpTT04gb2JqZWN0IGhhcyBiZWVuIHByb3ZpZGVkLiBMZXQncyBwYXJzZSBpdFxuICB0cnkge1xuICAgIHJlc3VsdCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFwiY29tbWFuZFRpbWVvdXRzXCIgY2FwYWJpbGl0eSBzaG91bGQgYmUgYSB2YWxpZCBKU09OIG9iamVjdC4gXCIke3ZhbHVlfVwiIHdhcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgZm9yIChsZXQgW2NtZCwgdGltZW91dF0gb2YgXy50b1BhaXJzKHJlc3VsdCkpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHRpbWVvdXQpIHx8IHRpbWVvdXQgPD0gMCkge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSB0aW1lb3V0IGZvciBcIiR7Y21kfVwiIHNob3VsZCBiZSBhIHZhbGlkIG5hdHVyYWwgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gXCIke3RpbWVvdXR9XCIgd2FzIGdpdmVuIGluc3RlYWRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb2Nlc3MgaWQgb2YgdGhlIG1vc3QgcmVjZW50IHJ1bm5pbmcgYXBwbGljYXRpb25cbiAqIGhhdmluZyB0aGUgcGFydGljdWxhciBjb21tYW5kIGxpbmUgcGF0dGVybi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGdyZXBQYXR0ZXJuIC0gcGdyZXAtY29tcGF0aWJsZSBzZWFyY2ggcGF0dGVybi5cbiAqIEByZXR1cm4ge3N0cmluZ30gRWl0aGVyIGEgcHJvY2VzcyBpZCBvciBudWxsIGlmIG5vIG1hdGNoZXMgd2VyZSBmb3VuZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UGlkVXNpbmdQYXR0ZXJuIChwZ3JlcFBhdHRlcm4pIHtcbiAgY29uc3QgYXJncyA9IFsnLW5pZicsIHBncmVwUGF0dGVybl07XG4gIHRyeSB7XG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdwZ3JlcCcsIGFyZ3MpO1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlSW50KHN0ZG91dCwgMTApO1xuICAgIGlmIChpc05hTihwaWQpKSB7XG4gICAgICBsb2cuZGVidWcoYENhbm5vdCBwYXJzZSBwcm9jZXNzIGlkIGZyb20gJ3BncmVwICR7YXJncy5qb2luKCcgJyl9JyBvdXRwdXQ6ICR7c3Rkb3V0fWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBgJHtwaWR9YDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGAncGdyZXAgJHthcmdzLmpvaW4oJyAnKX0nIGRpZG4ndCBkZXRlY3QgYW55IG1hdGNoaW5nIHByb2Nlc3Nlcy4gUmV0dXJuIGNvZGU6ICR7ZXJyLmNvZGV9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBLaWxsIGEgcHJvY2VzcyBoYXZpbmcgdGhlIHBhcnRpY3VsYXIgY29tbWFuZCBsaW5lIHBhdHRlcm4uXG4gKiBUaGlzIG1ldGhvZCB0cmllcyB0byBzZW5kIFNJR0lOVCwgU0lHVEVSTSBhbmQgU0lHS0lMTCB0byB0aGVcbiAqIG1hdGNoZWQgcHJvY2Vzc2VzIGluIHRoaXMgb3JkZXIgaWYgdGhlIHByb2Nlc3MgaXMgc3RpbGwgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGdyZXBQYXR0ZXJuIC0gcGdyZXAtY29tcGF0aWJsZSBzZWFyY2ggcGF0dGVybi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24ga2lsbEFwcFVzaW5nUGF0dGVybiAocGdyZXBQYXR0ZXJuKSB7XG4gIGZvciAoY29uc3Qgc2lnbmFsIG9mIFsyLCAxNSwgOV0pIHtcbiAgICBpZiAoIWF3YWl0IGdldFBpZFVzaW5nUGF0dGVybihwZ3JlcFBhdHRlcm4pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbYC0ke3NpZ25hbH1gLCAnLWlmJywgcGdyZXBQYXR0ZXJuXTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYygncGtpbGwnLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgcGtpbGwgJHthcmdzLmpvaW4oJyAnKX0gLT4gJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgYXdhaXQgQi5kZWxheSgxMDApO1xuICB9XG59XG5cbi8qKlxuICogS2lsbHMgcnVubmluZyBYQ1Rlc3QgcHJvY2Vzc2VzIGZvciB0aGUgcGFydGljdWxhciBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIFVESUQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2ltdWxhdG9yIC0gRXF1YWxzIHRvIHRydWUgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIGEgU2ltdWxhdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBQb3NzaWJsZSBrZXlzIGFyZTpcbiAqICAgLSB7c3RyaW5nfG51bWJlcn0gd2RhTG9jYWxQb3J0OiBUaGUgbnVtYmVyIG9mIGxvY2FsIHBvcnQgV0RBIGlzIGxpc3RlbmluZyBvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzZXRYQ1Rlc3RQcm9jZXNzZXMgKHVkaWQsIGlzU2ltdWxhdG9yLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcHJvY2Vzc1BhdHRlcm5zID0gW2B4Y29kZWJ1aWxkLioke3VkaWR9YF07XG4gIGlmIChvcHRzLndkYUxvY2FsUG9ydCkge1xuICAgIHByb2Nlc3NQYXR0ZXJucy5wdXNoKGBpcHJveHkgJHtvcHRzLndkYUxvY2FsUG9ydH1gKTtcbiAgfSBlbHNlIGlmICghaXNTaW11bGF0b3IpIHtcbiAgICBwcm9jZXNzUGF0dGVybnMucHVzaChgaXByb3h5Lioke3VkaWR9YCk7XG4gIH1cbiAgaWYgKGlzU2ltdWxhdG9yKSB7XG4gICAgcHJvY2Vzc1BhdHRlcm5zLnB1c2goYCR7dWRpZH0uKlhDVFJ1bm5lcmApO1xuICB9XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBydW5uaW5nIHByb2Nlc3NlcyAnJHtwcm9jZXNzUGF0dGVybnMuam9pbignLCAnKX0nIGZvciB0aGUgZGV2aWNlICR7dWRpZH0uLi5gKTtcbiAgZm9yIChjb25zdCBwZ3JlcFBhdHRlcm4gb2YgcHJvY2Vzc1BhdHRlcm5zKSB7XG4gICAgYXdhaXQga2lsbEFwcFVzaW5nUGF0dGVybihwZ3JlcFBhdHRlcm4pO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByaW50VXNlciAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnd2hvYW1pJyk7XG4gICAgbG9nLmRlYnVnKGBDdXJyZW50IHVzZXI6ICcke3N0ZG91dC50cmltKCl9J2ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cuZGVidWcoYFVuYWJsZSB0byBnZXQgdXNlcm5hbWUgcnVubmluZyBzZXJ2ZXI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJpbnRMaWJpbW9iaWxlZGV2aWNlSW5mbyAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnYnJldycsIFsnaW5mbycsICdsaWJpbW9iaWxlZGV2aWNlJ10pO1xuICAgIGxldCBtYXRjaCA9IC9saWJpbW9iaWxlZGV2aWNlOiguKykvLmV4ZWMoc3Rkb3V0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ3VycmVudCB2ZXJzaW9uIG9mIGxpYmltb2JpbGVkZXZpY2U6ICR7bWF0Y2hbMV0udHJpbSgpfWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLmRlYnVnKGBVbmFibGUgdG8gZ2V0IHZlcnNpb24gb2YgbGliaW1vYmlsZWRldmljZTogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgSURzIG9mIHByb2Nlc3NlcyBsaXN0ZW5pbmcgb24gdGhlIHBhcnRpY3VsYXIgc3lzdGVtIHBvcnQuXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGx5IGFkZGl0aW9uYWwgZmlsdGVyaW5nIGJhc2VkIG9uIHRoZVxuICogcHJvY2VzcyBjb21tYW5kIGxpbmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwb3J0IC0gVGhlIHBvcnQgbnVtYmVyLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGZpbHRlcmluZ0Z1bmMgLSBPcHRpb25hbCBsYW1iZGEgZnVuY3Rpb24sIHdoaWNoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVzIGNvbW1hbmQgbGluZSBzdHJpbmcgb2YgdGhlIHBhcnRpY3VsYXIgcHJvY2Vzc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5pbmcgb24gZ2l2ZW4gcG9ydCwgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVyblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXIgdHJ1ZSBvciBmYWxzZSB0byBpbmNsdWRlL2V4Y2x1ZGUgdGhlIGNvcnJlc3BvbmRpbmcgUElEXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIHJlc3VsdGluZyBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAtIHRoZSBsaXN0IG9mIG1hdGNoZWQgcHJvY2VzcyBpZHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBJRHNMaXN0ZW5pbmdPblBvcnQgKHBvcnQsIGZpbHRlcmluZ0Z1bmMgPSBudWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0cnkge1xuICAgIC8vIFRoaXMgb25seSB3b3JrcyBzaW5jZSBNYWMgT1MgWCBFbCBDYXBpdGFuXG4gICAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdsc29mJywgWyctdGknLCBgdGNwOiR7cG9ydH1gXSk7XG4gICAgcmVzdWx0LnB1c2goLi4uKHN0ZG91dC50cmltKCkuc3BsaXQoL1xcbisvKSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghXy5pc0Z1bmN0aW9uKGZpbHRlcmluZ0Z1bmMpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gYXdhaXQgQi5maWx0ZXIocmVzdWx0LCBhc3luYyAoeCkgPT4ge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygncHMnLCBbJy1wJywgeCwgJy1vJywgJ2NvbW1hbmQnXSk7XG4gICAgcmV0dXJuIGF3YWl0IGZpbHRlcmluZ0Z1bmMoc3Rkb3V0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVXBsb2FkT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcGFzcyAtIFRoZSBwYXNzd29yZCBmb3IgdGhlIHJlbW90ZSBhdXRoZW50aWNhdGlvbi4gT25seSB3b3JrcyBpZiBgcmVtb3RlUGF0aGAgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG1ldGhvZCAtIFRoZSBodHRwIG11bHRpcGFydCB1cGxvYWQgbWV0aG9kIG5hbWUuIFRoZSAnUFVUJyBvbmUgaXMgdXNlZCBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqL1xuXG5cbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gbG9jYWwgZmlsZSB0byBiYXNlNjQgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBzdHJpbmdcbiAqIG9yIHVwbG9hZHMgaXQgdG8gYSByZW1vdGUgc2VydmVyIHVzaW5nIGh0dHAvaHR0cHMgb3IgZnRwIHByb3RvY29sc1xuICogaWYgYHJlbW90ZVBhdGhgIGlzIHNldFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbEZpbGUgLSBUaGUgcGF0aCB0byBhbiBleGlzdGluZyBsb2NhbCBmaWxlXG4gKiBAcGFyYW0gez9zdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgcmVtb3RlIGxvY2F0aW9uLCB3aGVyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBmaWxlIHNob3VsZCBiZSB1cGxvYWRlZFxuICogQHBhcmFtIHs/VXBsb2FkT3B0aW9uc30gdXBsb2FkT3B0aW9ucyAtIFNldCBvZiB1cGxvYWQgb3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gRWl0aGVyIGFuIGVtcHR5IHN0cmluZyBpZiB0aGUgdXBsb2FkIHdhcyBzdWNjZXNzZnVsIG9yXG4gKiBiYXNlNjQtZW5jb2RlZCBmaWxlIHJlcHJlc2VudGF0aW9uIGlmIGByZW1vdGVQYXRoYCBpcyBmYWxzeVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyB1cGxvYWQgZmFpbHVyZSBvciB0aGUgZmlsZSBjb250ZW50IGlzIHRvbyBiaWdcbiAqIHRvIGZpdCBpbiB0aGUgYXZhaWxhYmxlIHByb2Nlc3MgbWVtb3J5LlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNvZGVCYXNlNjRPclVwbG9hZCAobG9jYWxGaWxlLCByZW1vdGVQYXRoID0gbnVsbCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKGxvY2FsRmlsZSkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIGZpbGUgYXQgJyR7bG9jYWxGaWxlfScgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGFjY2Vzc2libGVgKTtcbiAgfVxuXG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQobG9jYWxGaWxlKTtcbiAgbG9nLmRlYnVnKGBUaGUgc2l6ZSBvZiB0aGUgZmlsZSBpcyAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9YCk7XG4gIGlmIChfLmlzRW1wdHkocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCBtYXhNZW1vcnlMaW1pdCA9IHY4LmdldEhlYXBTdGF0aXN0aWNzKCkudG90YWxfYXZhaWxhYmxlX3NpemUgLyAyO1xuICAgIGlmIChzaXplID49IG1heE1lbW9yeUxpbWl0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWFkICcke2xvY2FsRmlsZX0nIHRvIHRoZSBtZW1vcnksIGJlY2F1c2UgdGhlIGZpbGUgaXMgdG9vIGxhcmdlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAoJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSA+PSAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcobWF4TWVtb3J5TGltaXQpfSkuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBUcnkgdG8gcHJvdmlkZSBhIGxpbmsgdG8gYSByZW1vdGUgd3JpdGFibGUgbG9jYXRpb24gaW5zdGVhZCBvciBpbmNyZWFzZSB0aGUgdmFsdWUgb2YgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCdtYXhfb2xkX3NwYWNlX3NpemUnIHNlcnZlciBhcmd1bWVudC5gKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGxvY2FsRmlsZSk7XG4gICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgcmVtb3RlVXJsID0gdXJsLnBhcnNlKHJlbW90ZVBhdGgpO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBjb25zdCB7dXNlciwgcGFzcywgbWV0aG9kfSA9IHVwbG9hZE9wdGlvbnM7XG4gIGlmIChyZW1vdGVVcmwucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHVybDogcmVtb3RlVXJsLmhyZWYsXG4gICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUFVUJyxcbiAgICAgIG11bHRpcGFydDogW3sgYm9keTogX2ZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxGaWxlKSB9XSxcbiAgICB9O1xuICAgIGlmICh1c2VyICYmIHBhc3MpIHtcbiAgICAgIG9wdGlvbnMuYXV0aCA9IHt1c2VyLCBwYXNzfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVtb3RlVXJsLnByb3RvY29sID09PSAnZnRwOicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgaG9zdDogcmVtb3RlVXJsLmhvc3RuYW1lLFxuICAgICAgcG9ydDogcmVtb3RlVXJsLnBvcnQgfHwgMjEsXG4gICAgfTtcbiAgICBpZiAodXNlciAmJiBwYXNzKSB7XG4gICAgICBvcHRpb25zLnVzZXIgPSB1c2VyO1xuICAgICAgb3B0aW9ucy5wYXNzID0gcGFzcztcbiAgICB9XG4gIH1cbiAgYXdhaXQgbmV0LnVwbG9hZEZpbGUobG9jYWxGaWxlLCByZW1vdGVQYXRoLCBvcHRpb25zKTtcbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFN0b3BzIGFuZCByZW1vdmVzIGFsbCB3ZWIgc29ja2V0IGhhbmRsZXJzIHRoYXQgYXJlIGxpc3RlbmluZ1xuICogaW4gc2NvcGUgb2YgdGhlIGN1cnJlY3Qgc2Vzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmVyIC0gVGhlIGluc3RhbmNlIG9mIE5vZGVKcyBIVFRQIHNlcnZlcixcbiAqIHdoaWNoIGhvc3RzIEFwcGl1bVxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JZCAtIFRoZSBpZCBvZiB0aGUgY3VycmVudCBzZXNzaW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZUFsbFNlc3Npb25XZWJTb2NrZXRIYW5kbGVycyAoc2VydmVyLCBzZXNzaW9uSWQpIHtcbiAgaWYgKCFzZXJ2ZXIgfHwgIV8uaXNGdW5jdGlvbihzZXJ2ZXIuZ2V0V2ViU29ja2V0SGFuZGxlcnMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWN0aXZlSGFuZGxlcnMgPSBhd2FpdCBzZXJ2ZXIuZ2V0V2ViU29ja2V0SGFuZGxlcnMoc2Vzc2lvbklkKTtcbiAgZm9yIChjb25zdCBwYXRobmFtZSBvZiBfLmtleXMoYWN0aXZlSGFuZGxlcnMpKSB7XG4gICAgYXdhaXQgc2VydmVyLnJlbW92ZVdlYlNvY2tldEhhbmRsZXIocGF0aG5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgdGhlIGdpdmVuIGFwcGxpY2F0aW9uIGlzIGNvbXBhdGlibGUgdG8gdGhlXG4gKiBwbGF0Zm9ybSB3aGVyZSBpdCBpcyBnb2luZyB0byBiZSBpbnN0YWxsZWQgYW5kIHRlc3RlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwIC0gVGhlIGFjdHVhbCBwYXRoIHRvIHRoZSBhcHBsaWNhdGlvbiBidW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTaW11bGF0b3IgLSBTaG91bGQgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGUgdGVzdCB3aWxsIGJlIGV4ZWN1dGVkIG9uIFNpbXVsYXRvclxuICogQHJldHVybnMgez9ib29sZWFufSBUaGUgZnVuY3Rpb24gcmV0dXJucyBgbnVsbGAgaWYgdGhlIGFwcGxpY2F0aW9uIGRvZXMgbm90IGV4aXN0IG9yIHRoZXJlIGlzIG5vXG4gKiBgQ0ZCdW5kbGVTdXBwb3J0ZWRQbGF0Zm9ybXNgIGtleSBpbiBpdHMgSW5mby5wbGlzdCBtYW5pZmVzdC5cbiAqIGB0cnVlYCBpcyByZXR1cm5lZCBpZiB0aGUgYnVuZGxlIGFyY2hpdGVjdHVyZSBtYXRjaGVzIHRoZSBkZXZpY2UgYXJjaGl0ZWN0dXJlLlxuICogQHRocm93cyB7RXJyb3J9IElmIGJ1bmRsZSBhcmNoaXRlY3R1cmUgZG9lcyBub3QgbWF0Y2ggdGhlIGRldmljZSBhcmNoaXRlY3R1cmUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUFwcGxpY2F0aW9uUGxhdGZvcm0gKGFwcCwgaXNTaW11bGF0b3IpIHtcbiAgbG9nLmRlYnVnKCdWZXJpZnlpbmcgYXBwbGljYXRpb24gcGxhdGZvcm0nKTtcblxuICBjb25zdCBpbmZvUGxpc3QgPSBwYXRoLnJlc29sdmUoYXBwLCAnSW5mby5wbGlzdCcpO1xuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhpbmZvUGxpc3QpKSB7XG4gICAgbG9nLmRlYnVnKGAnJHtpbmZvUGxpc3R9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qge0NGQnVuZGxlU3VwcG9ydGVkUGxhdGZvcm1zfSA9IGF3YWl0IHBsaXN0LnBhcnNlUGxpc3RGaWxlKGluZm9QbGlzdCk7XG4gIGxvZy5kZWJ1ZyhgQ0ZCdW5kbGVTdXBwb3J0ZWRQbGF0Zm9ybXM6ICR7SlNPTi5zdHJpbmdpZnkoQ0ZCdW5kbGVTdXBwb3J0ZWRQbGF0Zm9ybXMpfWApO1xuICBpZiAoIV8uaXNBcnJheShDRkJ1bmRsZVN1cHBvcnRlZFBsYXRmb3JtcykpIHtcbiAgICBsb2cuZGVidWcoYENGQnVuZGxlU3VwcG9ydGVkUGxhdGZvcm1zIGtleSBkb2VzIG5vdCBleGlzdCBpbiAnJHtpbmZvUGxpc3R9J2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaXNBcHBTdXBwb3J0ZWQgPSAoaXNTaW11bGF0b3IgJiYgQ0ZCdW5kbGVTdXBwb3J0ZWRQbGF0Zm9ybXMuaW5jbHVkZXMoJ2lQaG9uZVNpbXVsYXRvcicpKVxuICAgIHx8ICghaXNTaW11bGF0b3IgJiYgQ0ZCdW5kbGVTdXBwb3J0ZWRQbGF0Zm9ybXMuaW5jbHVkZXMoJ2lQaG9uZU9TJykpO1xuICBpZiAoaXNBcHBTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7aXNTaW11bGF0b3IgPyAnU2ltdWxhdG9yJyA6ICdSZWFsIGRldmljZSd9IGFyY2hpdGVjdHVyZSBpcyB1bnN1cHBvcnRlZCBieSB0aGUgJyR7YXBwfScgYXBwbGljYXRpb24uIGAgK1xuICAgICAgICAgICAgICAgICAgYE1ha2Ugc3VyZSB0aGUgY29ycmVjdCBkZXBsb3ltZW50IHRhcmdldCBoYXMgYmVlbiBzZWxlY3RlZCBmb3IgaXRzIGNvbXBpbGF0aW9uIGluIFhjb2RlLmApO1xufVxuXG5leHBvcnQgeyBkZXRlY3RVZGlkLCBnZXRBbmRDaGVja1hjb2RlVmVyc2lvbiwgZ2V0QW5kQ2hlY2tJb3NTZGtWZXJzaW9uLFxuICAgICAgICAgYWRqdXN0V0RBQXR0YWNobWVudHNQZXJtaXNzaW9ucywgY2hlY2tBcHBQcmVzZW50LCBnZXREcml2ZXJJbmZvLFxuICAgICAgICAgY2xlYXJTeXN0ZW1GaWxlcywgdHJhbnNsYXRlRGV2aWNlTmFtZSwgbm9ybWFsaXplQ29tbWFuZFRpbWVvdXRzLFxuICAgICAgICAgREVGQVVMVF9USU1FT1VUX0tFWSwgcmVzZXRYQ1Rlc3RQcm9jZXNzZXMsIGdldFBpZFVzaW5nUGF0dGVybixcbiAgICAgICAgIG1hcmtTeXN0ZW1GaWxlc0ZvckNsZWFudXAsIHByaW50VXNlciwgcHJpbnRMaWJpbW9iaWxlZGV2aWNlSW5mbyxcbiAgICAgICAgIGdldFBJRHNMaXN0ZW5pbmdPblBvcnQsIGVuY29kZUJhc2U2NE9yVXBsb2FkLCByZW1vdmVBbGxTZXNzaW9uV2ViU29ja2V0SGFuZGxlcnMsXG4gICAgICAgICB2ZXJpZnlBcHBsaWNhdGlvblBsYXRmb3JtIH07XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
