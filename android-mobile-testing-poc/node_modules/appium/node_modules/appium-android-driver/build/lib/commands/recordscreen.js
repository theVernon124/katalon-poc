'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _asyncbox = require('asyncbox');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _temp = require('temp');

var _temp2 = _interopRequireDefault(_temp);

var commands = {},
    extensions = {};

var RETRY_PAUSE = 1000;
var MAX_RECORDING_TIME_SEC = 60 * 3;
var DEFAULT_RECORDING_TIME_SEC = MAX_RECORDING_TIME_SEC;
var PROCESS_SHUTDOWN_TIMEOUT_SEC = 5;
var SCREENRECORD_BINARY = 'screenrecord';
var DEFAULT_EXT = '.mp4';
var MIN_EMULATOR_API_LEVEL = 27;

function extractCurrentRecordingPath(adb, pids) {
  var lsofOutput, _ref, output, pattern, matches;

  return _regeneratorRuntime.async(function extractCurrentRecordingPath$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        lsofOutput = '';
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(adb.shell(['lsof', '-p', pids.join(',')]));

      case 4:
        _ref = context$1$0.sent;
        output = _ref.output;

        lsofOutput = output;
        context$1$0.next = 13;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](1);

        _logger2['default'].warn('Cannot extract the path to the current screen capture. ' + ('Original error: ' + context$1$0.t0.message));
        return context$1$0.abrupt('return', null);

      case 13:
        _logger2['default'].debug('Got the following output from lsof: ' + lsofOutput);
        pattern = new RegExp(/\d+\s+(\/.*\.mp4)/);
        matches = pattern.exec(lsofOutput);
        return context$1$0.abrupt('return', _lodash2['default'].isEmpty(matches) ? null : _lodash2['default'].last(matches));

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 9]]);
}

function finishScreenCapture(adb, pids) {
  return _regeneratorRuntime.async(function finishScreenCapture$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(adb.shell(['kill', '-2'].concat(_toConsumableArray(pids))));

      case 3:
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);
        return context$1$0.abrupt('return', true);

      case 8:
        context$1$0.prev = 8;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var output, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pid;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(adb.shell(['ps']));

              case 3:
                output = context$2$0.sent;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$2$0.prev = 7;
                _iterator = _getIterator(pids);

              case 9:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  context$2$0.next = 16;
                  break;
                }

                pid = _step.value;

                if (!new RegExp('\\b' + pid + '\\b[^\\n]+\\b' + SCREENRECORD_BINARY + '$', 'm').test(output)) {
                  context$2$0.next = 13;
                  break;
                }

                return context$2$0.abrupt('return', false);

              case 13:
                _iteratorNormalCompletion = true;
                context$2$0.next = 9;
                break;

              case 16:
                context$2$0.next = 22;
                break;

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](7);
                _didIteratorError = true;
                _iteratorError = context$2$0.t0;

              case 22:
                context$2$0.prev = 22;
                context$2$0.prev = 23;

                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }

              case 25:
                context$2$0.prev = 25;

                if (!_didIteratorError) {
                  context$2$0.next = 28;
                  break;
                }

                throw _iteratorError;

              case 28:
                return context$2$0.finish(25);

              case 29:
                return context$2$0.finish(22);

              case 30:
                return context$2$0.abrupt('return', true);

              case 33:
                context$2$0.prev = 33;
                context$2$0.t1 = context$2$0['catch'](0);

                _logger2['default'].warn(context$2$0.t1.message);
                return context$2$0.abrupt('return', false);

              case 37:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[0, 33], [7, 18, 22, 30], [23,, 25, 29]]);
        }, { waitMs: PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000, intervalMs: 500 }));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t1 = context$1$0['catch'](8);
        return context$1$0.abrupt('return', false);

      case 16:
        return context$1$0.abrupt('return', true);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [8, 13]]);
}

function uploadRecordedMedia(adb, pathOnDevice) {
  var remotePath = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
  var uploadOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var localFile, _ref2, size, memoryUsage, maxMemoryLimit, content, remoteUrl, options, user, pass, method;

  return _regeneratorRuntime.async(function uploadRecordedMedia$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        localFile = _temp2['default'].path({ prefix: 'appium', suffix: DEFAULT_EXT });
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(adb.pull(pathOnDevice, localFile));

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localFile));

      case 6:
        _ref2 = context$1$0.sent;
        size = _ref2.size;

        _logger2['default'].debug('The size of the recent screen recording is ' + _appiumSupport.util.toReadableSizeString(size));

        if (!_lodash2['default'].isEmpty(remotePath)) {
          context$1$0.next = 18;
          break;
        }

        memoryUsage = process.memoryUsage();
        maxMemoryLimit = (memoryUsage.heapTotal - memoryUsage.heapUsed) / 2;

        if (!(size >= maxMemoryLimit)) {
          context$1$0.next = 14;
          break;
        }

        throw new Error('Cannot read the recorded media \'' + pathOnDevice + '\' to the memory, ' + 'because the file is too large ' + ('(' + _appiumSupport.util.toReadableSizeString(size) + ' >= ' + _appiumSupport.util.toReadableSizeString(maxMemoryLimit) + '). ') + 'Try to provide a link to a remote writable location instead.');

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localFile));

      case 16:
        content = context$1$0.sent;
        return context$1$0.abrupt('return', content.toString('base64'));

      case 18:
        remoteUrl = _url2['default'].parse(remotePath);
        options = {};
        user = uploadOptions.user;
        pass = uploadOptions.pass;
        method = uploadOptions.method;

        if (remoteUrl.protocol.startsWith('http')) {
          options = {
            url: remoteUrl.href,
            method: method || 'PUT',
            multipart: [{ body: _fs3['default'].createReadStream(localFile) }]
          };
          if (user && pass) {
            options.auth = { user: user, pass: pass };
          }
        } else if (remoteUrl.protocol.startsWith('ftp')) {
          options = {
            host: remoteUrl.hostname,
            port: remoteUrl.port || 21
          };
          if (user && pass) {
            options.user = user;
            options.pass = pass;
          }
        }
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.net.uploadFile(localFile, remotePath, options));

      case 26:
        return context$1$0.abrupt('return', '');

      case 27:
        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(localFile));

      case 30:
        context$1$0.prev = 30;
        context$1$0.next = 33;
        return _regeneratorRuntime.awrap(adb.rimraf(pathOnDevice));

      case 33:
        context$1$0.next = 38;
        break;

      case 35:
        context$1$0.prev = 35;
        context$1$0.t0 = context$1$0['catch'](30);

        _logger2['default'].warn('Cannot delete the recorded screen media \'' + pathOnDevice + '\' from the device. Continuing anyway');

      case 38:
        return context$1$0.finish(27);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1,, 27, 39], [30, 35]]);
}

function verifyScreenRecordIsSupported(adb, isEmulator) {
  var apiLevel;
  return _regeneratorRuntime.async(function verifyScreenRecordIsSupported$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(adb.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;

        if (!(isEmulator && apiLevel < MIN_EMULATOR_API_LEVEL)) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Screen recording does not work on emulators running Android API level less than ' + MIN_EMULATOR_API_LEVEL);

      case 5:
        if (!(apiLevel < 19)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error('Screen recording not available on API Level ' + apiLevel + '. Minimum API Level is 19.');

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * @typedef {Object} StartRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the captured video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 *                                  This option only has an effect if there is screen recording process in progreess
 *                                  and `forceRestart` parameter is not set to `true`.
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 * @property {?string} videoSize - The format is widthxheight.
 *                  The default value is the device's native display resolution (if supported),
 *                  1280x720 if not. For best results,
 *                  use a size supported by your device's Advanced Video Coding (AVC) encoder.
 *                  For example, "1280x720"
 * @property {?boolean} bugReport - Set it to `true` in order to display additional information on the video overlay,
 *                                  such as a timestamp, that is helpful in videos captured to illustrate bugs.
 *                                  This option is only supported since API level 27 (Android P).
 * @property {?string|number} timeLimit - The maximum recording time, in seconds. The default and maximum value is 180 (3 minutes).
 * @property {?string|number} bitRate - The video bit rate for the video, in megabits per second.
 *                The default value is 4. You can increase the bit rate to improve video quality,
 *                but doing so results in larger movie files.
 * @property {?boolean} forceRestart - Whether to try to catch and upload/return the currently running screen recording
 *                                     (`false`, the default setting) or ignore the result of it and start a new recording
 *                                     immediately (`true`).
 */

/**
 * Record the display of a real devices running Android 4.4 (API level 19) and higher.
 * Emulators are supported since API level 27 (Android P).
 * It records screen activity to an MPEG-4 file. Audio is not recorded with the video file.
 * If screen recording has been already started then the command will stop it forcefully and start a new one.
 * The previously recorded video file will be deleted.
 *
 * @param {?StartRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if
 *                   any screen recording is currently running or an empty string.
 * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
 */
commands.startRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var videoSize, _options$timeLimit, timeLimit, bugReport, bitRate, forceRestart, result, pids, pathOnDevice, cmd;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        videoSize = options.videoSize;
        _options$timeLimit = options.timeLimit;
        timeLimit = _options$timeLimit === undefined ? DEFAULT_RECORDING_TIME_SEC : _options$timeLimit;
        bugReport = options.bugReport;
        bitRate = options.bitRate;
        forceRestart = options.forceRestart;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 8:
        result = '';

        if (forceRestart) {
          context$1$0.next = 13;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.stopRecordingScreen(options));

      case 12:
        result = context$1$0.sent;

      case 13:
        context$1$0.prev = 13;
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.adb.getPIDsByName(SCREENRECORD_BINARY));

      case 16:
        context$1$0.t0 = function (p) {
          return '' + p;
        };

        pids = context$1$0.sent.map(context$1$0.t0);

        if (_lodash2['default'].isEmpty(pids)) {
          context$1$0.next = 21;
          break;
        }

        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.adb.shell(['kill'].concat(_toConsumableArray(pids))));

      case 21:
        context$1$0.next = 26;
        break;

      case 23:
        context$1$0.prev = 23;
        context$1$0.t1 = context$1$0['catch'](13);

        _logger2['default'].errorAndThrow('Unable to stop screen recording: ' + context$1$0.t1.message);

      case 26:
        if (_lodash2['default'].isEmpty(this._recentScreenRecordingPath)) {
          context$1$0.next = 35;
          break;
        }

        context$1$0.prev = 27;
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(this.adb.rimraf(this._recentScreenRecordingPath));

      case 30:
        context$1$0.next = 34;
        break;

      case 32:
        context$1$0.prev = 32;
        context$1$0.t2 = context$1$0['catch'](27);

      case 34:
        this._recentScreenRecordingPath = null;

      case 35:
        pathOnDevice = '/sdcard/' + Math.floor(new Date()) + DEFAULT_EXT;
        cmd = [SCREENRECORD_BINARY];

        if (_appiumSupport.util.hasValue(videoSize)) {
          cmd.push('--size', videoSize);
        }
        if (_appiumSupport.util.hasValue(timeLimit)) {
          cmd.push('--time-limit', '' + timeLimit);
        }
        if (_appiumSupport.util.hasValue(bitRate)) {
          cmd.push('--bit-rate', '' + bitRate);
        }
        if (bugReport) {
          cmd.push('--bugreport');
        }
        cmd.push(pathOnDevice);

        // wrap in a manual Promise so we can handle errors in adb shell operation
        context$1$0.next = 44;
        return _regeneratorRuntime.awrap(new _bluebird2['default'](function callee$1$0(resolve, reject) {
          var err, timeout;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            var _this2 = this;

            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                err = null;
                timeout = Math.floor(parseFloat(timeLimit) * 1000);

                if (!(timeout > MAX_RECORDING_TIME_SEC * 1000 || timeout <= 0)) {
                  context$2$0.next = 4;
                  break;
                }

                return context$2$0.abrupt('return', reject(new Error('The timeLimit value must be in range (0, ' + MAX_RECORDING_TIME_SEC + '] seconds. ' + ('The value of ' + timeLimit + ' has been passed instead.'))));

              case 4:
                _logger2['default'].debug('Beginning screen recording with command: \'adb shell ' + cmd.join(' ') + '\'' + ('Will timeout in ' + timeout / 1000 + ' s'));
                // screenrecord has its owen timer, so we only use this one as a safety precaution
                timeout += PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000 * 2;
                // do not await here, as the call runs in the background and we check for its product
                this.adb.shell(cmd, { timeout: timeout, killSignal: 'SIGINT' })['catch'](function (e) {
                  err = e;
                });

                // there is the delay time to start recording the screen, so, wait until it is ready.
                // the ready condition is
                //   1. check the movie file is created
                //   2. check it is started to capture the screen
                context$2$0.prev = 7;
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(10, RETRY_PAUSE, function callee$2$0() {
                  var size;
                  return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                    while (1) switch (context$3$0.prev = context$3$0.next) {
                      case 0:
                        if (!err) {
                          context$3$0.next = 2;
                          break;
                        }

                        return context$3$0.abrupt('return');

                      case 2:
                        context$3$0.next = 4;
                        return _regeneratorRuntime.awrap(this.adb.fileSize(pathOnDevice));

                      case 4:
                        size = context$3$0.sent;

                        if (!(size <= 32)) {
                          context$3$0.next = 7;
                          break;
                        }

                        throw new Error('Remote file \'' + pathOnDevice + '\' found but it is still too small: ' + size + ' bytes');

                      case 7:
                      case 'end':
                        return context$3$0.stop();
                    }
                  }, null, _this2);
                }));

              case 10:
                context$2$0.next = 15;
                break;

              case 12:
                context$2$0.prev = 12;
                context$2$0.t0 = context$2$0['catch'](7);

                err = context$2$0.t0;

              case 15:
                if (!err) {
                  context$2$0.next = 18;
                  break;
                }

                _logger2['default'].error('Error recording screen: ' + err.message);
                return context$2$0.abrupt('return', reject(err));

              case 18:
                this._recentScreenRecordingPath = pathOnDevice;
                resolve(result);

              case 20:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[7, 12]]);
        }));

      case 44:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 45:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[13, 23], [27, 32]]);
};

/**
 * @typedef {Object} StopRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 * @property {?string} user - The name of the user for the remote authentication.
 * @property {?string} pass - The password for the remote authentication.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 */

/**
 * Stop recording the screen. If no screen recording process is running then
 * the endpoint will try to get the recently recorded file.
 * If no previously recorded file is found and no active screen recording
 * processes are running then the method returns an empty string.
 *
 * @param {?StopRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'
 *                   parameter is empty or null or an empty string.
 * @throws {Error} If there was an error while getting the name of a media file
 *                 or the file content cannot be uploaded to the remote location
 *                 or screen recording is not supported on the device under test.
 */
commands.stopRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var remotePath, user, pass, method, pids, pathOnDevice, result;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        remotePath = options.remotePath;
        user = options.user;
        pass = options.pass;
        method = options.method;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.adb.getPIDsByName(SCREENRECORD_BINARY));

      case 8:
        context$1$0.t0 = function (p) {
          return '' + p;
        };

        pids = context$1$0.sent.map(context$1$0.t0);
        pathOnDevice = this._recentScreenRecordingPath;

        if (!_lodash2['default'].isEmpty(pids)) {
          context$1$0.next = 15;
          break;
        }

        _logger2['default'].info('Screen recording is not running. There is nothing to stop.');
        context$1$0.next = 29;
        break;

      case 15:
        context$1$0.t1 = pathOnDevice;

        if (context$1$0.t1) {
          context$1$0.next = 20;
          break;
        }

        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(extractCurrentRecordingPath(this.adb, pids));

      case 19:
        context$1$0.t1 = context$1$0.sent;

      case 20:
        pathOnDevice = context$1$0.t1;
        context$1$0.prev = 21;

        if (_lodash2['default'].isEmpty(pathOnDevice)) {
          _logger2['default'].errorAndThrow('Cannot parse the path to the file created by ' + 'screen recorder process from \'ps\' output. ' + 'Did you start screen recording before?');
        }

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(finishScreenCapture(this.adb, pids));

      case 26:
        if (context$1$0.sent) {
          context$1$0.next = 28;
          break;
        }

        _logger2['default'].warn('Unable to stop screen recording. Continuing anyway');

      case 28:
        return context$1$0.finish(23);

      case 29:
        result = '';

        if (_lodash2['default'].isEmpty(pathOnDevice)) {
          context$1$0.next = 38;
          break;
        }

        context$1$0.prev = 31;
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(uploadRecordedMedia(this.adb, pathOnDevice, remotePath, { user: user, pass: pass, method: method }));

      case 34:
        result = context$1$0.sent;

      case 35:
        context$1$0.prev = 35;

        this._recentScreenRecordingPath = null;
        return context$1$0.finish(35);

      case 38:
        return context$1$0.abrupt('return', result);

      case 39:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[21,, 23, 29], [31,, 35, 38]]);
};

_Object$assign(extensions, commands);
exports.commands = commands;
exports['default'] = extensions;

// Wait until the process is terminated

//make adb command
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9yZWNvcmRzY3JlZW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O21CQUNOLElBQUk7Ozs7bUJBQ0osS0FBSzs7Ozt3QkFDMkIsVUFBVTs7d0JBQzVDLFVBQVU7Ozs7NkJBQ00sZ0JBQWdCOztzQkFDOUIsV0FBVzs7OztvQkFDVixNQUFNOzs7O0FBR3ZCLElBQUksUUFBUSxHQUFHLEVBQUU7SUFBRSxVQUFVLEdBQUcsRUFBRSxDQUFDOztBQUVuQyxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sMEJBQTBCLEdBQUcsc0JBQXNCLENBQUM7QUFDMUQsSUFBTSw0QkFBNEIsR0FBRyxDQUFDLENBQUM7QUFDdkMsSUFBTSxtQkFBbUIsR0FBRyxjQUFjLENBQUM7QUFDM0MsSUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDO0FBQzNCLElBQU0sc0JBQXNCLEdBQUcsRUFBRSxDQUFDOztBQUdsQyxTQUFlLDJCQUEyQixDQUFFLEdBQUcsRUFBRSxJQUFJO01BQy9DLFVBQVUsUUFFTCxNQUFNLEVBUVQsT0FBTyxFQUNQLE9BQU87Ozs7O0FBWFQsa0JBQVUsR0FBRyxFQUFFOzs7eUNBRU0sR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDOzs7O0FBQXpELGNBQU0sUUFBTixNQUFNOztBQUNiLGtCQUFVLEdBQUcsTUFBTSxDQUFDOzs7Ozs7OztBQUVwQiw0QkFBSSxJQUFJLENBQUMsa0ZBQ21CLGVBQUksT0FBTyxDQUFFLENBQUMsQ0FBQzs0Q0FDcEMsSUFBSTs7O0FBRWIsNEJBQUksS0FBSywwQ0FBd0MsVUFBVSxDQUFHLENBQUM7QUFDekQsZUFBTyxHQUFHLElBQUksTUFBTSxDQUFDLG1CQUFtQixD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QUFNLEVBQUMsQ0FBQzs7O0FBQTVGLGNBQU07Ozs7O0FBRU4sWUFBSSxDQUFDLDBCQUEwQixHQUFHLElBQUksQ0FBQzs7Ozs0Q0FHcEMsTUFBTTs7Ozs7OztDQUNkLENBQUM7O0FBR0YsZUFBYyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDM0IsUUFBUSxHQUFSLFFBQVE7cUJBQ0YsVUFBVSIsImZpbGUiOiJsaWIvY29tbWFuZHMvcmVjb3Jkc2NyZWVuLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBfZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHsgcmV0cnlJbnRlcnZhbCwgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHV0aWwsIGZzLCBuZXQgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgdGVtcCBmcm9tICd0ZW1wJztcblxuXG5sZXQgY29tbWFuZHMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBSRVRSWV9QQVVTRSA9IDEwMDA7XG5jb25zdCBNQVhfUkVDT1JESU5HX1RJTUVfU0VDID0gNjAgKiAzO1xuY29uc3QgREVGQVVMVF9SRUNPUkRJTkdfVElNRV9TRUMgPSBNQVhfUkVDT1JESU5HX1RJTUVfU0VDO1xuY29uc3QgUFJPQ0VTU19TSFVURE9XTl9USU1FT1VUX1NFQyA9IDU7XG5jb25zdCBTQ1JFRU5SRUNPUkRfQklOQVJZID0gJ3NjcmVlbnJlY29yZCc7XG5jb25zdCBERUZBVUxUX0VYVCA9ICcubXA0JztcbmNvbnN0IE1JTl9FTVVMQVRPUl9BUElfTEVWRUwgPSAyNztcblxuXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0Q3VycmVudFJlY29yZGluZ1BhdGggKGFkYiwgcGlkcykge1xuICBsZXQgbHNvZk91dHB1dCA9ICcnO1xuICB0cnkge1xuICAgIGNvbnN0IHtvdXRwdXR9ID0gYXdhaXQgYWRiLnNoZWxsKFsnbHNvZicsICctcCcsIHBpZHMuam9pbignLCcpXSk7XG4gICAgbHNvZk91dHB1dCA9IG91dHB1dDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCBleHRyYWN0IHRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IHNjcmVlbiBjYXB0dXJlLiBgICtcbiAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbG9nLmRlYnVnKGBHb3QgdGhlIGZvbGxvd2luZyBvdXRwdXQgZnJvbSBsc29mOiAke2xzb2ZPdXRwdXR9YCk7XG4gIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKC9cXGQrXFxzKyhcXC8uKlxcLm1wNCkvKTtcbiAgY29uc3QgbWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhsc29mT3V0cHV0KTtcbiAgcmV0dXJuIF8uaXNFbXB0eShtYXRjaGVzKSA/IG51bGwgOiBfLmxhc3QobWF0Y2hlcyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmlzaFNjcmVlbkNhcHR1cmUgKGFkYiwgcGlkcykge1xuICB0cnkge1xuICAgIGF3YWl0IGFkYi5zaGVsbChbJ2tpbGwnLCAnLTInLCAuLi5waWRzXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFdhaXQgdW50aWwgdGhlIHByb2Nlc3MgaXMgdGVybWluYXRlZFxuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgYWRiLnNoZWxsKFsncHMnXSk7XG4gICAgICAgIGZvciAoY29uc3QgcGlkIG9mIHBpZHMpIHtcbiAgICAgICAgICBpZiAobmV3IFJlZ0V4cChgXFxcXGIke3BpZH1cXFxcYlteXFxcXG5dK1xcXFxiJHtTQ1JFRU5SRUNPUkRfQklOQVJZfSRgLCAnbScpLnRlc3Qob3V0cHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihlcnIubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB7d2FpdE1zOiBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVRfU0VDICogMTAwMCwgaW50ZXJ2YWxNczogNTAwfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZFJlY29yZGVkTWVkaWEgKGFkYiwgcGF0aE9uRGV2aWNlLCByZW1vdGVQYXRoID0gbnVsbCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGxvY2FsRmlsZSA9IHRlbXAucGF0aCh7cHJlZml4OiAnYXBwaXVtJywgc3VmZml4OiBERUZBVUxUX0VYVH0pO1xuICB0cnkge1xuICAgIGF3YWl0IGFkYi5wdWxsKHBhdGhPbkRldmljZSwgbG9jYWxGaWxlKTtcblxuICAgIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQobG9jYWxGaWxlKTtcbiAgICBsb2cuZGVidWcoYFRoZSBzaXplIG9mIHRoZSByZWNlbnQgc2NyZWVuIHJlY29yZGluZyBpcyAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcoc2l6ZSl9YCk7XG4gICAgaWYgKF8uaXNFbXB0eShyZW1vdGVQYXRoKSkge1xuICAgICAgY29uc3QgbWVtb3J5VXNhZ2UgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICBjb25zdCBtYXhNZW1vcnlMaW1pdCA9IChtZW1vcnlVc2FnZS5oZWFwVG90YWwgLSBtZW1vcnlVc2FnZS5oZWFwVXNlZCkgLyAyO1xuICAgICAgaWYgKHNpemUgPj0gbWF4TWVtb3J5TGltaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVhZCB0aGUgcmVjb3JkZWQgbWVkaWEgJyR7cGF0aE9uRGV2aWNlfScgdG8gdGhlIG1lbW9yeSwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgYmVjYXVzZSB0aGUgZmlsZSBpcyB0b28gbGFyZ2UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKCR7dXRpbC50b1JlYWRhYmxlU2l6ZVN0cmluZyhzaXplKX0gPj0gJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKG1heE1lbW9yeUxpbWl0KX0pLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBUcnkgdG8gcHJvdmlkZSBhIGxpbmsgdG8gYSByZW1vdGUgd3JpdGFibGUgbG9jYXRpb24gaW5zdGVhZC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShsb2NhbEZpbGUpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbW90ZVVybCA9IHVybC5wYXJzZShyZW1vdGVQYXRoKTtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IHt1c2VyLCBwYXNzLCBtZXRob2R9ID0gdXBsb2FkT3B0aW9ucztcbiAgICBpZiAocmVtb3RlVXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgdXJsOiByZW1vdGVVcmwuaHJlZixcbiAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BVVCcsXG4gICAgICAgIG11bHRpcGFydDogW3sgYm9keTogX2ZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxGaWxlKSB9XSxcbiAgICAgIH07XG4gICAgICBpZiAodXNlciAmJiBwYXNzKSB7XG4gICAgICAgIG9wdGlvbnMuYXV0aCA9IHt1c2VyLCBwYXNzfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbW90ZVVybC5wcm90b2NvbC5zdGFydHNXaXRoKCdmdHAnKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgaG9zdDogcmVtb3RlVXJsLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiByZW1vdGVVcmwucG9ydCB8fCAyMSxcbiAgICAgIH07XG4gICAgICBpZiAodXNlciAmJiBwYXNzKSB7XG4gICAgICAgIG9wdGlvbnMudXNlciA9IHVzZXI7XG4gICAgICAgIG9wdGlvbnMucGFzcyA9IHBhc3M7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IG5ldC51cGxvYWRGaWxlKGxvY2FsRmlsZSwgcmVtb3RlUGF0aCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICcnO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZihsb2NhbEZpbGUpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhZGIucmltcmFmKHBhdGhPbkRldmljZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLndhcm4oYENhbm5vdCBkZWxldGUgdGhlIHJlY29yZGVkIHNjcmVlbiBtZWRpYSAnJHtwYXRoT25EZXZpY2V9JyBmcm9tIHRoZSBkZXZpY2UuIENvbnRpbnVpbmcgYW55d2F5YCk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkIChhZGIsIGlzRW11bGF0b3IpIHtcbiAgY29uc3QgYXBpTGV2ZWwgPSBhd2FpdCBhZGIuZ2V0QXBpTGV2ZWwoKTtcbiAgaWYgKGlzRW11bGF0b3IgJiYgYXBpTGV2ZWwgPCBNSU5fRU1VTEFUT1JfQVBJX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTY3JlZW4gcmVjb3JkaW5nIGRvZXMgbm90IHdvcmsgb24gZW11bGF0b3JzIHJ1bm5pbmcgQW5kcm9pZCBBUEkgbGV2ZWwgbGVzcyB0aGFuICR7TUlOX0VNVUxBVE9SX0FQSV9MRVZFTH1gKTtcbiAgfVxuICBpZiAoYXBpTGV2ZWwgPCAxOSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2NyZWVuIHJlY29yZGluZyBub3QgYXZhaWxhYmxlIG9uIEFQSSBMZXZlbCAke2FwaUxldmVsfS4gTWluaW11bSBBUEkgTGV2ZWwgaXMgMTkuYCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXJ0UmVjb3JkaW5nT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIHRoZSByZW1vdGUgbG9jYXRpb24sIHdoZXJlIHRoZSBjYXB0dXJlZCB2aWRlbyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHByb3RvY29scyBhcmUgc3VwcG9ydGVkOiBodHRwL2h0dHBzLCBmdHAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdWxsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZSAodGhlIGRlZmF1bHQgc2V0dGluZykgbWVhbnMgdGhlIGNvbnRlbnQgb2YgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHNob3VsZCBiZSBlbmNvZGVkIGFzIEJhc2U2NCBhbmQgcGFzc2VkIGFzIHRoZSBlbmRwb3VudCByZXNwb25zZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBpZiB0aGUgZ2VuZXJhdGVkIG1lZGlhIGZpbGUgaXMgdG9vIGJpZyB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IGludG8gdGhlIGF2YWlsYWJsZSBwcm9jZXNzIG1lbW9yeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb3B0aW9uIG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGVyZSBpcyBzY3JlZW4gcmVjb3JkaW5nIHByb2Nlc3MgaW4gcHJvZ3JlZXNzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYGZvcmNlUmVzdGFydGAgcGFyYW1ldGVyIGlzIG5vdCBzZXQgdG8gYHRydWVgLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB1c2VyIC0gVGhlIG5hbWUgb2YgdGhlIHVzZXIgZm9yIHRoZSByZW1vdGUgYXV0aGVudGljYXRpb24uIE9ubHkgd29ya3MgaWYgYHJlbW90ZVBhdGhgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwYXNzIC0gVGhlIHBhc3N3b3JkIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbWV0aG9kIC0gVGhlIGh0dHAgbXVsdGlwYXJ0IHVwbG9hZCBtZXRob2QgbmFtZS4gVGhlICdQVVQnIG9uZSBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgd29ya3MgaWYgYHJlbW90ZVBhdGhgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB2aWRlb1NpemUgLSBUaGUgZm9ybWF0IGlzIHdpZHRoeGhlaWdodC5cbiAqICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIGRldmljZSdzIG5hdGl2ZSBkaXNwbGF5IHJlc29sdXRpb24gKGlmIHN1cHBvcnRlZCksXG4gKiAgICAgICAgICAgICAgICAgIDEyODB4NzIwIGlmIG5vdC4gRm9yIGJlc3QgcmVzdWx0cyxcbiAqICAgICAgICAgICAgICAgICAgdXNlIGEgc2l6ZSBzdXBwb3J0ZWQgYnkgeW91ciBkZXZpY2UncyBBZHZhbmNlZCBWaWRlbyBDb2RpbmcgKEFWQykgZW5jb2Rlci5cbiAqICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIFwiMTI4MHg3MjBcIlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gYnVnUmVwb3J0IC0gU2V0IGl0IHRvIGB0cnVlYCBpbiBvcmRlciB0byBkaXNwbGF5IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb24gdGhlIHZpZGVvIG92ZXJsYXksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNoIGFzIGEgdGltZXN0YW1wLCB0aGF0IGlzIGhlbHBmdWwgaW4gdmlkZW9zIGNhcHR1cmVkIHRvIGlsbHVzdHJhdGUgYnVncy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHNpbmNlIEFQSSBsZXZlbCAyNyAoQW5kcm9pZCBQKS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ3xudW1iZXJ9IHRpbWVMaW1pdCAtIFRoZSBtYXhpbXVtIHJlY29yZGluZyB0aW1lLCBpbiBzZWNvbmRzLiBUaGUgZGVmYXVsdCBhbmQgbWF4aW11bSB2YWx1ZSBpcyAxODAgKDMgbWludXRlcykuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd8bnVtYmVyfSBiaXRSYXRlIC0gVGhlIHZpZGVvIGJpdCByYXRlIGZvciB0aGUgdmlkZW8sIGluIG1lZ2FiaXRzIHBlciBzZWNvbmQuXG4gKiAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA0LiBZb3UgY2FuIGluY3JlYXNlIHRoZSBiaXQgcmF0ZSB0byBpbXByb3ZlIHZpZGVvIHF1YWxpdHksXG4gKiAgICAgICAgICAgICAgICBidXQgZG9pbmcgc28gcmVzdWx0cyBpbiBsYXJnZXIgbW92aWUgZmlsZXMuXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBmb3JjZVJlc3RhcnQgLSBXaGV0aGVyIHRvIHRyeSB0byBjYXRjaCBhbmQgdXBsb2FkL3JldHVybiB0aGUgY3VycmVudGx5IHJ1bm5pbmcgc2NyZWVuIHJlY29yZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGBmYWxzZWAsIHRoZSBkZWZhdWx0IHNldHRpbmcpIG9yIGlnbm9yZSB0aGUgcmVzdWx0IG9mIGl0IGFuZCBzdGFydCBhIG5ldyByZWNvcmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZWx5IChgdHJ1ZWApLlxuICovXG5cbi8qKlxuICogUmVjb3JkIHRoZSBkaXNwbGF5IG9mIGEgcmVhbCBkZXZpY2VzIHJ1bm5pbmcgQW5kcm9pZCA0LjQgKEFQSSBsZXZlbCAxOSkgYW5kIGhpZ2hlci5cbiAqIEVtdWxhdG9ycyBhcmUgc3VwcG9ydGVkIHNpbmNlIEFQSSBsZXZlbCAyNyAoQW5kcm9pZCBQKS5cbiAqIEl0IHJlY29yZHMgc2NyZWVuIGFjdGl2aXR5IHRvIGFuIE1QRUctNCBmaWxlLiBBdWRpbyBpcyBub3QgcmVjb3JkZWQgd2l0aCB0aGUgdmlkZW8gZmlsZS5cbiAqIElmIHNjcmVlbiByZWNvcmRpbmcgaGFzIGJlZW4gYWxyZWFkeSBzdGFydGVkIHRoZW4gdGhlIGNvbW1hbmQgd2lsbCBzdG9wIGl0IGZvcmNlZnVsbHkgYW5kIHN0YXJ0IGEgbmV3IG9uZS5cbiAqIFRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZpZGVvIGZpbGUgd2lsbCBiZSBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSB7P1N0YXJ0UmVjb3JkaW5nT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIGNvbnRlbnQgb2YgdGhlIHJlY29yZGVkIG1lZGlhIGZpbGUgaWZcbiAqICAgICAgICAgICAgICAgICAgIGFueSBzY3JlZW4gcmVjb3JkaW5nIGlzIGN1cnJlbnRseSBydW5uaW5nIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzY3JlZW4gcmVjb3JkaW5nIGhhcyBmYWlsZWQgdG8gc3RhcnQgb3IgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKi9cbmNvbW1hbmRzLnN0YXJ0UmVjb3JkaW5nU2NyZWVuID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7dmlkZW9TaXplLCB0aW1lTGltaXQ9REVGQVVMVF9SRUNPUkRJTkdfVElNRV9TRUMsIGJ1Z1JlcG9ydCwgYml0UmF0ZSwgZm9yY2VSZXN0YXJ0fSA9IG9wdGlvbnM7XG5cbiAgYXdhaXQgdmVyaWZ5U2NyZWVuUmVjb3JkSXNTdXBwb3J0ZWQodGhpcy5hZGIsIHRoaXMuaXNFbXVsYXRvcigpKTtcblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmICghZm9yY2VSZXN0YXJ0KSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zdG9wUmVjb3JkaW5nU2NyZWVuKG9wdGlvbnMpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGlkcyA9IChhd2FpdCB0aGlzLmFkYi5nZXRQSURzQnlOYW1lKFNDUkVFTlJFQ09SRF9CSU5BUlkpKS5tYXAoKHApID0+IGAke3B9YCk7XG4gICAgaWYgKCFfLmlzRW1wdHkocGlkcykpIHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiLnNoZWxsKFsna2lsbCcsIC4uLnBpZHNdKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBVbmFibGUgdG8gc3RvcCBzY3JlZW4gcmVjb3JkaW5nOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG4gIGlmICghXy5pc0VtcHR5KHRoaXMuX3JlY2VudFNjcmVlblJlY29yZGluZ1BhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiLnJpbXJhZih0aGlzLl9yZWNlbnRTY3JlZW5SZWNvcmRpbmdQYXRoKTtcbiAgICB9IGNhdGNoIChpZ24pIHt9XG4gICAgdGhpcy5fcmVjZW50U2NyZWVuUmVjb3JkaW5nUGF0aCA9IG51bGw7XG4gIH1cblxuICBjb25zdCBwYXRoT25EZXZpY2UgPSBgL3NkY2FyZC8ke01hdGguZmxvb3IobmV3IERhdGUoKSl9JHtERUZBVUxUX0VYVH1gO1xuXG4gIC8vbWFrZSBhZGIgY29tbWFuZFxuICBjb25zdCBjbWQgPSBbU0NSRUVOUkVDT1JEX0JJTkFSWV07XG4gIGlmICh1dGlsLmhhc1ZhbHVlKHZpZGVvU2l6ZSkpIHtcbiAgICBjbWQucHVzaCgnLS1zaXplJywgdmlkZW9TaXplKTtcbiAgfVxuICBpZiAodXRpbC5oYXNWYWx1ZSh0aW1lTGltaXQpKSB7XG4gICAgY21kLnB1c2goJy0tdGltZS1saW1pdCcsIGAke3RpbWVMaW1pdH1gKTtcbiAgfVxuICBpZiAodXRpbC5oYXNWYWx1ZShiaXRSYXRlKSkge1xuICAgIGNtZC5wdXNoKCctLWJpdC1yYXRlJywgYCR7Yml0UmF0ZX1gKTtcbiAgfVxuICBpZiAoYnVnUmVwb3J0KSB7XG4gICAgY21kLnB1c2goJy0tYnVncmVwb3J0Jyk7XG4gIH1cbiAgY21kLnB1c2gocGF0aE9uRGV2aWNlKTtcblxuICAvLyB3cmFwIGluIGEgbWFudWFsIFByb21pc2Ugc28gd2UgY2FuIGhhbmRsZSBlcnJvcnMgaW4gYWRiIHNoZWxsIG9wZXJhdGlvblxuICByZXR1cm4gYXdhaXQgbmV3IEIoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCB0aW1lb3V0ID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KHRpbWVMaW1pdCkgKiAxMDAwKTtcbiAgICBpZiAodGltZW91dCA+IE1BWF9SRUNPUkRJTkdfVElNRV9TRUMgKiAxMDAwIHx8IHRpbWVvdXQgPD0gMCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFRoZSB0aW1lTGltaXQgdmFsdWUgbXVzdCBiZSBpbiByYW5nZSAoMCwgJHtNQVhfUkVDT1JESU5HX1RJTUVfU0VDfV0gc2Vjb25kcy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgVGhlIHZhbHVlIG9mICR7dGltZUxpbWl0fSBoYXMgYmVlbiBwYXNzZWQgaW5zdGVhZC5gKSk7XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgQmVnaW5uaW5nIHNjcmVlbiByZWNvcmRpbmcgd2l0aCBjb21tYW5kOiAnYWRiIHNoZWxsICR7Y21kLmpvaW4oJyAnKX0nYCArXG4gICAgICAgICAgICAgIGBXaWxsIHRpbWVvdXQgaW4gJHt0aW1lb3V0IC8gMTAwMH0gc2ApO1xuICAgIC8vIHNjcmVlbnJlY29yZCBoYXMgaXRzIG93ZW4gdGltZXIsIHNvIHdlIG9ubHkgdXNlIHRoaXMgb25lIGFzIGEgc2FmZXR5IHByZWNhdXRpb25cbiAgICB0aW1lb3V0ICs9IFBST0NFU1NfU0hVVERPV05fVElNRU9VVF9TRUMgKiAxMDAwICogMjtcbiAgICAvLyBkbyBub3QgYXdhaXQgaGVyZSwgYXMgdGhlIGNhbGwgcnVucyBpbiB0aGUgYmFja2dyb3VuZCBhbmQgd2UgY2hlY2sgZm9yIGl0cyBwcm9kdWN0XG4gICAgdGhpcy5hZGIuc2hlbGwoY21kLCB7dGltZW91dCwga2lsbFNpZ25hbDogJ1NJR0lOVCd9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgZXJyID0gZTtcbiAgICB9KTtcblxuICAgIC8vIHRoZXJlIGlzIHRoZSBkZWxheSB0aW1lIHRvIHN0YXJ0IHJlY29yZGluZyB0aGUgc2NyZWVuLCBzbywgd2FpdCB1bnRpbCBpdCBpcyByZWFkeS5cbiAgICAvLyB0aGUgcmVhZHkgY29uZGl0aW9uIGlzXG4gICAgLy8gICAxLiBjaGVjayB0aGUgbW92aWUgZmlsZSBpcyBjcmVhdGVkXG4gICAgLy8gICAyLiBjaGVjayBpdCBpcyBzdGFydGVkIHRvIGNhcHR1cmUgdGhlIHNjcmVlblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZXRyeUludGVydmFsKDEwLCBSRVRSWV9QQVVTRSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGF3YWl0IHRoaXMuYWRiLmZpbGVTaXplKHBhdGhPbkRldmljZSk7XG4gICAgICAgIGlmIChzaXplIDw9IDMyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZW1vdGUgZmlsZSAnJHtwYXRoT25EZXZpY2V9JyBmb3VuZCBidXQgaXQgaXMgc3RpbGwgdG9vIHNtYWxsOiAke3NpemV9IGJ5dGVzYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgbG9nLmVycm9yKGBFcnJvciByZWNvcmRpbmcgc2NyZWVuOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9yZWNlbnRTY3JlZW5SZWNvcmRpbmdQYXRoID0gcGF0aE9uRGV2aWNlO1xuICAgIHJlc29sdmUocmVzdWx0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0b3BSZWNvcmRpbmdPcHRpb25zXG4gKlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gdGhlIHJlbW90ZSBsb2NhdGlvbiwgd2hlcmUgdGhlIHJlc3VsdGluZyB2aWRlbyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHByb3RvY29scyBhcmUgc3VwcG9ydGVkOiBodHRwL2h0dHBzLCBmdHAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdWxsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZSAodGhlIGRlZmF1bHQgc2V0dGluZykgbWVhbnMgdGhlIGNvbnRlbnQgb2YgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHNob3VsZCBiZSBlbmNvZGVkIGFzIEJhc2U2NCBhbmQgcGFzc2VkIGFzIHRoZSBlbmRwb3VudCByZXNwb25zZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBpZiB0aGUgZ2VuZXJhdGVkIG1lZGlhIGZpbGUgaXMgdG9vIGJpZyB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IGludG8gdGhlIGF2YWlsYWJsZSBwcm9jZXNzIG1lbW9yeS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwYXNzIC0gVGhlIHBhc3N3b3JkIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBtZXRob2QgLSBUaGUgaHR0cCBtdWx0aXBhcnQgdXBsb2FkIG1ldGhvZCBuYW1lLiBUaGUgJ1BVVCcgb25lIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vKipcbiAqIFN0b3AgcmVjb3JkaW5nIHRoZSBzY3JlZW4uIElmIG5vIHNjcmVlbiByZWNvcmRpbmcgcHJvY2VzcyBpcyBydW5uaW5nIHRoZW5cbiAqIHRoZSBlbmRwb2ludCB3aWxsIHRyeSB0byBnZXQgdGhlIHJlY2VudGx5IHJlY29yZGVkIGZpbGUuXG4gKiBJZiBubyBwcmV2aW91c2x5IHJlY29yZGVkIGZpbGUgaXMgZm91bmQgYW5kIG5vIGFjdGl2ZSBzY3JlZW4gcmVjb3JkaW5nXG4gKiBwcm9jZXNzZXMgYXJlIHJ1bm5pbmcgdGhlbiB0aGUgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7P1N0b3BSZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgcmVjb3JkZWQgbWVkaWEgZmlsZSBpZiAncmVtb3RlUGF0aCdcbiAqICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBpcyBlbXB0eSBvciBudWxsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgbmFtZSBvZiBhIG1lZGlhIGZpbGVcbiAqICAgICAgICAgICAgICAgICBvciB0aGUgZmlsZSBjb250ZW50IGNhbm5vdCBiZSB1cGxvYWRlZCB0byB0aGUgcmVtb3RlIGxvY2F0aW9uXG4gKiAgICAgICAgICAgICAgICAgb3Igc2NyZWVuIHJlY29yZGluZyBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xuY29tbWFuZHMuc3RvcFJlY29yZGluZ1NjcmVlbiA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge3JlbW90ZVBhdGgsIHVzZXIsIHBhc3MsIG1ldGhvZH0gPSBvcHRpb25zO1xuXG4gIGF3YWl0IHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkKHRoaXMuYWRiLCB0aGlzLmlzRW11bGF0b3IoKSk7XG5cbiAgY29uc3QgcGlkcyA9IChhd2FpdCB0aGlzLmFkYi5nZXRQSURzQnlOYW1lKFNDUkVFTlJFQ09SRF9CSU5BUlkpKS5tYXAoKHApID0+IGAke3B9YCk7XG4gIGxldCBwYXRoT25EZXZpY2UgPSB0aGlzLl9yZWNlbnRTY3JlZW5SZWNvcmRpbmdQYXRoO1xuICBpZiAoXy5pc0VtcHR5KHBpZHMpKSB7XG4gICAgbG9nLmluZm8oYFNjcmVlbiByZWNvcmRpbmcgaXMgbm90IHJ1bm5pbmcuIFRoZXJlIGlzIG5vdGhpbmcgdG8gc3RvcC5gKTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoT25EZXZpY2UgPSBwYXRoT25EZXZpY2UgfHwgYXdhaXQgZXh0cmFjdEN1cnJlbnRSZWNvcmRpbmdQYXRoKHRoaXMuYWRiLCBwaWRzKTtcbiAgICB0cnkge1xuICAgICAgaWYgKF8uaXNFbXB0eShwYXRoT25EZXZpY2UpKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBDYW5ub3QgcGFyc2UgdGhlIHBhdGggdG8gdGhlIGZpbGUgY3JlYXRlZCBieSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYHNjcmVlbiByZWNvcmRlciBwcm9jZXNzIGZyb20gJ3BzJyBvdXRwdXQuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSBzdGFydCBzY3JlZW4gcmVjb3JkaW5nIGJlZm9yZT9gKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFhd2FpdCBmaW5pc2hTY3JlZW5DYXB0dXJlKHRoaXMuYWRiLCBwaWRzKSkge1xuICAgICAgICBsb2cud2FybihgVW5hYmxlIHRvIHN0b3Agc2NyZWVuIHJlY29yZGluZy4gQ29udGludWluZyBhbnl3YXlgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmICghXy5pc0VtcHR5KHBhdGhPbkRldmljZSkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUmVjb3JkZWRNZWRpYSh0aGlzLmFkYiwgcGF0aE9uRGV2aWNlLCByZW1vdGVQYXRoLCB7dXNlciwgcGFzcywgbWV0aG9kfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3JlY2VudFNjcmVlblJlY29yZGluZ1BhdGggPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5PYmplY3QuYXNzaWduKGV4dGVuc2lvbnMsIGNvbW1hbmRzKTtcbmV4cG9ydCB7IGNvbW1hbmRzIH07XG5leHBvcnQgZGVmYXVsdCBleHRlbnNpb25zO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
