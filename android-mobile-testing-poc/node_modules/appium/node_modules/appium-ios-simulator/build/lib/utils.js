'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _appiumXcode = require('appium-xcode');

var _nodeSimctl = require('node-simctl');

var _appiumSupport = require('appium-support');

var _certificate = require('./certificate');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _simulatorXcode6 = require('./simulator-xcode-6');

var _simulatorXcode62 = _interopRequireDefault(_simulatorXcode6);

var _fkill = require('fkill');

var _fkill2 = _interopRequireDefault(_fkill);

var DEFAULT_SIM_SHUTDOWN_TIMEOUT = 30000;

// pgrep/pkill exit codes:
// 0       One or more processes were matched.
// 1       No processes were matched.
// 2       Invalid options were specified on the command line.
// 3       An internal error occurred.

function pkill(appName) {
  var forceKill = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var args;
  return _regeneratorRuntime.async(function pkill$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = forceKill ? ['-9'] : [];

        args.push('-x', appName);
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', args));

      case 5:
        return context$1$0.abrupt('return', 0);

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](2);

        if (_lodash2['default'].isUndefined(context$1$0.t0.code)) {
          context$1$0.next = 12;
          break;
        }

        throw new Error('Cannot forcefully terminate ' + appName + '. pkill error code: ' + context$1$0.t0.code);

      case 12:
        _logger2['default'].error('Received unexpected error while trying to kill ' + appName + ': ' + context$1$0.t0.message);
        throw context$1$0.t0;

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 8]]);
}

function killAllSimulators() {
  var timeout = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_SIM_SHUTDOWN_TIMEOUT : arguments[0];

  var xcodeVersion, appName, pids, _ref, stdout, _ref2, uniquePids, remainingDevices, allSimsAreDown, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, device;

  return _regeneratorRuntime.async(function killAllSimulators$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        allSimsAreDown = function allSimsAreDown() {
          var devices;
          return _regeneratorRuntime.async(function allSimsAreDown$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                remainingDevices = [];
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

              case 3:
                devices = context$2$0.sent;

                devices = _lodash2['default'].flatten(_lodash2['default'].values(devices));
                return context$2$0.abrupt('return', _lodash2['default'].every(devices, function (sim) {
                  var state = sim.state.toLowerCase();
                  var done = state === 'shutdown' || state === 'unavailable' || state === 'disconnected';
                  if (!done) {
                    remainingDevices.push(sim.name + ' (' + sim.sdk + ', udid: ' + sim.udid + ') is still in state \'' + state + '\'');
                  }
                  return done;
                }));

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, this);
        };

        _logger2['default'].debug('Killing all iOS Simulators');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _appiumXcode.getVersion)(true));

      case 4:
        xcodeVersion = context$1$0.sent;
        appName = xcodeVersion.major >= 7 ? 'Simulator' : 'iOS Simulator';

        // later versions are slower to close
        timeout = timeout * (xcodeVersion.major >= 8 ? 2 : 1);

        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcrun', ['simctl', 'shutdown', xcodeVersion.major > 8 ? 'all' : 'booted'], { timeout: timeout }));

      case 10:
        context$1$0.next = 14;
        break;

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](7);

      case 14:
        pids = [];
        context$1$0.prev = 15;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('osascript', ['-e', 'tell application "System Events" to unix id of processes whose bundle identifier is "com.apple.iphonesimulator"']));

      case 18:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        if (stdout.trim()) {
          pids.push.apply(pids, _toConsumableArray(stdout.trim().split(/\s+/)));
        }
        context$1$0.next = 25;
        break;

      case 23:
        context$1$0.prev = 23;
        context$1$0.t1 = context$1$0['catch'](15);

      case 25:
        context$1$0.prev = 25;
        context$1$0.next = 28;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('pgrep', ['-x', appName]));

      case 28:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;

        if (stdout.trim()) {
          pids.push.apply(pids, _toConsumableArray(stdout.trim().split('\n')));
        }
        context$1$0.next = 39;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](25);

        if (!(context$1$0.t2.code === 1 && !pids.length)) {
          context$1$0.next = 38;
          break;
        }

        _logger2['default'].debug(appName + ' is not running. Continuing...');
        return context$1$0.abrupt('return');

      case 38:
        if (!pids.length) {
          _logger2['default'].warn('pgrep error ' + context$1$0.t2.code + ' while detecting whether ' + appName + ' is running. Trying to kill anyway.');
        }

      case 39:
        if (!pids.length) {
          context$1$0.next = 49;
          break;
        }

        uniquePids = _lodash2['default'].uniq(pids);

        _logger2['default'].debug('Using fkill to kill processes: ' + uniquePids.join(', '));
        context$1$0.prev = 42;
        context$1$0.next = 45;
        return _regeneratorRuntime.awrap((0, _fkill2['default'])(uniquePids, { force: true }));

      case 45:
        context$1$0.next = 49;
        break;

      case 47:
        context$1$0.prev = 47;
        context$1$0.t3 = context$1$0['catch'](42);

      case 49:

        _logger2['default'].debug('Using pkill to kill application: ' + appName);
        context$1$0.prev = 50;
        context$1$0.next = 53;
        return _regeneratorRuntime.awrap(pkill(appName, true));

      case 53:
        context$1$0.next = 57;
        break;

      case 55:
        context$1$0.prev = 55;
        context$1$0.t4 = context$1$0['catch'](50);

      case 57:
        remainingDevices = [];
        context$1$0.prev = 58;
        context$1$0.next = 61;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(allSimsAreDown, {
          waitMs: timeout,
          intervalMs: 200
        }));

      case 61:
        context$1$0.next = 87;
        break;

      case 63:
        context$1$0.prev = 63;
        context$1$0.t5 = context$1$0['catch'](58);

        if (!(remainingDevices.length > 0)) {
          context$1$0.next = 86;
          break;
        }

        _logger2['default'].warn('The following devices are still not in the correct state after ' + timeout + ' ms:');
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 70;
        for (_iterator = _getIterator(remainingDevices); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          device = _step.value;

          _logger2['default'].warn('    ' + device);
        }
        context$1$0.next = 78;
        break;

      case 74:
        context$1$0.prev = 74;
        context$1$0.t6 = context$1$0['catch'](70);
        _didIteratorError = true;
        _iteratorError = context$1$0.t6;

      case 78:
        context$1$0.prev = 78;
        context$1$0.prev = 79;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 81:
        context$1$0.prev = 81;

        if (!_didIteratorError) {
          context$1$0.next = 84;
          break;
        }

        throw _iteratorError;

      case 84:
        return context$1$0.finish(81);

      case 85:
        return context$1$0.finish(78);

      case 86:
        throw context$1$0.t5;

      case 87:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 12], [15, 23], [25, 33], [42, 47], [50, 55], [58, 63], [70, 74, 78, 86], [79,, 81, 85]]);
}

function endAllSimulatorDaemons() {
  var _arr, _i, servicePattern, launchCtlCommand, stopCmd, removeCmd;

  return _regeneratorRuntime.async(function endAllSimulatorDaemons$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _logger2['default'].debug('Ending all simulator daemons');
        _arr = ['com.apple.iphonesimulator', 'com.apple.CoreSimulator'];
        _i = 0;

      case 3:
        if (!(_i < _arr.length)) {
          context$1$0.next = 28;
          break;
        }

        servicePattern = _arr[_i];

        _logger2['default'].debug('Killing any other ' + servicePattern + ' daemons');
        launchCtlCommand = 'launchctl list | grep ' + servicePattern + ' | cut -f 3 | xargs -n 1 launchctl';
        context$1$0.prev = 7;
        stopCmd = launchCtlCommand + ' stop';
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', stopCmd]));

      case 11:
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](7);

        _logger2['default'].warn('Could not stop ' + servicePattern + ' daemons, carrying on anyway!');

      case 16:
        context$1$0.prev = 16;
        removeCmd = launchCtlCommand + ' remove';
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', removeCmd]));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](16);

        _logger2['default'].warn('Could not remove ' + servicePattern + ' daemons, carrying on anyway!');

      case 25:
        _i++;
        context$1$0.next = 3;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.next = 31;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          var _ref3, stdout;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)('bash', ['-c', 'ps -e  | grep launchd_sim | grep -v bash | grep -v grep | awk {\'print$1\'}']));

              case 2:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;
                return context$2$0.abrupt('return', stdout.trim().length === 0);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: 5000, intervalMs: 500 }));

      case 31:
        context$1$0.next = 36;
        break;

      case 33:
        context$1$0.prev = 33;
        context$1$0.t2 = context$1$0['catch'](28);

        _logger2['default'].warn('Could not end all simulator daemons, carrying on!');

      case 36:
        _logger2['default'].debug('Finishing ending all simulator daemons');

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 13], [16, 22], [28, 33]]);
}

function simExists(udid) {
  var devices;
  return _regeneratorRuntime.async(function simExists$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _nodeSimctl.getDevices)());

      case 2:
        devices = context$1$0.sent;

        devices = _lodash2['default'].toPairs(devices).map(function (pair) {
          return pair[1];
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        return context$1$0.abrupt('return', !!_lodash2['default'].find(devices, function (sim) {
          return sim.udid === udid;
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function safeRimRaf(delPath) {
  var tryNum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  return _regeneratorRuntime.async(function safeRimRaf$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(delPath));

      case 3:
        context$1$0.next = 20;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(tryNum < 20)) {
          context$1$0.next = 20;
          break;
        }

        if (!(context$1$0.t0.message.indexOf('ENOTEMPTY') !== -1)) {
          context$1$0.next = 15;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\' was not empty during delete; retrying');
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(safeRimRaf(delPath, tryNum + 1));

      case 12:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 15:
        if (!(context$1$0.t0.message.indexOf('ENOENT') !== -1)) {
          context$1$0.next = 20;
          break;
        }

        _logger2['default'].debug('Path \'' + delPath + '\'\' did not exist when we tried to delete, ignoring');
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(safeRimRaf(delPath, tryNum + 1));

      case 19:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

/**
 * Install an SSL certificate to a device with given udid
 * @param {string} pemText SSL pem text
 * @param {string} udid Identifier of the Simulator
 */
function installSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function installSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('openssl'));

      case 3:
        context$1$0.next = 9;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('customSSLCert requires openssl to be available on path');
        _logger2['default'].errorAndThrow('Command \'openssl\' not found');

      case 9:
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which('sqlite3'));

      case 12:
        context$1$0.next = 18;
        break;

      case 14:
        context$1$0.prev = 14;
        context$1$0.t1 = context$1$0['catch'](9);

        _logger2['default'].debug('customSSLCert requires sqlite3 to be available on path');
        _logger2['default'].errorAndThrow('Command \'sqlite3\' not found');

      case 18:
        context$1$0.t2 = _path2['default'];
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 21:
        context$1$0.t3 = context$1$0.sent;
        tempFileName = context$1$0.t2.resolve.call(context$1$0.t2, context$1$0.t3, 'temp-ssl-cert.pem');
        pathToKeychain = new _simulatorXcode62['default'](udid).getDir();
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 26:
        context$1$0.prev = 26;
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(pathToKeychain));

      case 29:
        context$1$0.next = 35;
        break;

      case 31:
        context$1$0.prev = 31;
        context$1$0.t4 = context$1$0['catch'](26);

        _logger2['default'].debug('Could not install SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t4);

      case 35:
        certificate = new _certificate.Certificate(tempFileName);

        _logger2['default'].debug('Installing certificate to ' + pathToKeychain);
        context$1$0.next = 39;
        return _regeneratorRuntime.awrap(certificate.add(pathToKeychain));

      case 39:
        context$1$0.next = 41;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 41:
        return context$1$0.abrupt('return', certificate);

      case 42:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5], [9, 14], [26, 31]]);
}

function uninstallSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function uninstallSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        tempFileName = _path2['default'].resolve(__dirname, 'temp-ssl-cert.pem');
        pathToKeychain = _path2['default'].resolve(new _simulatorXcode62['default'](udid).getDir());
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 5:
        certificate = new _certificate.Certificate(tempFileName);
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(certificate.remove(pathToKeychain));

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(tempFileName));

      case 10:
        return context$1$0.abrupt('return', certificate);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](0);

        _logger2['default'].debug('Could not uninstall SSL certificate. No simulator with udid \'' + udid + '\'');
        _logger2['default'].errorAndThrow(context$1$0.t0);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 13]]);
}

/**
 * Check if the Simulator already has this SSL certificate
 * @param {string} pemText PEM text of SSL cert
 * @param {string} udid Identifier of the Simulator
 */
function hasSSLCert(pemText, udid) {
  var tempFileName, pathToKeychain, certificate;
  return _regeneratorRuntime.async(function hasSSLCert$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.t0 = _path2['default'];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 3:
        context$1$0.t1 = context$1$0.sent;
        tempFileName = context$1$0.t0.resolve.call(context$1$0.t0, context$1$0.t1, 'temp-ssl-cert.pem');
        pathToKeychain = new _simulatorXcode62['default'](udid).getDir();
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempFileName, pemText));

      case 8:
        certificate = new _certificate.Certificate(tempFileName);
        return context$1$0.abrupt('return', certificate.has(pathToKeychain));

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Runs a command line sqlite3 query
 */
function execSQLiteQuery(db, query) {
  for (var _len = arguments.length, queryParams = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    queryParams[_key - 2] = arguments[_key];
  }

  var queryTokens, formattedQuery;
  return _regeneratorRuntime.async(function execSQLiteQuery$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        queryTokens = query.split('?');
        formattedQuery = [];

        queryParams.forEach(function (param, i) {
          formattedQuery.push(queryTokens[i]);
          formattedQuery.push(param.replace(/'/g, "''"));
        });
        formattedQuery.push(queryTokens[queryTokens.length - 1]);

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('sqlite3', ['-line', db, formattedQuery.join('')]));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

exports.killAllSimulators = killAllSimulators;
exports.endAllSimulatorDaemons = endAllSimulatorDaemons;
exports.safeRimRaf = safeRimRaf;
exports.simExists = simExists;
exports.installSSLCert = installSSLCert;
exports.uninstallSSLCert = uninstallSSLCert;
exports.hasSSLCert = hasSSLCert;
exports.execSQLiteQuery = execSQLiteQuery;

// wait for all the devices to be shutdown before Continuing
// but only print out the failed ones when they are actually fully failed

// waiting until the simulator service has died.

// see the README for github.com/appium/node-simctl for example output of getDevices()

// Check that openssl is installed on the path

// Check that sqlite3 is installed on the path

// Create a temporary file to store PEM text
// (a temp file is necessary to run `openssl` shell commands, can't be done in memory)

// Do the certificate installation

// Remove the temporary file
//# sourceMappingURL=data:application/json;charset=utf8;base64,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LEVBQUUsQ0FBQyxFQUFLO0FBQ2hDLHdCQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLHdCQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDaEQsQ0FBQyxDQUFDO0FBQ0gsc0JBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7O3lDQUU1Qyx3QkFBSyxTQUFTLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7OztDQUNyRTs7UUFHQyxpQkFBaUIsR0FBakIsaUJBQWlCO1FBQ2pCLHNCQUFzQixHQUF0QixzQkFBc0I7UUFDdEIsVUFBVSxHQUFWLFVBQVU7UUFDVixTQUFTLEdBQVQsU0FBUztRQUNULGNBQWMsR0FBZCxjQUFjO1FBQ2QsZ0JBQWdCLEdBQWhCLGdCQUFnQjtRQUNoQixVQUFVLEdBQVYsVUFBVTtRQUNWLGVBQWUsR0FBZixlQUFlIiwiZmlsZSI6ImxpYi91dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCB7IGdldFZlcnNpb24gfSBmcm9tICdhcHBpdW0teGNvZGUnO1xuaW1wb3J0IHsgZ2V0RGV2aWNlcyB9IGZyb20gJ25vZGUtc2ltY3RsJztcbmltcG9ydCB7IGZzLCB0ZW1wRGlyIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHsgQ2VydGlmaWNhdGUgfSBmcm9tICcuL2NlcnRpZmljYXRlJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFNpbXVsYXRvciBmcm9tICcuL3NpbXVsYXRvci14Y29kZS02JztcbmltcG9ydCBma2lsbCBmcm9tICdma2lsbCc7XG5cblxuY29uc3QgREVGQVVMVF9TSU1fU0hVVERPV05fVElNRU9VVCA9IDMwMDAwO1xuXG4vLyBwZ3JlcC9wa2lsbCBleGl0IGNvZGVzOlxuLy8gMCAgICAgICBPbmUgb3IgbW9yZSBwcm9jZXNzZXMgd2VyZSBtYXRjaGVkLlxuLy8gMSAgICAgICBObyBwcm9jZXNzZXMgd2VyZSBtYXRjaGVkLlxuLy8gMiAgICAgICBJbnZhbGlkIG9wdGlvbnMgd2VyZSBzcGVjaWZpZWQgb24gdGhlIGNvbW1hbmQgbGluZS5cbi8vIDMgICAgICAgQW4gaW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuXG5cbmFzeW5jIGZ1bmN0aW9uIHBraWxsIChhcHBOYW1lLCBmb3JjZUtpbGwgPSBmYWxzZSkge1xuICBsZXQgYXJncyA9IGZvcmNlS2lsbCA/IFsnLTknXSA6IFtdO1xuICBhcmdzLnB1c2goJy14JywgYXBwTmFtZSk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYygncGtpbGwnLCBhcmdzKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVyci5jb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZm9yY2VmdWxseSB0ZXJtaW5hdGUgJHthcHBOYW1lfS4gcGtpbGwgZXJyb3IgY29kZTogJHtlcnIuY29kZX1gKTtcbiAgICB9XG4gICAgbG9nLmVycm9yKGBSZWNlaXZlZCB1bmV4cGVjdGVkIGVycm9yIHdoaWxlIHRyeWluZyB0byBraWxsICR7YXBwTmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGtpbGxBbGxTaW11bGF0b3JzICh0aW1lb3V0ID0gREVGQVVMVF9TSU1fU0hVVERPV05fVElNRU9VVCkge1xuICBsb2cuZGVidWcoJ0tpbGxpbmcgYWxsIGlPUyBTaW11bGF0b3JzJyk7XG4gIGNvbnN0IHhjb2RlVmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb24odHJ1ZSk7XG4gIGNvbnN0IGFwcE5hbWUgPSB4Y29kZVZlcnNpb24ubWFqb3IgPj0gNyA/ICdTaW11bGF0b3InIDogJ2lPUyBTaW11bGF0b3InO1xuXG4gIC8vIGxhdGVyIHZlcnNpb25zIGFyZSBzbG93ZXIgdG8gY2xvc2VcbiAgdGltZW91dCA9IHRpbWVvdXQgKiAoeGNvZGVWZXJzaW9uLm1ham9yID49IDggPyAyIDogMSk7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKCd4Y3J1bicsIFsnc2ltY3RsJywgJ3NodXRkb3duJywgeGNvZGVWZXJzaW9uLm1ham9yID4gOCA/ICdhbGwnIDogJ2Jvb3RlZCddLCB7dGltZW91dH0pO1xuICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgY29uc3QgcGlkcyA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygnb3Nhc2NyaXB0JyxcbiAgICAgIFsnLWUnLCBgdGVsbCBhcHBsaWNhdGlvbiBcIlN5c3RlbSBFdmVudHNcIiB0byB1bml4IGlkIG9mIHByb2Nlc3NlcyB3aG9zZSBidW5kbGUgaWRlbnRpZmllciBpcyBcImNvbS5hcHBsZS5pcGhvbmVzaW11bGF0b3JcImBdKTtcbiAgICBpZiAoc3Rkb3V0LnRyaW0oKSkge1xuICAgICAgcGlkcy5wdXNoKC4uLihzdGRvdXQudHJpbSgpLnNwbGl0KC9cXHMrLykpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGlnbikge31cbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoJ3BncmVwJywgWycteCcsIGFwcE5hbWVdKTtcbiAgICBpZiAoc3Rkb3V0LnRyaW0oKSkge1xuICAgICAgcGlkcy5wdXNoKC4uLihzdGRvdXQudHJpbSgpLnNwbGl0KCdcXG4nKSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09IDEgJiYgIXBpZHMubGVuZ3RoKSB7XG4gICAgICBsb2cuZGVidWcoYCR7YXBwTmFtZX0gaXMgbm90IHJ1bm5pbmcuIENvbnRpbnVpbmcuLi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwaWRzLmxlbmd0aCkge1xuICAgICAgbG9nLndhcm4oYHBncmVwIGVycm9yICR7ZS5jb2RlfSB3aGlsZSBkZXRlY3Rpbmcgd2hldGhlciAke2FwcE5hbWV9IGlzIHJ1bm5pbmcuIFRyeWluZyB0byBraWxsIGFueXdheS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBpZHMubGVuZ3RoKSB7XG4gICAgY29uc3QgdW5pcXVlUGlkcyA9IF8udW5pcShwaWRzKTtcbiAgICBsb2cuZGVidWcoYFVzaW5nIGZraWxsIHRvIGtpbGwgcHJvY2Vzc2VzOiAke3VuaXF1ZVBpZHMuam9pbignLCAnKX1gKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZmtpbGwodW5pcXVlUGlkcywge2ZvcmNlOiB0cnVlfSk7XG4gICAgfSBjYXRjaCAoaWduKSB7fVxuICB9XG5cbiAgbG9nLmRlYnVnKGBVc2luZyBwa2lsbCB0byBraWxsIGFwcGxpY2F0aW9uOiAke2FwcE5hbWV9YCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgcGtpbGwoYXBwTmFtZSwgdHJ1ZSk7XG4gIH0gY2F0Y2ggKGlnbikge31cblxuICAvLyB3YWl0IGZvciBhbGwgdGhlIGRldmljZXMgdG8gYmUgc2h1dGRvd24gYmVmb3JlIENvbnRpbnVpbmdcbiAgLy8gYnV0IG9ubHkgcHJpbnQgb3V0IHRoZSBmYWlsZWQgb25lcyB3aGVuIHRoZXkgYXJlIGFjdHVhbGx5IGZ1bGx5IGZhaWxlZFxuICBsZXQgcmVtYWluaW5nRGV2aWNlcyA9IFtdO1xuICBhc3luYyBmdW5jdGlvbiBhbGxTaW1zQXJlRG93biAoKSB7XG4gICAgcmVtYWluaW5nRGV2aWNlcyA9IFtdO1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgIGRldmljZXMgPSBfLmZsYXR0ZW4oXy52YWx1ZXMoZGV2aWNlcykpO1xuICAgIHJldHVybiBfLmV2ZXJ5KGRldmljZXMsIChzaW0pID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IHNpbS5zdGF0ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbGV0IGRvbmUgPSBzdGF0ZSA9PT0gJ3NodXRkb3duJyB8fFxuICAgICAgICAgICAgICAgICBzdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJyB8fFxuICAgICAgICAgICAgICAgICBzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgcmVtYWluaW5nRGV2aWNlcy5wdXNoKGAke3NpbS5uYW1lfSAoJHtzaW0uc2RrfSwgdWRpZDogJHtzaW0udWRpZH0pIGlzIHN0aWxsIGluIHN0YXRlICcke3N0YXRlfSdgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lO1xuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhbGxTaW1zQXJlRG93biwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0LFxuICAgICAgaW50ZXJ2YWxNczogMjAwXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChyZW1haW5pbmdEZXZpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZy53YXJuKGBUaGUgZm9sbG93aW5nIGRldmljZXMgYXJlIHN0aWxsIG5vdCBpbiB0aGUgY29ycmVjdCBzdGF0ZSBhZnRlciAke3RpbWVvdXR9IG1zOmApO1xuICAgICAgZm9yIChsZXQgZGV2aWNlIG9mIHJlbWFpbmluZ0RldmljZXMpIHtcbiAgICAgICAgbG9nLndhcm4oYCAgICAke2RldmljZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuZEFsbFNpbXVsYXRvckRhZW1vbnMgKCkge1xuICBsb2cuZGVidWcoJ0VuZGluZyBhbGwgc2ltdWxhdG9yIGRhZW1vbnMnKTtcbiAgZm9yIChsZXQgc2VydmljZVBhdHRlcm4gb2YgWydjb20uYXBwbGUuaXBob25lc2ltdWxhdG9yJywgJ2NvbS5hcHBsZS5Db3JlU2ltdWxhdG9yJ10pIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYW55IG90aGVyICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnNgKTtcbiAgICBsZXQgbGF1bmNoQ3RsQ29tbWFuZCA9IGBsYXVuY2hjdGwgbGlzdCB8IGdyZXAgJHtzZXJ2aWNlUGF0dGVybn0gfCBjdXQgLWYgMyB8IHhhcmdzIC1uIDEgbGF1bmNoY3RsYDtcbiAgICB0cnkge1xuICAgICAgbGV0IHN0b3BDbWQgPSBgJHtsYXVuY2hDdGxDb21tYW5kfSBzdG9wYDtcbiAgICAgIGF3YWl0IGV4ZWMoJ2Jhc2gnLCBbJy1jJywgc3RvcENtZF0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCBzdG9wICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnMsIGNhcnJ5aW5nIG9uIGFueXdheSFgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZW1vdmVDbWQgPSBgJHtsYXVuY2hDdGxDb21tYW5kfSByZW1vdmVgO1xuICAgICAgYXdhaXQgZXhlYygnYmFzaCcsIFsnLWMnLCByZW1vdmVDbWRdKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgcmVtb3ZlICR7c2VydmljZVBhdHRlcm59IGRhZW1vbnMsIGNhcnJ5aW5nIG9uIGFueXdheSFgKTtcbiAgICB9XG4gIH1cbiAgLy8gd2FpdGluZyB1bnRpbCB0aGUgc2ltdWxhdG9yIHNlcnZpY2UgaGFzIGRpZWQuXG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCdiYXNoJywgWyctYycsXG4gICAgICAgIGBwcyAtZSAgfCBncmVwIGxhdW5jaGRfc2ltIHwgZ3JlcCAtdiBiYXNoIHwgZ3JlcCAtdiBncmVwIHwgYXdrIHsncHJpbnQkMSd9YF0pO1xuICAgICAgcmV0dXJuIHN0ZG91dC50cmltKCkubGVuZ3RoID09PSAwO1xuICAgIH0sIHt3YWl0TXM6IDUwMDAsIGludGVydmFsTXM6IDUwMH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgQ291bGQgbm90IGVuZCBhbGwgc2ltdWxhdG9yIGRhZW1vbnMsIGNhcnJ5aW5nIG9uIWApO1xuICB9XG4gIGxvZy5kZWJ1ZygnRmluaXNoaW5nIGVuZGluZyBhbGwgc2ltdWxhdG9yIGRhZW1vbnMnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2ltRXhpc3RzICh1ZGlkKSB7XG4gIC8vIHNlZSB0aGUgUkVBRE1FIGZvciBnaXRodWIuY29tL2FwcGl1bS9ub2RlLXNpbWN0bCBmb3IgZXhhbXBsZSBvdXRwdXQgb2YgZ2V0RGV2aWNlcygpXG4gIGxldCBkZXZpY2VzID0gYXdhaXQgZ2V0RGV2aWNlcygpO1xuXG4gIGRldmljZXMgPSBfLnRvUGFpcnMoZGV2aWNlcykubWFwKChwYWlyKSA9PiB7XG4gICAgcmV0dXJuIHBhaXJbMV07XG4gIH0pLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfSwgW10pO1xuICByZXR1cm4gISFfLmZpbmQoZGV2aWNlcywgKHNpbSkgPT4ge1xuICAgIHJldHVybiBzaW0udWRpZCA9PT0gdWRpZDtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHNhZmVSaW1SYWYgKGRlbFBhdGgsIHRyeU51bSA9IDApIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYoZGVsUGF0aCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0cnlOdW0gPCAyMCkge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0VOT1RFTVBUWScpICE9PSAtMSkge1xuICAgICAgICBsb2cuZGVidWcoYFBhdGggJyR7ZGVsUGF0aH0nIHdhcyBub3QgZW1wdHkgZHVyaW5nIGRlbGV0ZTsgcmV0cnlpbmdgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNhZmVSaW1SYWYoZGVsUGF0aCwgdHJ5TnVtICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0VOT0VOVCcpICE9PSAtMSkge1xuICAgICAgICBsb2cuZGVidWcoYFBhdGggJyR7ZGVsUGF0aH0nJyBkaWQgbm90IGV4aXN0IHdoZW4gd2UgdHJpZWQgdG8gZGVsZXRlLCBpZ25vcmluZ2ApO1xuICAgICAgICByZXR1cm4gYXdhaXQgc2FmZVJpbVJhZihkZWxQYXRoLCB0cnlOdW0gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnN0YWxsIGFuIFNTTCBjZXJ0aWZpY2F0ZSB0byBhIGRldmljZSB3aXRoIGdpdmVuIHVkaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwZW1UZXh0IFNTTCBwZW0gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHVkaWQgSWRlbnRpZmllciBvZiB0aGUgU2ltdWxhdG9yXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxTU0xDZXJ0IChwZW1UZXh0LCB1ZGlkKSB7XG4gIC8vIENoZWNrIHRoYXQgb3BlbnNzbCBpcyBpbnN0YWxsZWQgb24gdGhlIHBhdGhcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53aGljaCgnb3BlbnNzbCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBjdXN0b21TU0xDZXJ0IHJlcXVpcmVzIG9wZW5zc2wgdG8gYmUgYXZhaWxhYmxlIG9uIHBhdGhgKTtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgQ29tbWFuZCAnb3BlbnNzbCcgbm90IGZvdW5kYCk7XG4gIH1cblxuICAvLyBDaGVjayB0aGF0IHNxbGl0ZTMgaXMgaW5zdGFsbGVkIG9uIHRoZSBwYXRoXG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud2hpY2goJ3NxbGl0ZTMnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgY3VzdG9tU1NMQ2VydCByZXF1aXJlcyBzcWxpdGUzIHRvIGJlIGF2YWlsYWJsZSBvbiBwYXRoYCk7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYENvbW1hbmQgJ3NxbGl0ZTMnIG5vdCBmb3VuZGApO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGZpbGUgdG8gc3RvcmUgUEVNIHRleHRcbiAgLy8gKGEgdGVtcCBmaWxlIGlzIG5lY2Vzc2FyeSB0byBydW4gYG9wZW5zc2xgIHNoZWxsIGNvbW1hbmRzLCBjYW4ndCBiZSBkb25lIGluIG1lbW9yeSlcbiAgbGV0IHRlbXBGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKSwgJ3RlbXAtc3NsLWNlcnQucGVtJyk7XG4gIGxldCBwYXRoVG9LZXljaGFpbiA9IG5ldyBTaW11bGF0b3IodWRpZCkuZ2V0RGlyKCk7XG4gIGF3YWl0IGZzLndyaXRlRmlsZSh0ZW1wRmlsZU5hbWUsIHBlbVRleHQpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLnN0YXQocGF0aFRvS2V5Y2hhaW4pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmRlYnVnKGBDb3VsZCBub3QgaW5zdGFsbCBTU0wgY2VydGlmaWNhdGUuIE5vIHNpbXVsYXRvciB3aXRoIHVkaWQgJyR7dWRpZH0nYCk7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XG4gIH1cblxuICAvLyBEbyB0aGUgY2VydGlmaWNhdGUgaW5zdGFsbGF0aW9uXG4gIGxldCBjZXJ0aWZpY2F0ZSA9IG5ldyBDZXJ0aWZpY2F0ZSh0ZW1wRmlsZU5hbWUpO1xuICBsb2cuZGVidWcoYEluc3RhbGxpbmcgY2VydGlmaWNhdGUgdG8gJHtwYXRoVG9LZXljaGFpbn1gKTtcbiAgYXdhaXQgY2VydGlmaWNhdGUuYWRkKHBhdGhUb0tleWNoYWluKTtcblxuICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSBmaWxlXG4gIGF3YWl0IGZzLnVubGluayh0ZW1wRmlsZU5hbWUpO1xuXG4gIHJldHVybiBjZXJ0aWZpY2F0ZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdW5pbnN0YWxsU1NMQ2VydCAocGVtVGV4dCwgdWRpZCkge1xuICB0cnkge1xuICAgIGxldCB0ZW1wRmlsZU5hbWUgPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAndGVtcC1zc2wtY2VydC5wZW0nKTtcbiAgICBsZXQgcGF0aFRvS2V5Y2hhaW4gPSBwYXRoLnJlc29sdmUobmV3IFNpbXVsYXRvcih1ZGlkKS5nZXREaXIoKSk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBGaWxlTmFtZSwgcGVtVGV4dCk7XG4gICAgbGV0IGNlcnRpZmljYXRlID0gbmV3IENlcnRpZmljYXRlKHRlbXBGaWxlTmFtZSk7XG4gICAgYXdhaXQgY2VydGlmaWNhdGUucmVtb3ZlKHBhdGhUb0tleWNoYWluKTtcbiAgICBhd2FpdCBmcy51bmxpbmsodGVtcEZpbGVOYW1lKTtcbiAgICByZXR1cm4gY2VydGlmaWNhdGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cuZGVidWcoYENvdWxkIG5vdCB1bmluc3RhbGwgU1NMIGNlcnRpZmljYXRlLiBObyBzaW11bGF0b3Igd2l0aCB1ZGlkICcke3VkaWR9J2ApO1xuICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIFNpbXVsYXRvciBhbHJlYWR5IGhhcyB0aGlzIFNTTCBjZXJ0aWZpY2F0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBlbVRleHQgUEVNIHRleHQgb2YgU1NMIGNlcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1ZGlkIElkZW50aWZpZXIgb2YgdGhlIFNpbXVsYXRvclxuICovXG5hc3luYyBmdW5jdGlvbiBoYXNTU0xDZXJ0IChwZW1UZXh0LCB1ZGlkKSB7XG4gIGNvbnN0IHRlbXBGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKSwgJ3RlbXAtc3NsLWNlcnQucGVtJyk7XG4gIGNvbnN0IHBhdGhUb0tleWNoYWluID0gbmV3IFNpbXVsYXRvcih1ZGlkKS5nZXREaXIoKTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBGaWxlTmFtZSwgcGVtVGV4dCk7XG4gIGNvbnN0IGNlcnRpZmljYXRlID0gbmV3IENlcnRpZmljYXRlKHRlbXBGaWxlTmFtZSk7XG4gIHJldHVybiBjZXJ0aWZpY2F0ZS5oYXMocGF0aFRvS2V5Y2hhaW4pO1xufVxuXG4vKipcbiAqIFJ1bnMgYSBjb21tYW5kIGxpbmUgc3FsaXRlMyBxdWVyeVxuICovXG5hc3luYyBmdW5jdGlvbiBleGVjU1FMaXRlUXVlcnkgKGRiLCBxdWVyeSwgLi4ucXVlcnlQYXJhbXMpIHtcbiAgbGV0IHF1ZXJ5VG9rZW5zID0gcXVlcnkuc3BsaXQoJz8nKTtcbiAgbGV0IGZvcm1hdHRlZFF1ZXJ5ID0gW107XG4gIHF1ZXJ5UGFyYW1zLmZvckVhY2goKHBhcmFtLCBpKSA9PiB7XG4gICAgZm9ybWF0dGVkUXVlcnkucHVzaChxdWVyeVRva2Vuc1tpXSk7XG4gICAgZm9ybWF0dGVkUXVlcnkucHVzaChwYXJhbS5yZXBsYWNlKC8nL2csIFwiJydcIikpO1xuICB9KTtcbiAgZm9ybWF0dGVkUXVlcnkucHVzaChxdWVyeVRva2Vuc1txdWVyeVRva2Vucy5sZW5ndGggLSAxXSk7XG5cbiAgcmV0dXJuIGF3YWl0IGV4ZWMoJ3NxbGl0ZTMnLCBbJy1saW5lJywgZGIsIGZvcm1hdHRlZFF1ZXJ5LmpvaW4oJycpXSk7XG59XG5cbmV4cG9ydCB7XG4gIGtpbGxBbGxTaW11bGF0b3JzLFxuICBlbmRBbGxTaW11bGF0b3JEYWVtb25zLFxuICBzYWZlUmltUmFmLFxuICBzaW1FeGlzdHMsXG4gIGluc3RhbGxTU0xDZXJ0LFxuICB1bmluc3RhbGxTU0xDZXJ0LFxuICBoYXNTU0xDZXJ0LFxuICBleGVjU1FMaXRlUXVlcnlcbn07XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
