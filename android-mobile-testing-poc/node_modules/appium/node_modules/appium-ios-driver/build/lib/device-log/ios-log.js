'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _teen_process = require('teen_process');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var EventEmitter = _events2['default'].EventEmitter;

var START_TIMEOUT = 10000;
var DEVICE_CONSOLE_PATH = _path2['default'].resolve(__dirname, '..', '..', '..', 'build', 'deviceconsole');
var SYSTEM_LOG_PATH = '/var/log/system.log';
// We keep only the most recent log entries to avoid out of memory error
var MAX_LOG_ENTRIES_COUNT = 10000;

var IOSLog = (function (_EventEmitter) {
  _inherits(IOSLog, _EventEmitter);

  function IOSLog(opts) {
    _classCallCheck(this, IOSLog);

    _get(Object.getPrototypeOf(IOSLog.prototype), 'constructor', this).call(this);
    this.sim = opts.sim;
    this.udid = opts.udid;
    this.showLogs = !!opts.showLogs;
    this.realDeviceLogger = opts.realDeviceLogger || 'idevicesyslog';
    this.xcodeVersion = opts.xcodeVersion;

    this.proc = null;
    this.logs = [];
    this.logRow = '';
    this.logIdxSinceLastRequest = -1;
    this.maxBufferSize = MAX_LOG_ENTRIES_COUNT;
  }

  _createClass(IOSLog, [{
    key: 'startCaptureRealDevice',
    value: function startCaptureRealDevice() {
      var cmd, args, env, deviceconsole, stat;
      return _regeneratorRuntime.async(function startCaptureRealDevice$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined, args = undefined, env = undefined;

            if (!((this.realDeviceLogger || '').indexOf('idevicesyslog') !== -1)) {
              context$2$0.next = 24;
              break;
            }

            _logger2['default'].debug('Attempting iOS device log capture via libimobiledevice idevicesyslog');

            if (!(this.realDeviceLogger.toLowerCase() === 'idevicesyslog')) {
              context$2$0.next = 15;
              break;
            }

            cmd = 'idevicesyslog';
            context$2$0.prev = 5;
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevicesyslog'));

          case 8:
            context$2$0.next = 13;
            break;

          case 10:
            context$2$0.prev = 10;
            context$2$0.t0 = context$2$0['catch'](5);
            throw new Error('Unable to find system idevicesyslog: ' + context$2$0.t0.message);

          case 13:
            context$2$0.next = 20;
            break;

          case 15:
            context$2$0.next = 17;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this.realDeviceLogger));

          case 17:
            if (context$2$0.sent) {
              context$2$0.next = 19;
              break;
            }

            throw new Error('Unable to find idevicesyslog from \'realDeviceLogger\' capability \'' + this.realDeviceLogger + '\'');

          case 19:
            cmd = this.realDeviceLogger;

          case 20:

            args = ['-u', this.udid];
            env = process.env;
            context$2$0.next = 57;
            break;

          case 24:
            if (!((this.realDeviceLogger || '').indexOf('deviceconsole') !== -1)) {
              context$2$0.next = 56;
              break;
            }

            _logger2['default'].debug('Attempting iOS device log capture via deviceconsole');
            deviceconsole = undefined;

            if (!(this.realDeviceLogger.toLowerCase() === 'deviceconsole')) {
              context$2$0.next = 31;
              break;
            }

            deviceconsole = DEVICE_CONSOLE_PATH;
            context$2$0.next = 48;
            break;

          case 31:
            stat = undefined;
            context$2$0.prev = 32;
            context$2$0.next = 35;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(this.realDeviceLogger));

          case 35:
            stat = context$2$0.sent;
            context$2$0.next = 41;
            break;

          case 38:
            context$2$0.prev = 38;
            context$2$0.t1 = context$2$0['catch'](32);
            throw new Error('Unable to find deviceconsole from \'realDeviceLogger\' capability \'' + this.realDeviceLogger + '\': ' + context$2$0.t1.message);

          case 41:
            if (!stat.isDirectory()) {
              context$2$0.next = 45;
              break;
            }

            deviceconsole = this.realDeviceLogger;
            context$2$0.next = 48;
            break;

          case 45:
            if (_lodash2['default'].endsWith(this.realDeviceLogger, 'deviceconsole')) {
              context$2$0.next = 47;
              break;
            }

            throw new Error('Unable to parse \'deviceconsole\' installation directory from \'' + this.realDeviceLogger + '\'');

          case 47:
            // remove the executable, and trailing `/`, to get the install directory
            deviceconsole = _path2['default'].dirname(this.realDeviceLogger);

          case 48:

            _logger2['default'].debug('Using \'deviceconsole\' from \'' + deviceconsole + '\'');

            cmd = deviceconsole + '/deviceconsole';
            args = ['-u', this.udid];

            // set up the environment to be able to run deviceconsole
            env = _lodash2['default'].clone(process.env);
            env.DYLD_LIBRARY_PATH = deviceconsole;
            if (process.env.DYLD_LIBRARY_PATH) {
              env.DYLD_LIBRARY_PATH = env.DYLD_LIBRARY_PATH + ':' + process.env.DYLD_LIBRARY_PATH;
            }
            context$2$0.next = 57;
            break;

          case 56:
            _logger2['default'].errorAndThrow('Unable to capture device log. Unknown \'realDeviceLogger\': \'' + this.realDeviceLogger + '\'');

          case 57:

            this.subprocessId = cmd + '_' + this.udid;

            _logger2['default'].debug('Starting iOS device log capture with: \'' + cmd + '\'');

            context$2$0.prev = 59;
            context$2$0.next = 62;
            return _regeneratorRuntime.awrap(this.killExistingSysLogProcesses(cmd, args));

          case 62:
            context$2$0.next = 66;
            break;

          case 64:
            context$2$0.prev = 64;
            context$2$0.t2 = context$2$0['catch'](59);

          case 66:

            // just use one instance of 'idevicesyslog' per udid
            this.proc = this.getIDeviceSysLogProcess(cmd, args, env);

            context$2$0.next = 69;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 69:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[5, 10], [32, 38], [59, 64]]);
    }
  }, {
    key: 'startCaptureSimulator',
    value: function startCaptureSimulator() {
      var logPath, systemLogPath, files, lastModifiedLogPath, lastModifiedLogTime, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, _ref, mtime, tailArgs;

      return _regeneratorRuntime.async(function startCaptureSimulator$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.t0 = _logger2['default'];
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.sim.getPlatformVersion());

          case 3:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = 'Starting iOS ' + context$2$0.t1;
            context$2$0.t3 = context$2$0.t2 + ' simulator log capture';
            context$2$0.t0.debug.call(context$2$0.t0, context$2$0.t3);

            if (!(this.xcodeVersion.major < 5)) {
              context$2$0.next = 12;
              break;
            }

            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', SYSTEM_LOG_PATH]);
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 11:
            return context$2$0.abrupt('return');

          case 12:

            // this is xcode 6+
            if (_lodash2['default'].isUndefined(this.sim.udid)) {
              _logger2['default'].errorAndThrow('iOS log capture with Xcode ' + this.xcodeVersion.versionString + ' requires a sim udid');
            }

            logPath = this.sim.getLogDir();
            context$2$0.prev = 14;

            if (!(logPath.indexOf('*') >= 0)) {
              context$2$0.next = 18;
              break;
            }

            _logger2['default'].error('Log path has * in it. Unable to start log capture: ' + logPath);
            return context$2$0.abrupt('return');

          case 18:
            systemLogPath = _path2['default'].resolve(logPath, 'system.log');

            _logger2['default'].debug('System log path: ' + systemLogPath);
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(logPath));

          case 22:
            context$2$0.next = 24;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(systemLogPath, 'A new Appium session is about to start!\n', { flag: 'a' }));

          case 24:
            files = undefined;
            context$2$0.prev = 25;
            context$2$0.next = 28;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(systemLogPath));

          case 28:
            files = context$2$0.sent;

            if (!(files.length < 1)) {
              context$2$0.next = 31;
              break;
            }

            throw new Error('Could not start log capture');

          case 31:
            context$2$0.next = 36;
            break;

          case 33:
            context$2$0.prev = 33;
            context$2$0.t4 = context$2$0['catch'](25);

            _logger2['default'].error('Could not start log capture because no iOS ' + ('simulator logs could be found at ' + systemLogPath + '. ') + 'Logging will not be functional for this run');

          case 36:
            lastModifiedLogPath = files[0];
            context$2$0.next = 39;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(lastModifiedLogPath));

          case 39:
            lastModifiedLogTime = context$2$0.sent.mtime;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 43;
            _iterator = _getIterator(files);

          case 45:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 55;
              break;
            }

            file = _step.value;
            context$2$0.next = 49;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(file));

          case 49:
            _ref = context$2$0.sent;
            mtime = _ref.mtime;

            if (mtime > lastModifiedLogTime) {
              lastModifiedLogPath = file;
              lastModifiedLogTime = mtime;
            }

          case 52:
            _iteratorNormalCompletion = true;
            context$2$0.next = 45;
            break;

          case 55:
            context$2$0.next = 61;
            break;

          case 57:
            context$2$0.prev = 57;
            context$2$0.t5 = context$2$0['catch'](43);
            _didIteratorError = true;
            _iteratorError = context$2$0.t5;

          case 61:
            context$2$0.prev = 61;
            context$2$0.prev = 62;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 64:
            context$2$0.prev = 64;

            if (!_didIteratorError) {
              context$2$0.next = 67;
              break;
            }

            throw _iteratorError;

          case 67:
            return context$2$0.finish(64);

          case 68:
            return context$2$0.finish(61);

          case 69:
            tailArgs = ['-f', '-n', '1', lastModifiedLogPath];
            context$2$0.prev = 70;
            context$2$0.next = 73;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', ['-xf', ['tail'].concat(tailArgs).join(' ')]));

          case 73:
            context$2$0.next = 77;
            break;

          case 75:
            context$2$0.prev = 75;
            context$2$0.t6 = context$2$0['catch'](70);

          case 77:
            this.proc = new _teen_process.SubProcess('tail', tailArgs);
            context$2$0.next = 80;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 80:
            context$2$0.next = 85;
            break;

          case 82:
            context$2$0.prev = 82;
            context$2$0.t7 = context$2$0['catch'](14);

            _logger2['default'].errorAndThrow('Simulator log capture failed: ' + context$2$0.t7.message);

          case 85:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[14, 82], [25, 33], [43, 57, 61, 69], [62,, 64, 68], [70, 75]]);
    }
  }, {
    key: 'startCapture',
    value: function startCapture() {
      return _regeneratorRuntime.async(function startCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.udid) {
              context$2$0.next = 4;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.startCaptureRealDevice());

          case 3:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 4:
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.startCaptureSimulator());

          case 6:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 7:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'finishStartingLogCapture',
    value: function finishStartingLogCapture() {
      var firstLine, sd;
      return _regeneratorRuntime.async(function finishStartingLogCapture$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              _logger2['default'].errorAndThrow('Could not capture device log');
            }
            firstLine = true;

            this.proc.on('output', function (stdout, stderr) {
              if (stdout) {
                if (firstLine) {
                  if (stdout.substr(-1, 1) === '\n') {
                    // don't store the first line of the log because it came before the sim or device was launched
                    firstLine = false;
                  }
                } else {
                  _this.logRow += stdout;
                  if (stdout.substr(-1, 1) === '\n') {
                    _this.onOutput();
                    _this.logRow = '';
                  }
                }
              }
              if (stderr) {
                _this.onOutput('STDERR');
              }
            });

            sd = function sd(stdout, stderr) {
              if (/execvp\(\)/.test(stderr)) {
                throw new Error('iOS log capture process failed to start');
              }
              return stdout || stderr;
            };

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.start(sd, START_TIMEOUT));

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stopCapture',
    value: function stopCapture() {
      var cachedSysLog;
      return _regeneratorRuntime.async(function stopCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              context$2$0.next = 12;
              break;
            }

            if (!this.udid) {
              context$2$0.next = 10;
              break;
            }

            cachedSysLog = IOSLog.cachedIDeviceSysLogs[this.subprocessId];

            cachedSysLog.count--;

            if (!(cachedSysLog.count === 0)) {
              context$2$0.next = 8;
              break;
            }

            context$2$0.next = 7;
            return _regeneratorRuntime.awrap(this.killLogSubProcess());

          case 7:
            delete IOSLog.cachedIDeviceSysLogs[this.subprocessId];

          case 8:
            context$2$0.next = 12;
            break;

          case 10:
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.killLogSubProcess());

          case 12:
            this.proc = null;

          case 13:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killLogSubProcess',
    value: function killLogSubProcess() {
      return _regeneratorRuntime.async(function killLogSubProcess$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc.isRunning) {
              context$2$0.next = 12;
              break;
            }

            _logger2['default'].debug('Stopping iOS log capture');
            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGTERM', 1000));

          case 5:
            context$2$0.next = 12;
            break;

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].error('Cannot stop log capture process. Sending SIGKILL...');
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGKILL'));

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: 'onOutput',
    value: function onOutput() {
      var prefix = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      var logs = this.logRow.split('\n');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(logs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var log = _step2.value;

          if (!log) continue; // eslint-disable-line curly
          var logObj = {
            timestamp: Date.now(),
            level: 'ALL',
            message: log
          };
          this.logs.push(logObj);
          this.emit('output', logObj);
          if (this.logs.length > this.maxBufferSize) {
            this.logs.shift();
            if (this.logIdxSinceLastRequest > 0) {
              --this.logIdxSinceLastRequest;
            }
          }
          if (this.showLogs) {
            var space = prefix.length > 0 ? ' ' : '';
            _logger2['default'].info('[IOS_SYSLOG_ROW' + space + prefix + '] ' + log);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'getLogs',
    value: function getLogs() {
      var result;
      return _regeneratorRuntime.async(function getLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!(this.logs.length && this.logIdxSinceLastRequest < this.logs.length)) {
              context$2$0.next = 5;
              break;
            }

            result = this.logs;

            if (this.logIdxSinceLastRequest > 0) {
              result = result.slice(this.logIdxSinceLastRequest);
            }
            this.logIdxSinceLastRequest = this.logs.length;
            return context$2$0.abrupt('return', result);

          case 5:
            return context$2$0.abrupt('return', []);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getAllLogs',
    value: function getAllLogs() {
      return _regeneratorRuntime.async(function getAllLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', this.logs);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killExistingSysLogProcesses',
    value: function killExistingSysLogProcesses(cmd, args) {
      return _regeneratorRuntime.async(function killExistingSysLogProcesses$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (IOSLog.cachedIDeviceSysLogs[this.subprocessId]) {
              context$2$0.next = 3;
              break;
            }

            context$2$0.next = 3;
            return _regeneratorRuntime.awrap((0, _teen_process.exec)('pkill', ['-xf', [cmd].concat(_toConsumableArray(args)).join(' ')]));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Get 'idevicesyslog' subprocess for a given udid.
     *
     * This function caches and re-uses instances so that there's
     * just one instance per device (cache by UDID)
     */
  }, {
    key: 'getIDeviceSysLogProcess',
    value: function getIDeviceSysLogProcess(cmd, args, env) {
      var _this2 = this;

      if (!IOSLog.cachedIDeviceSysLogs[this.subprocessId]) {
        var _IOSLog$cachedIDeviceSysLogs$subprocessId = IOSLog.cachedIDeviceSysLogs[this.subprocessId] = {
          proc: new _teen_process.SubProcess(cmd, args, { env: env }),
          count: 1
        };

        var proc = _IOSLog$cachedIDeviceSysLogs$subprocessId.proc;

        // If the process dies, remove it from the cache
        proc.on('exit', function () {
          return delete IOSLog.cachedIDeviceSysLogs[_this2.subprocessId];
        });
      } else {
        IOSLog.cachedIDeviceSysLogs[this.subprocessId].count++;
      }
      return IOSLog.cachedIDeviceSysLogs[this.subprocessId].proc;
    }
  }]);

  return IOSLog;
})(EventEmitter);

IOSLog.cachedIDeviceSysLogs = {};

exports.IOSLog = IOSLog;
exports.DEVICE_CONSOLE_PATH = DEVICE_CONSOLE_PATH;
exports['default'] = IOSLog;

// make sure it is available on the PATH

// make sure the executable exists

// make sure that we have the path to the directory,
// not the actual executable

// make sure they've passed in `deviceconsole` and not something random

// cleanup existing listeners if the previous session has not been terminated properly

// otherwise, if we have a simulator...

// cleanup existing listeners if the previous session has not been terminated properly

// if we have a real device

// If no other UDID's are using 'idevicesyslog' kill it
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBaUIsTUFBTTs7OztzQkFDVCxRQUFROzs7O3NCQUNILFVBQVU7Ozs7NkJBQ0YsZ0JBQWdCOzs0QkFDVixjQUFjOztzQkFDNUIsUUFBUTs7OztJQUNuQixZQUFZLHVCQUFaLFlBQVk7O0FBRXBCLElBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQztBQUM1QixJQUFNLG1CQUFtQixHQUFHLGtCQUFLLE9BQU8sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQ2hHLElBQU0sZUFBZSxHQUFHLHFCQUFxQixDQUFDOztBQUU5QyxJQUFNLHFCQUFxQixHQUFHLEtBQUssQ0FBQzs7SUFFOUIsTUFBTTtZQUFOLE1BQU07O0FBQ0UsV0FEUixNQUFNLENBQ0csSUFBSSxFQUFFOzBCQURmLE1BQU07O0FBRVIsK0JBRkUsTUFBTSw2Q0FFQTtBQUNSLFFBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNwQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDdEIsUUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUNoQyxRQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixJQUFJLGVBQWUsQ0FBQztBQUNqRSxRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7O0FBRXRDLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDakIsUUFBSSxDQUFDLHNCQUFzQixHQUFHLENBQUMsQ0FBQyxDQUFDO0FB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Q0FBQyxDQUFDLElBQUksQ0FBQztLQUM1RDs7O1NBOVJHLE1BQU07R0FBUyxZQUFZOztBQWlTakMsTUFBTSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsQ0FBQzs7UUFFeEIsTUFBTSxHQUFOLE1BQU07UUFBRSxtQkFBbUIsR0FBbkIsbUJBQW1CO3FCQUNyQixNQUFNIiwiZmlsZSI6ImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGZzLCBta2RpcnAgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBTdWJQcm9jZXNzLCBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSBldmVudHM7XG5cbmNvbnN0IFNUQVJUX1RJTUVPVVQgPSAxMDAwMDtcbmNvbnN0IERFVklDRV9DT05TT0xFX1BBVEggPSBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAnYnVpbGQnLCAnZGV2aWNlY29uc29sZScpO1xuY29uc3QgU1lTVEVNX0xPR19QQVRIID0gJy92YXIvbG9nL3N5c3RlbS5sb2cnO1xuLy8gV2Uga2VlcCBvbmx5IHRoZSBtb3N0IHJlY2VudCBsb2cgZW50cmllcyB0byBhdm9pZCBvdXQgb2YgbWVtb3J5IGVycm9yXG5jb25zdCBNQVhfTE9HX0VOVFJJRVNfQ09VTlQgPSAxMDAwMDtcblxuY2xhc3MgSU9TTG9nIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2ltID0gb3B0cy5zaW07XG4gICAgdGhpcy51ZGlkID0gb3B0cy51ZGlkO1xuICAgIHRoaXMuc2hvd0xvZ3MgPSAhIW9wdHMuc2hvd0xvZ3M7XG4gICAgdGhpcy5yZWFsRGV2aWNlTG9nZ2VyID0gb3B0cy5yZWFsRGV2aWNlTG9nZ2VyIHx8ICdpZGV2aWNlc3lzbG9nJztcbiAgICB0aGlzLnhjb2RlVmVyc2lvbiA9IG9wdHMueGNvZGVWZXJzaW9uO1xuXG4gICAgdGhpcy5wcm9jID0gbnVsbDtcbiAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICB0aGlzLmxvZ1JvdyA9ICcnO1xuICAgIHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA9IC0xO1xuICAgIHRoaXMubWF4QnVmZmVyU2l6ZSA9IE1BWF9MT0dfRU5UUklFU19DT1VOVDtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FwdHVyZVJlYWxEZXZpY2UgKCkge1xuICAgIGxldCBjbWQsIGFyZ3MsIGVudjtcbiAgICBpZiAoKHRoaXMucmVhbERldmljZUxvZ2dlciB8fCAnJykuaW5kZXhPZignaWRldmljZXN5c2xvZycpICE9PSAtMSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdBdHRlbXB0aW5nIGlPUyBkZXZpY2UgbG9nIGNhcHR1cmUgdmlhIGxpYmltb2JpbGVkZXZpY2UgaWRldmljZXN5c2xvZycpO1xuICAgICAgaWYgKHRoaXMucmVhbERldmljZUxvZ2dlci50b0xvd2VyQ2FzZSgpID09PSAnaWRldmljZXN5c2xvZycpIHtcbiAgICAgICAgY21kID0gJ2lkZXZpY2VzeXNsb2cnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCBpcyBhdmFpbGFibGUgb24gdGhlIFBBVEhcbiAgICAgICAgICBhd2FpdCBmcy53aGljaCgnaWRldmljZXN5c2xvZycpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHN5c3RlbSBpZGV2aWNlc3lzbG9nOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGV4ZWN1dGFibGUgZXhpc3RzXG4gICAgICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKHRoaXMucmVhbERldmljZUxvZ2dlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGlkZXZpY2VzeXNsb2cgZnJvbSAncmVhbERldmljZUxvZ2dlcicgY2FwYWJpbGl0eSAnJHt0aGlzLnJlYWxEZXZpY2VMb2dnZXJ9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGNtZCA9IHRoaXMucmVhbERldmljZUxvZ2dlcjtcbiAgICAgIH1cblxuICAgICAgYXJncyA9IFsnLXUnLCB0aGlzLnVkaWRdO1xuICAgICAgZW52ID0gcHJvY2Vzcy5lbnY7XG4gICAgfSBlbHNlIGlmICgodGhpcy5yZWFsRGV2aWNlTG9nZ2VyIHx8ICcnKS5pbmRleE9mKCdkZXZpY2Vjb25zb2xlJykgIT09IC0xKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0F0dGVtcHRpbmcgaU9TIGRldmljZSBsb2cgY2FwdHVyZSB2aWEgZGV2aWNlY29uc29sZScpO1xuICAgICAgbGV0IGRldmljZWNvbnNvbGU7XG4gICAgICBpZiAodGhpcy5yZWFsRGV2aWNlTG9nZ2VyLnRvTG93ZXJDYXNlKCkgPT09ICdkZXZpY2Vjb25zb2xlJykge1xuICAgICAgICBkZXZpY2Vjb25zb2xlID0gREVWSUNFX0NPTlNPTEVfUEFUSDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgdGhlIHBhdGggdG8gdGhlIGRpcmVjdG9yeSxcbiAgICAgICAgLy8gbm90IHRoZSBhY3R1YWwgZXhlY3V0YWJsZVxuICAgICAgICBsZXQgc3RhdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0ID0gYXdhaXQgZnMuc3RhdCh0aGlzLnJlYWxEZXZpY2VMb2dnZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGRldmljZWNvbnNvbGUgZnJvbSAncmVhbERldmljZUxvZ2dlcicgY2FwYWJpbGl0eSAnJHt0aGlzLnJlYWxEZXZpY2VMb2dnZXJ9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgZGV2aWNlY29uc29sZSA9IHRoaXMucmVhbERldmljZUxvZ2dlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhleSd2ZSBwYXNzZWQgaW4gYGRldmljZWNvbnNvbGVgIGFuZCBub3Qgc29tZXRoaW5nIHJhbmRvbVxuICAgICAgICAgIGlmICghXy5lbmRzV2l0aCh0aGlzLnJlYWxEZXZpY2VMb2dnZXIsICdkZXZpY2Vjb25zb2xlJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlICdkZXZpY2Vjb25zb2xlJyBpbnN0YWxsYXRpb24gZGlyZWN0b3J5IGZyb20gJyR7dGhpcy5yZWFsRGV2aWNlTG9nZ2VyfSdgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBleGVjdXRhYmxlLCBhbmQgdHJhaWxpbmcgYC9gLCB0byBnZXQgdGhlIGluc3RhbGwgZGlyZWN0b3J5XG4gICAgICAgICAgZGV2aWNlY29uc29sZSA9IHBhdGguZGlybmFtZSh0aGlzLnJlYWxEZXZpY2VMb2dnZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5kZWJ1ZyhgVXNpbmcgJ2RldmljZWNvbnNvbGUnIGZyb20gJyR7ZGV2aWNlY29uc29sZX0nYCk7XG5cbiAgICAgIGNtZCA9IGAke2RldmljZWNvbnNvbGV9L2RldmljZWNvbnNvbGVgO1xuICAgICAgYXJncyA9IFsnLXUnLCB0aGlzLnVkaWRdO1xuXG4gICAgICAvLyBzZXQgdXAgdGhlIGVudmlyb25tZW50IHRvIGJlIGFibGUgdG8gcnVuIGRldmljZWNvbnNvbGVcbiAgICAgIGVudiA9IF8uY2xvbmUocHJvY2Vzcy5lbnYpO1xuICAgICAgZW52LkRZTERfTElCUkFSWV9QQVRIID0gZGV2aWNlY29uc29sZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5EWUxEX0xJQlJBUllfUEFUSCkge1xuICAgICAgICBlbnYuRFlMRF9MSUJSQVJZX1BBVEggPSBgJHtlbnYuRFlMRF9MSUJSQVJZX1BBVEh9OiR7cHJvY2Vzcy5lbnYuRFlMRF9MSUJSQVJZX1BBVEh9YDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coYFVuYWJsZSB0byBjYXB0dXJlIGRldmljZSBsb2cuIFVua25vd24gJ3JlYWxEZXZpY2VMb2dnZXInOiAnJHt0aGlzLnJlYWxEZXZpY2VMb2dnZXJ9J2ApO1xuICAgIH1cblxuICAgIHRoaXMuc3VicHJvY2Vzc0lkID0gYCR7Y21kfV8ke3RoaXMudWRpZH1gO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBTdGFydGluZyBpT1MgZGV2aWNlIGxvZyBjYXB0dXJlIHdpdGg6ICcke2NtZH0nYCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gY2xlYW51cCBleGlzdGluZyBsaXN0ZW5lcnMgaWYgdGhlIHByZXZpb3VzIHNlc3Npb24gaGFzIG5vdCBiZWVuIHRlcm1pbmF0ZWQgcHJvcGVybHlcbiAgICAgIGF3YWl0IHRoaXMua2lsbEV4aXN0aW5nU3lzTG9nUHJvY2Vzc2VzKGNtZCwgYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIGp1c3QgdXNlIG9uZSBpbnN0YW5jZSBvZiAnaWRldmljZXN5c2xvZycgcGVyIHVkaWRcbiAgICB0aGlzLnByb2MgPSB0aGlzLmdldElEZXZpY2VTeXNMb2dQcm9jZXNzKGNtZCwgYXJncywgZW52KTtcblxuICAgIGF3YWl0IHRoaXMuZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlKCk7XG4gIH1cblxuICBhc3luYyBzdGFydENhcHR1cmVTaW11bGF0b3IgKCkge1xuICAgIC8vIG90aGVyd2lzZSwgaWYgd2UgaGF2ZSBhIHNpbXVsYXRvci4uLlxuICAgIGxvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgaU9TICR7YXdhaXQgdGhpcy5zaW0uZ2V0UGxhdGZvcm1WZXJzaW9uKCl9IHNpbXVsYXRvciBsb2cgY2FwdHVyZWApO1xuICAgIGlmICh0aGlzLnhjb2RlVmVyc2lvbi5tYWpvciA8IDUpIHtcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKCd0YWlsJywgWyctZicsICctbicsICcxJywgU1lTVEVNX0xPR19QQVRIXSk7XG4gICAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgeGNvZGUgNitcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLnNpbS51ZGlkKSkge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coYGlPUyBsb2cgY2FwdHVyZSB3aXRoIFhjb2RlICR7dGhpcy54Y29kZVZlcnNpb24udmVyc2lvblN0cmluZ30gcmVxdWlyZXMgYSBzaW0gdWRpZGApO1xuICAgIH1cblxuICAgIGxldCBsb2dQYXRoID0gdGhpcy5zaW0uZ2V0TG9nRGlyKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsb2dQYXRoLmluZGV4T2YoJyonKSA+PSAwKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgTG9nIHBhdGggaGFzICogaW4gaXQuIFVuYWJsZSB0byBzdGFydCBsb2cgY2FwdHVyZTogJHtsb2dQYXRofWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3lzdGVtTG9nUGF0aCA9IHBhdGgucmVzb2x2ZShsb2dQYXRoLCAnc3lzdGVtLmxvZycpO1xuICAgICAgbG9nZ2VyLmRlYnVnKGBTeXN0ZW0gbG9nIHBhdGg6ICR7c3lzdGVtTG9nUGF0aH1gKTtcbiAgICAgIGF3YWl0IG1rZGlycChsb2dQYXRoKTtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShzeXN0ZW1Mb2dQYXRoLCAnQSBuZXcgQXBwaXVtIHNlc3Npb24gaXMgYWJvdXQgdG8gc3RhcnQhXFxuJywge2ZsYWc6ICdhJ30pO1xuICAgICAgbGV0IGZpbGVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZXMgPSBhd2FpdCBmcy5nbG9iKHN5c3RlbUxvZ1BhdGgpO1xuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHN0YXJ0IGxvZyBjYXB0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBDb3VsZCBub3Qgc3RhcnQgbG9nIGNhcHR1cmUgYmVjYXVzZSBubyBpT1MgYCArXG4gICAgICAgICAgICAgICAgICAgICBgc2ltdWxhdG9yIGxvZ3MgY291bGQgYmUgZm91bmQgYXQgJHtzeXN0ZW1Mb2dQYXRofS4gYCArXG4gICAgICAgICAgICAgICAgICAgICBgTG9nZ2luZyB3aWxsIG5vdCBiZSBmdW5jdGlvbmFsIGZvciB0aGlzIHJ1bmApO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGFzdE1vZGlmaWVkTG9nUGF0aCA9IGZpbGVzWzBdO1xuICAgICAgbGV0IGxhc3RNb2RpZmllZExvZ1RpbWUgPSAoYXdhaXQgZnMuc3RhdChsYXN0TW9kaWZpZWRMb2dQYXRoKSkubXRpbWU7XG4gICAgICBmb3IgKGxldCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIGxldCB7bXRpbWV9ID0gYXdhaXQgZnMuc3RhdChmaWxlKTtcbiAgICAgICAgaWYgKG10aW1lID4gbGFzdE1vZGlmaWVkTG9nVGltZSkge1xuICAgICAgICAgIGxhc3RNb2RpZmllZExvZ1BhdGggPSBmaWxlO1xuICAgICAgICAgIGxhc3RNb2RpZmllZExvZ1RpbWUgPSBtdGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdGFpbEFyZ3MgPSBbJy1mJywgJy1uJywgJzEnLCBsYXN0TW9kaWZpZWRMb2dQYXRoXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGNsZWFudXAgZXhpc3RpbmcgbGlzdGVuZXJzIGlmIHRoZSBwcmV2aW91cyBzZXNzaW9uIGhhcyBub3QgYmVlbiB0ZXJtaW5hdGVkIHByb3Blcmx5XG4gICAgICAgIGF3YWl0IGV4ZWMoJ3BraWxsJywgWycteGYnLCBbJ3RhaWwnLCAuLi50YWlsQXJnc10uam9pbignICcpXSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3MoJ3RhaWwnLCB0YWlsQXJncyk7XG4gICAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmVycm9yQW5kVGhyb3coYFNpbXVsYXRvciBsb2cgY2FwdHVyZSBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RhcnRDYXB0dXJlICgpIHtcbiAgICBpZiAodGhpcy51ZGlkKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgcmVhbCBkZXZpY2VcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0YXJ0Q2FwdHVyZVJlYWxEZXZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RhcnRDYXB0dXJlU2ltdWxhdG9yKCk7XG4gIH1cblxuICBhc3luYyBmaW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUgKCkge1xuICAgIGlmICghdGhpcy5wcm9jKSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdygnQ291bGQgbm90IGNhcHR1cmUgZGV2aWNlIGxvZycpO1xuICAgIH1cbiAgICBsZXQgZmlyc3RMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLnByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICBpZiAoZmlyc3RMaW5lKSB7XG4gICAgICAgICAgaWYgKHN0ZG91dC5zdWJzdHIoLTEsIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgLy8gZG9uJ3Qgc3RvcmUgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGxvZyBiZWNhdXNlIGl0IGNhbWUgYmVmb3JlIHRoZSBzaW0gb3IgZGV2aWNlIHdhcyBsYXVuY2hlZFxuICAgICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nUm93ICs9IHN0ZG91dDtcbiAgICAgICAgICBpZiAoc3Rkb3V0LnN1YnN0cigtMSwgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ1JvdyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICB0aGlzLm9uT3V0cHV0KCdTVERFUlInKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBzZCA9IChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgaWYgKC9leGVjdnBcXChcXCkvLnRlc3Qoc3RkZXJyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lPUyBsb2cgY2FwdHVyZSBwcm9jZXNzIGZhaWxlZCB0byBzdGFydCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ZG91dCB8fCBzdGRlcnI7XG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnByb2Muc3RhcnQoc2QsIFNUQVJUX1RJTUVPVVQpO1xuICB9XG5cbiAgYXN5bmMgc3RvcENhcHR1cmUgKCkge1xuICAgIGlmICh0aGlzLnByb2MpIHtcbiAgICAgIGlmICh0aGlzLnVkaWQpIHtcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgVURJRCdzIGFyZSB1c2luZyAnaWRldmljZXN5c2xvZycga2lsbCBpdFxuICAgICAgICBjb25zdCBjYWNoZWRTeXNMb2cgPSBJT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3NbdGhpcy5zdWJwcm9jZXNzSWRdO1xuICAgICAgICBjYWNoZWRTeXNMb2cuY291bnQtLTtcbiAgICAgICAgaWYgKGNhY2hlZFN5c0xvZy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMua2lsbExvZ1N1YlByb2Nlc3MoKTtcbiAgICAgICAgICBkZWxldGUgSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5raWxsTG9nU3ViUHJvY2VzcygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMga2lsbExvZ1N1YlByb2Nlc3MgKCkge1xuICAgIGlmICh0aGlzLnByb2MuaXNSdW5uaW5nKSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1N0b3BwaW5nIGlPUyBsb2cgY2FwdHVyZScpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR1RFUk0nLCAxMDAwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdDYW5ub3Qgc3RvcCBsb2cgY2FwdHVyZSBwcm9jZXNzLiBTZW5kaW5nIFNJR0tJTEwuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoJ1NJR0tJTEwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbk91dHB1dCAocHJlZml4ID0gJycpIHtcbiAgICBsZXQgbG9ncyA9IHRoaXMubG9nUm93LnNwbGl0KCdcXG4nKTtcbiAgICBmb3IgKGxldCBsb2cgb2YgbG9ncykge1xuICAgICAgaWYgKCFsb2cpIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgICBsZXQgbG9nT2JqID0ge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGxldmVsOiAnQUxMJyxcbiAgICAgICAgbWVzc2FnZTogbG9nXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2dzLnB1c2gobG9nT2JqKTtcbiAgICAgIHRoaXMuZW1pdCgnb3V0cHV0JywgbG9nT2JqKTtcbiAgICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID4gdGhpcy5tYXhCdWZmZXJTaXplKSB7XG4gICAgICAgIHRoaXMubG9ncy5zaGlmdCgpO1xuICAgICAgICBpZiAodGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID4gMCkge1xuICAgICAgICAgIC0tdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaG93TG9ncykge1xuICAgICAgICBsZXQgc3BhY2UgPSBwcmVmaXgubGVuZ3RoID4gMCA/ICcgJyA6ICcnO1xuICAgICAgICBsb2dnZXIuaW5mbyhgW0lPU19TWVNMT0dfUk9XJHtzcGFjZX0ke3ByZWZpeH1dICR7bG9nfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldExvZ3MgKCkge1xuICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoICYmIHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA8IHRoaXMubG9ncy5sZW5ndGgpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmxvZ3M7XG4gICAgICBpZiAodGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID4gMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UodGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nSWR4U2luY2VMYXN0UmVxdWVzdCA9IHRoaXMubG9ncy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhc3luYyBnZXRBbGxMb2dzICgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dzO1xuICB9XG5cbiAgYXN5bmMga2lsbEV4aXN0aW5nU3lzTG9nUHJvY2Vzc2VzIChjbWQsIGFyZ3MpIHtcbiAgICBpZiAoIUlPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF0pIHtcbiAgICAgIGF3YWl0IGV4ZWMoJ3BraWxsJywgWycteGYnLCBbY21kLCAuLi5hcmdzXS5qb2luKCcgJyldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0ICdpZGV2aWNlc3lzbG9nJyBzdWJwcm9jZXNzIGZvciBhIGdpdmVuIHVkaWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FjaGVzIGFuZCByZS11c2VzIGluc3RhbmNlcyBzbyB0aGF0IHRoZXJlJ3NcbiAgICoganVzdCBvbmUgaW5zdGFuY2UgcGVyIGRldmljZSAoY2FjaGUgYnkgVURJRClcbiAgICovXG4gIGdldElEZXZpY2VTeXNMb2dQcm9jZXNzIChjbWQsIGFyZ3MsIGVudikge1xuICAgIGlmICghSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXSkge1xuICAgICAgbGV0IHtwcm9jfSA9IElPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF0gPSB7XG4gICAgICAgIHByb2M6IG5ldyBTdWJQcm9jZXNzKGNtZCwgYXJncywge2Vudn0pLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgIH07XG4gICAgICAvLyBJZiB0aGUgcHJvY2VzcyBkaWVzLCByZW1vdmUgaXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgIHByb2Mub24oJ2V4aXQnLCAoKSA9PiBkZWxldGUgSU9TTG9nLmNhY2hlZElEZXZpY2VTeXNMb2dzW3RoaXMuc3VicHJvY2Vzc0lkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF0uY291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIElPU0xvZy5jYWNoZWRJRGV2aWNlU3lzTG9nc1t0aGlzLnN1YnByb2Nlc3NJZF0ucHJvYztcbiAgfVxufVxuXG5JT1NMb2cuY2FjaGVkSURldmljZVN5c0xvZ3MgPSB7fTtcblxuZXhwb3J0IHsgSU9TTG9nLCBERVZJQ0VfQ09OU09MRV9QQVRIIH07XG5leHBvcnQgZGVmYXVsdCBJT1NMb2c7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
